<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on Jiang . &#39;s blog</title>
    <link>https://jfy0o0.github.io/categories/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on Jiang . &#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 12 Dec 2020 08:47:21 +0800</lastBuildDate><atom:link href="https://jfy0o0.github.io/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43; - STL Algorithm</title>
      <link>https://jfy0o0.github.io/2020/cpp_stl_algorithm/</link>
      <pubDate>Sat, 12 Dec 2020 08:47:21 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_stl_algorithm/</guid>
      <description>非修改性序列操作（12个） 循环          对序列中的每个元素执行某操作 for_each()    查找          在序列中找出某个值的第一次出现的位置 find()   在序列中找出符合某谓词的第一个元素 find_if()   在序列中找出一子序列的最后一次出现的位置 find_end()   在序列中找出第一次出现指定值集中之值的位置 find_first_of()   在序列中找出相邻的一对值 adjacent_find()    计数          在序列中统计某个值出现的次数 count()   在序列中统计与某谓词匹配的次数 count_if()    比较          找出两个序列相异的第一个元素 mismatch()   两个序列中的对应元素都相同时为真 equal()    搜索          在序列中找出一子序列的第一次出现的位置 search()   在序列中找出一值的连续n次出现的位置 search_n()    修改性序列操作（27个） 复制          从序列的第一个元素起进行复制 copy()   从序列的最后一个元素起进行复制 copy_backward()    交换          交换两个元素 swap()   交换指定范围的元素 swap_ranges()   交换由迭代器所指的两个元素 iter_swap()    变换          将某操作应用于指定范围的每个元素 transform()    替换          用一个给定值替换一些值 replace()   替换满足谓词的一些元素 replace_if()   复制序列时用一给定值替换元素 replace_copy()   复制序列时替换满足谓词的元素 replace_copy_if()    填充          用一给定值取代所有元素 fill()   用一给定值取代前n个元素 fill_n()    生成          用一操作的结果取代所有元素 generate()   用一操作的结果取代前n个元素 generate_n()    删除          删除具有给定值的元素 remove()   删除满足谓词的元素 remove_if()   复制序列时删除具有给定值的元素 remove_copy()   复制序列时删除满足谓词的元素 remove_copy_if()    唯一          删除相邻的重复元素 unique()   复制序列时删除相邻的重复元素 unique_copy()    反转          反转元素的次序 reverse()   复制序列时反转元素的次序 reverse_copy()    环移          循环移动元素 rotate()   复制序列时循环移动元素 rotate_copy()    随机          采用均匀分布来随机移动元素 random_shuffle()    划分          将满足某谓词的元素都放到前面 partition()   将满足某谓词的元素都放到前面并维持原顺序 stable_partition()    序列排序及相关操作（27个） 排序          以很好的平均效率排序 sort()   排序，并维持相同元素的原有顺序 stable_sort()   将序列的前一部分排好序 partial_sort()   复制的同时将序列的前一部分排好序 partial_sort_copy()    第n个元素          将第n各元素放到它的正确位置 nth_element()    二分检索          找到大于等于某值的第一次出现 lower_bound()   找到大于某值的第一次出现 upper_bound()   找到（在不破坏顺序的前提下）可插入给定值的最大范围 equal_range()   在有序序列中确定给定元素是否存在 binary_search()    归并          归并两个有序序列 merge()   归并两个接续的有序序列 inplace_merge()    有序结构上的集合操作          一序列为另一序列的子序列时为真 includes()   构造两个集合的有序并集 set_union()   构造两个集合的有序交集 set_intersection()   构造两个集合的有序差集 set_difference()   构造两个集合的有序对称差集（并-交） set_symmetric_difference()    堆操作          向堆中加入元素 push_heap()   从堆中弹出元素 pop_heap()   从序列构造堆 make_heap()   给堆排序 sort_heap()    最大和最小          两个值中较小的 min()   两个值中较大的 max()   序列中的最小元素 min_element()   序列中的最大元素 max_element()    词典比较          两个序列按字典序的第一个在前 lexicographical_compare()    排列生成器          按字典序的下一个排列 next_permutation()   按字典序的前一个排列 prev_permutation()    函数对象类模板    函数对象类模板 成员函数 T operator ( const T &amp;amp; x, const T &amp;amp; y) 的功能     plus  return x + y;   minus &amp;lt; &amp;gt; return x - y;   multiplies  return x * y;   divides  return x / y;   modulus  return x % y;        成员函数 bool operator( const T &amp;amp; x, const T &amp;amp; y) 的功能   equal_to  return x == y;   not_equal_to  return x!</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - lambda表达式</title>
      <link>https://jfy0o0.github.io/2020/cpp_lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Fri, 11 Dec 2020 16:54:59 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>lambda 说明  lambda表达式 就是一个函数（匿名函数），也就是没有函数名的函数。 为什么不需要函数名呢，因为我们直接（一次性的）用它，嵌入式用的它，不需要其他地方调用它。 lambda表达式也叫闭包，闭就是封闭的意思，就是其他地方都不用他，包就是函数。 lambda表达式其实就是一个函数对象，他内部创建了一个重载()操作符的类。  简易入门 //最简单的一个lambda表达式。 int main() { [] { }();//[]代表lambda表达式的开始，{}代表函数体，什么都没有，()代表调用函数. } // []() {}(); // 加了一个()代表函数参数。什么参数都没有，就可以省略。 输出 int main() { [] { cout &amp;lt;&amp;lt; &amp;#34;Hello, World!&amp;#34;; }(); auto lam = [] { cout &amp;lt;&amp;lt; &amp;#34;Hello, World!&amp;#34;; }; lam(); } 返回值 // -&amp;gt; int ：代表返回int。  int main() { auto lam =[]() -&amp;gt; int { cout &amp;lt;&amp;lt; &amp;#34;Hello, World!&amp;#34;; return 1; }; auto ret = lam(); auto lam2 =[]() -&amp;gt; string { cout &amp;lt;&amp;lt; &amp;#34;Hello, World!</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - cast用法</title>
      <link>https://jfy0o0.github.io/2020/cpp_cast%E7%94%A8%E6%B3%95/</link>
      <pubDate>Thu, 10 Dec 2020 11:34:01 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_cast%E7%94%A8%E6%B3%95/</guid>
      <description>static_cast static_cast&amp;lt; new_type &amp;gt;(expression)  相当于传统的C语言里的强制转换 把expression转换为new_type类型 编译时检查，用于非多态的转换，可以转换指针及其他 没有运行时类型检查来保证转换的安全性  用法  用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。  进行上行转换（把派生类的指针或引用转换成基类表示）是安全的； 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。   用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。 把空指针转换成目标类型的空指针。 把任何类型的表达式转换成void类型。 static_cast不能转换掉expression的const、volatile、或者__unaligned属性  例子 char a = &amp;#39;a&amp;#39;; int b = static_cast&amp;lt;int&amp;gt;(a);//正确，将char型数据转换成int型数据  double *c = new double; void *d = static_cast&amp;lt;void*&amp;gt;(c);//正确，将double指针转换成void指针  int e = 10; const int f = static_cast&amp;lt;const int&amp;gt;(e);//正确，将int型数据转换成const int型数据  const int g = 20; int *h = static_cast&amp;lt;int*&amp;gt;(&amp;amp;g);//编译错误，static_cast不能转换掉g的const属性  class Base {}; class Derived : public Base {} Base* pB = new Base(); if(Derived* pD = static_cast&amp;lt;Derived*&amp;gt;(pB)) {}//下行转换是不安全的(坚决抵制这种方法)  Derived* pD = new Derived(); if(Base* pB = static_cast&amp;lt;Base*&amp;gt;(pD)) {}//上行转换是安全的 dynamic_cast dynamic_cast&amp;lt; type* &amp;gt;(e) //type必须是一个类类型且必须是一个有效的指针 dynamic_cast&amp;lt; type&amp;amp; &amp;gt;(e) //type必须是一个类类型且必须是一个左值 dynamic_cast&amp;lt; type&amp;amp;&amp;amp; &amp;gt;(e) //type必须是一个类类型且必须是一个右值 e的类型必须符合以下三个条件中的任何一个：</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - new的三种用法</title>
      <link>https://jfy0o0.github.io/2020/cpp_new%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95/</link>
      <pubDate>Fri, 04 Dec 2020 10:19:49 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_new%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95/</guid>
      <description>new用法总结 new可以说是个
 一个关键字， 一个运算符 可以被重载。  new operator 这个就是平时最经常用的new，用法如下程序所示：
class A { public: A(int i) :a(i){} private: int a; }; int main() { A* example = new A(1); } 说明 new operator实际上执行了以下三个步骤：
 调用operator new分配内存（后面要说的第二种new），  如果类本身定义了operator new，那么会调用类自己的operator new，而不是全局的； 如果未定义，则是全局的   调用A的构造函数A::A(int)； 返回相应的指针  operator new operator new不调用构造函数，而仅仅分配内存，
有两个版本，
 前者抛出异常 后者当失败时不抛出异常，而是直接返回：  void* operator new (std::size_t size); void* operator new (std::size_t size, const std::nothrow_t&amp;amp; nothrow_value) noexcept; class A { public: A(int i) :a(i){} void* operator new(size_t size) { cout &amp;lt;&amp;lt; &amp;#34;call A::operator new&amp;#34; &amp;lt;&amp;lt; endl; return malloc(size); } void operator delete(void* p) { cout &amp;lt;&amp;lt; &amp;#34;call A::operator delete&amp;#34; &amp;lt;&amp;lt; endl; return free(p); } void* operator new(size_t size, const nothrow_t&amp;amp; nothrow_value) noexcept { cout &amp;lt;&amp;lt; &amp;#34;call A::operator new (noexcept)&amp;#34; &amp;lt;&amp;lt; endl; return malloc(size); } void operator delete(void* p, const nothrow_t&amp;amp; nothrow_value) noexcept { cout &amp;lt;&amp;lt; &amp;#34;call A::operator delete (noexcept)&amp;#34; &amp;lt;&amp;lt; endl; free(p); } private: int a; }; int main() { A* example1 = new A(1); delete example1; A* example2 = new(nothrow) A(2); delete example2; } placement new placement new仅在一个已经分配好的内存指针上调用构造函数，基本形式如下：</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - 使用技巧</title>
      <link>https://jfy0o0.github.io/2020/cpp_%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Thu, 03 Dec 2020 18:44:42 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <description>变长数组 特点：
 变长 空间合理  eg: struct MutableLenArray { int count; char p[0]; }; 宏的妙用 1. “#”符号把一个符号直接转换为字符串，例如：
#define TO_STRING(x) #x const char *str = TO_STRING( test ); ##符号会连接两个符号，从而产生新的符号(词法层次)，例如：
#define SIGN( x ) INT_##x int SIGN( 1 ); //宏被展开后将成为：int INT_1; 2. 变参宏 #define LOG( format, ... ) printf( format, __VA_ARGS__ ) LOG( &amp;#34;%s %d&amp;#34;, str, count );  VA_ARGS是系统预定义宏，被自动替换为参数列表。 经常需要进行输出格式化，重定义时，可以用到以上技巧。  不定参 模板实现： template&amp;lt;typename... T&amp;gt; void func(T... args) { for (auto x : {args.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - 运算符重载小技巧</title>
      <link>https://jfy0o0.github.io/2020/cpp_%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%B0%8F%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Thu, 12 Nov 2020 15:54:13 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid>
      <description>c++ - 运算符重载小技巧 重载 () ： 多次调用(),然后再调用print()
class A{ public: A operator()(int a) { cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt;endl; return *this; } void print() { cout &amp;lt;&amp;lt; &amp;#34;hello&amp;#34;&amp;lt;&amp;lt;endl; } }; int main() { A a; a(54)(434).print(); //54 	//434 	//hello } 重载 ++ ： ++ 运算符，还可分为前缀 ++ 和后缀 ++ 运算符。
class Length { private: int len_inches; public: //前缀++的声明  Length operator++ ()； //后缀++的声明  Length operator++ (int)； }; 重载前缀++运算符: C++允许重载前缀运算符，以使表达式 ++b 能递增 b 的长度值，并返回结果对象。该运算符可以作为成员函数来重载，这使得它的单个形参是隐含的， 所以重载运算符不需要形参。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - cmake</title>
      <link>https://jfy0o0.github.io/2020/cpp_cmake/</link>
      <pubDate>Mon, 09 Nov 2020 13:47:22 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_cmake/</guid>
      <description>cmake 1.指定 cmake 的最小版本 cmake_minimum_required(VERSION 3.4.1)这行命令是可选的，我们可以不写这句话，但在有些情况下，如果 CMakeLists.txt 文件中使用了一些高版本 cmake 特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行 cmake。
2.设置项目名称 project(demo)这个命令不是强制性的，但最好都加上。它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。
3.设置编译类型 add_executable(demo demo.cpp) # 生成可执行文件 add_library(common STATIC util.cpp) # 生成静态库 add_library(common SHARED util.cpp) # 生成动态库或共享库 #add_library 默认生成是静态库，通过以上命令生成文件名字， 4.指定编译包含的源文件 4.1 明确指定包含哪些源文件 add_library(demo demo.cpp test.cpp util.cpp)4.2 搜索所有的 cpp 文件 aux_source_directory(dir VAR) 发现一个目录下所有的源代码文件并将列表存储在一个变量中。 aux_source_directory(. SRC_LIST) # 搜索当前目录下的所有.cpp文件 add_library(demo ${SRC_LIST})4.3 自定义搜索规则 file(GLOB SRC_LIST &amp;#34;*.cpp&amp;#34; &amp;#34;protocol/*.cpp&amp;#34;)add_library(demo ${SRC_LIST})#或者 file(GLOB SRC_LIST &amp;#34;*.cpp&amp;#34;)file(GLOB SRC_PROTOCOL_LIST &amp;#34;protocol/*.cpp&amp;#34;)add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})#或者 aux_source_directory(. SRC_LIST)aux_source_directory(protocol SRC_PROTOCOL_LIST)add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})5.</description>
    </item>
    
  </channel>
</rss>
