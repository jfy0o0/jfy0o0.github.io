<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Jiang . &#39;s blog</title>
    <link>https://jfy0o0.github.io/posts/</link>
    <description>Recent content in Posts on Jiang . &#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 30 Mar 2021 15:59:46 +0800</lastBuildDate><atom:link href="https://jfy0o0.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Other - 公私钥、加验签、CA</title>
      <link>https://jfy0o0.github.io/2021/other-%E5%85%AC%E7%A7%81%E9%92%A5%E5%8A%A0%E9%AA%8C%E7%AD%BEca/</link>
      <pubDate>Tue, 30 Mar 2021 15:59:46 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/other-%E5%85%AC%E7%A7%81%E9%92%A5%E5%8A%A0%E9%AA%8C%E7%AD%BEca/</guid>
      <description>公私钥加解密，加验签梳理 对称加密和非对称加密。  对称加密：也就是加密和解密所使用的密钥是同一个，常用到的有AES、DES、3DES等等，这类加密方式容易理解，不过多赘述。 非对称加密：加密和解密所使用的密钥是一对，也就是两个，  若A、B是一对密钥，那么加密使用A则解密只能使用B， 加密使用B则解密只能使用A。   这也就是公私钥的原型。 公钥加密，私钥解密。  数字签名 ​	加解密问题解决了，但是网络通讯远没有这么简单，报文信息被黑客拦截了怎么办？拦截后黑客替换成他的报文，还能用公钥继续加密发出去，那不就完了，所以我们还需要个方式来验证发送方的身份，也就是我们经常听说的数字签名。
​	数字签名和加解密不同，是对一段信息做hash算法（MD5，RSA等）运算，生成唯一标识该信息的一个特征串，比如你小时候背课文，背完让家长签名（加签），然后第二天老师检查签名（验签），老师就会认为你完成了作业。老师认为该签名唯一且只能由你家长生成，所以认同你背过课文。（虽然你可以模仿）。
​	那么我们要做的就是对我们的密文信息再进行一次签名，将签名得到的签名特征串附在原文后，那么对方接收到报文以后，如果能验签通过，那就能确定消息是你发的了。
 私钥加签，公钥验签  ​	网络通讯中我们一般用自己的私钥加签将报文，用第三方提供的公钥将报文中涉及安全隐私的部分加密，然后第三方会用我们提供公钥进行验签，验签通过后再用他们自己的私钥将报文加密部分解密。
​	如果还需要响应返回，那么他们还将重复一遍我们这边的过程，我们这边也需要重复一边他们那边的过程，用他们提供的公钥验签返回回来的报文，并用自己的私钥解密隐私部分。
​	这里又有个问题，既然公钥是公开的，你如何确定这个公钥是你的而不是别人的？这样一想，其实就变成了一个循环，没法证明绝对安全，鸡生蛋蛋生鸡的问题。
ca 其实在密码学中也是这样，你必须建立一个信赖点，不然任何都是无法信赖的。所以在此基础上，出现了一个可信任的第三方认证中心（CA），
 CA把你的公钥进行认证，并颁发一个数字证书给到你，该证书里面包含了你的公钥， 而你给别人的公钥也替换成数字证书， 别人拿到数字证书，看了下，确实是CA签发的，那么这里面的公钥就是你的，你是可信的。 这里就又把大家所迷惑的一个概念理清楚了， 证书就是经过认证的公钥。  </description>
    </item>
    
    <item>
      <title>C&#43;&#43; - 标准属性</title>
      <link>https://jfy0o0.github.io/2021/cpp_%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Sat, 20 Feb 2021 15:06:32 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/cpp_%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7/</guid>
      <description>标准属性  C++11后引入了 C++ 标准属性1。在 C++ 11 中，属性提供一种标准化的方法添加批注的其他信息，也可能不是特定于供应商的 C++ 构造 （包括但不是限于类、 函数、 变量和块）。 用于生成信息性消息，或应用特殊逻辑，编译特性化的代码时，编译器可以使用此信息。 编译器将忽略无法识别的任何属性，这意味着你不能定义自定义属性。 使用此语法，属性将由双方括号标明。     attribute-token 属性 值 标准 作用     carries_dependency [[carries_dependency]] 200809L (C++11) 指示释放消费 std::memory_order 中的依赖链传进和传出该函数，这允许编译器跳过不必要的内存栅栏指令。   noreturn [[noreturn]] 200809L (C++11) 表示函数不返回值,并只能应用在函数上面,如果函数真的有返回值，那么该属性无效,并且会给出警告   deprecated [[deprecated]] [[deprecated(“reason”)]] 201309L (C++14) 表示某些实体已经废弃，或者因为某些原因废弃，可以用在类，定义类型名，变量，非静态数据成员，枚举，模板实例   fallthrough [[fallthrough]] 201603L (C++17) 指示从前一 case 标号直落是有意的，而在发生直落时给出警告的编译器不应该为此诊断。   maybe_unused [[maybe_unused]] 201603L (C++17) 压制编译器在未使用实体上的警告，若存在。   nodiscard [[nodiscard]] [[nodiscard(“reason”)]] 201603L (C++17) (C++20) 若返回值被舍弃，则鼓励编译器发布警告。   likely [[likely]] 201803L C++20) 指示编译器应该针对通过某语句的执行路径比任何其他执行路径更可能或更不可能的情况进行优化。   unlikely [[unlikely]] 201803L (C++20) 指示编译器应该针对通过某语句的执行路径比任何其他执行路径更可能或更不可能的情况进行优化。   no_unique_address [[no_unique_address]] 201803L (C++20) 指示非静态数据成员不需要拥有不同于其类的所有其他非静态数据成员的地址。    </description>
    </item>
    
    <item>
      <title>C&#43;&#43; - openmp</title>
      <link>https://jfy0o0.github.io/2021/cpp_openmp/</link>
      <pubDate>Fri, 29 Jan 2021 10:49:45 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/cpp_openmp/</guid>
      <description>openmp 并行开发
标准并行模式执行代码的基本思想是，
 程序开始时只有一个主线程， 程序中的串行部分都由主线程执行， 并行的部分是通过派生其他线程来执行， 但是如果并行部分没有结束时是不会执行串行部分的  使用 1.头文件 #include &amp;lt;omp.h&amp;gt; 2.cmake add_link_options(-fopenmp)add_executable(test main.cpp)FIND_PACKAGE(OpenMP REQUIRED)if (OPENMP_FOUND) message(&amp;#34;OPENMP FOUND&amp;#34;) set(CMAKE_C_FLAGS &amp;#34;${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}&amp;#34;) set(CMAKE_CXX_FLAGS &amp;#34;${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}&amp;#34;)endif ()指令格式 在C++中，OpenMP的指令格式为：
＃pragma omp 指令 [子句[子句]…] **例如： **
#pragma omp parallel private(i, j) parallel 就是指令， private是子句
1. OpenMP的指令 OpenMP的指令有以下一些：（常用的已标黑）
 parallel，用在一个代码段之前，表示这段代码将被多个线程并行执行 for，用于for循环之前，将循环分配到多个线程中并行执行，必须保证每次循环之间无相关性。 parallel for， parallel 和 for语句的结合，也是用在一个for循环之前，表示for循环的代码将被多个线程并行执行。 sections，用在可能会被并行执行的代码段之前 parallel sections，parallel和sections两个语句的结合 critical，用在一段代码临界区之前 single，用在一段只被单个线程执行的代码段之前，表示后面的代码段将被单线程执行。 flush， barrier，用于并行区内代码的线程同步，所有线程执行到barrier时要停止，直到所有线程都执行到barrier时才继续往下执行。 atomic，用于指定一块内存区域被制动更新 master，用于指定一段代码块由主线程执行 ordered， 用于指定并行区域的循环按顺序执行 threadprivate, 用于指定一个变量是线程私有的。  例子1：
#include &amp;lt;iostream&amp;gt;#include &amp;#34;omp.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - c&#43;&#43;17特性</title>
      <link>https://jfy0o0.github.io/2021/cpp_17%E7%89%B9%E6%80%A7/</link>
      <pubDate>Thu, 28 Jan 2021 17:05:27 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/cpp_17%E7%89%B9%E6%80%A7/</guid>
      <description>c++17特性 1.关键字 1. auto关键字 从c++11开始，auto关键字能够通过初始化器推导出变量的类型。在c++14中，auto关键字的能力进一步提升，能够通过return语句推导出函数的返回类型。 使用auto关键字能够提高编码效率，同时能够简化重构流程。但是，C++11中的auto推导，往往结果与预期的不同。
c++11 中为了支持统一初始化，引入了新的统一初始化语法，如下所示。
// c++11 auto x3{ 1, 2 }; // std::initializer_list&amp;lt;int&amp;gt; auto x4 = { 3 }; // decltype(x4) is std::initializer_list&amp;lt;int&amp;gt; auto x5{ 3 }; // std::initializer_list&amp;lt;int&amp;gt; 这三种方式初始化的变量，最终类型推导的结果都是 std::initializer_list ， 而不是我们认为的int。 这是因为 当用于auto声明变量的表达式是{}括起来的，推导的型别就会变成 std::initializer_list。
在C++17中，对auto表达式推导的规则进行了改变
// c++17 auto x3{ 1, 2 }; // error: not a single element auto x4 = { 3 }; // decltype(x4) is std::initializer_list&amp;lt;int&amp;gt; auto x5{ 3 }; // decltype(x5) is int 对比发现， auto x5{3}, 会直接将变量推导成 x5， 而 x3{1, 2} 这种方式也会编译失败。auto推导的规则变得更加直观。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - c&#43;&#43;14特性</title>
      <link>https://jfy0o0.github.io/2021/cpp_14%E7%89%B9%E6%80%A7/</link>
      <pubDate>Thu, 28 Jan 2021 16:35:46 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/cpp_14%E7%89%B9%E6%80%A7/</guid>
      <description>C++14 Lambda 函数 C++14 的泛型 Lambda 使编写如下语句成为可能：
auto lambda = [](auto x， auto y) {return x + y;}; 而另一方面，C++11 要求 Lambda 参数使用具体的类型声明，比如：
auto lambda = [](int x， int y) {return x + y;}; 此外，新标准中的 std::move 函数可用于捕获 Lambda 表达式中的变量，这是通过移动对象而非复制或引用对象实现的：
std::unique_ptr ptr (new int (10)); auto lambda = [value = std::move (ptr)] {return *value;}; int a = 2; [a = sin(a)]() { cout &amp;lt;&amp;lt; cos(a) &amp;lt;&amp;lt; endl; //0.6143 	}(); cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; //2 	cout &amp;lt;&amp;lt; cos(a) &amp;lt;&amp;lt; endl;//-0.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - c&#43;&#43;11特性</title>
      <link>https://jfy0o0.github.io/2021/cpp_11%E7%89%B9%E6%80%A7/</link>
      <pubDate>Thu, 28 Jan 2021 15:31:27 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/cpp_11%E7%89%B9%E6%80%A7/</guid>
      <description>C++11 特性 1 变量和基本类型 1.1 long long 类型 扩展精度浮点数，10位有效数字
1.2 列表初始化 初始化的几种不同形式，其中用花括号来初始化变量称为列表初始化；
int i = 0; int i = {0}; int i{0}; int i(0);  需要注意的是，当用于内置类型的变量时，这种初始化形式有一个重要的特点： 如果我们使用初始化且初始值存在丢失信息的风险，则编译器报错；  long double ld = 3.1414141414; int a{ld}, b = {ld}; //报错 int c(ld), d = ld; //正确 1.3 nullptr 常量 int *p1 = nullptr; // 等价于int *p1 = 0; 1.4 constexpr 变量 将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式；
声明为constexpr的变量一定是一个常量，而且必须用常量表达式来初始化，比如说下面的情况则是不正确的：
int t = 10; constexpr int q = t + 20; cout &amp;lt;&amp;lt; &amp;#34;q&amp;#34; &amp;lt;&amp;lt; q &amp;lt;&amp;lt; endl; 需要将t声明为 const 才是正确的；</description>
    </item>
    
    <item>
      <title>Linux Soft - valgrind</title>
      <link>https://jfy0o0.github.io/2021/linux-%E8%BD%AF%E4%BB%B6-valgrind/</link>
      <pubDate>Fri, 22 Jan 2021 08:51:12 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/linux-%E8%BD%AF%E4%BB%B6-valgrind/</guid>
      <description>valgrind  Valgrind是一个GPL的软件，用于Linux（For x86, amd64 and ppc32）程序的内存调试和代码剖析。 你可以在它的环境中运行你的程序来监视内存的使用情况，比如C 语言中的malloc和free或者 C++中的new和 delete。 使用Valgrind的工具包，你可以自动的检测许多内存管理和线程的bug，避免花费太多的时间在bug寻找上，使得你的程序更加稳固。  功能 Valgrind工具包包含多个工具，如Memcheck,Cachegrind,Helgrind, Callgrind，Massif
下面分别介绍个工具的作用
Memcheck  使用未初始化的内存 (Use of uninitialised memory) 使用已经释放了的内存 (Reading/writing memory after it has been free’d) 使用超过 malloc分配的内存空间(Reading/writing off the end of malloc’d blocks) 对堆栈的非法访问 (Reading/writing inappropriate areas on the stack) 申请的空间是否有释放 (Memory leaks – where pointers to malloc’d blocks are lost forever) malloc/free/new/delete申请和释放内存的匹配(Mismatched use of malloc/new/new [] vs free/delete/delete []) src和dst的重叠(Overlapping src and dst pointers in memcpy() and related functions)  Callgrind  Callgrind收集程序运行时的一些数据，函数调用关系等信息，还可以有选择地进行cache模拟。 在运行结束时，它会把分析数据写入一个文件。callgrind_annotate可以把这个文件的内容转化成可读的形式。  Cachegrind  它模拟 CPU中的一级缓存I1,D1和L2二级缓存，能够精确地指出程序中 cache的丢失和命中。 如果需要，它还能够为我们提供cache丢失次数，内存引用次数，以及每行代码，每个函数，每个模块，整个程序产生的指令数。这对优化程序有很大的帮助。  Helgrind  它主要用来检查多线程程序中出现的竞争问题。 Helgrind寻找内存中被多个线程访问，而又没有一贯加锁的区域，这些区域往往是线程之间失去同步的地方，而且会导致难以发掘的错误。 Helgrind实现了名为” Eraser” 的竞争检测算法，并做了进一步改进，减少了报告错误的次数。  Massif  堆栈分析器，它能测量程序在堆栈中使用了多少内存，告诉我们堆块，堆管理块和栈的大小。 Massif能帮助我们减少内存的使用，在带有虚拟内存的现代系统中，它还能够加速我们程序的运行，减少程序停留在交换区中的几率。  应用 1、检查内存错误： 如果我们想用valgrind的内存检测工具，我们就要用如下方法调用：</description>
    </item>
    
    <item>
      <title>db - rdbms</title>
      <link>https://jfy0o0.github.io/2021/db-rdbms/</link>
      <pubDate>Wed, 20 Jan 2021 13:56:14 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/db-rdbms/</guid>
      <description>sql  SQL是结构化查询语言的缩写，用来访问和操作数据库系统。 SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。 不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。  能力 总的来说，SQL语言定义了这么几种操作数据库的能力：
DDL：Data Definition Language
​	DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。
DML：Data Manipulation Language
​	DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。
DQL：Data Query Language
​	DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。
语法特点  SQL语言关键字不区分大小写！！！ 但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。 同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。  数据模型 数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型：
 层次模型 (树) 网状模型 (图) 关系模型 (表)  rdbms 数据类型 对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：
   名称 类型 说明     INT 整型 4字节整数类型，范围约+/-21亿   BIGINT 长整型 8字节整数类型，范围约+/-922亿亿   REAL 浮点型 4字节浮点数，范围约+/-1038   DOUBLE 浮点型 8字节浮点数，范围约+/-10308   DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算   CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串   VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串   BOOLEAN 布尔类型 存储True或者False   DATE 日期类型 存储日期，例如，2018-06-22   TIME 时间类型 存储时间，例如，12:20:59   DATETIME 日期和时间类型 存储日期+时间，例如，2018-06-22 12:20:59    关系模型  表的每一行称为记录（Record），记录是一个逻辑意义上的数据。 表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。  主键 在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，students表的两行记录：</description>
    </item>
    
    <item>
      <title>Other - 内存池</title>
      <link>https://jfy0o0.github.io/2021/other-%E5%86%85%E5%AD%98%E6%B1%A0/</link>
      <pubDate>Thu, 07 Jan 2021 15:30:29 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/other-%E5%86%85%E5%AD%98%E6%B1%A0/</guid>
      <description>内存池 1. 内存池设计 1.1 目的 在给定的内存buffer上建立内存管理机制，根据用户需求从该buffer上分配内存或者将已经分配的内存释放回buffer中。
1.2 要求 尽量减少内存碎片，平均效率高于C语言的malloc和free。
1.3 设计思路  一个存储全部内存的容器 一个存储正在使用的内存的容器 一个存储未被使用的容器  实现 #ifndef TESTJSON_MEMORYPOOL_HPP #define TESTJSON_MEMORYPOOL_HPP  #include &amp;lt;algorithm&amp;gt;#include &amp;lt;functional&amp;gt;#include &amp;lt;set&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;lt;queue&amp;gt;#include &amp;lt;cstdlib&amp;gt;#include &amp;lt;cxxabi.h&amp;gt; template&amp;lt;typename T&amp;gt; class MemoryPool { public: MemoryPool(); MemoryPool(int max_size); virtual ~MemoryPool(); T *alloc(); void release(T *obj); void walkUsedMemList(std::function&amp;lt;void(T *)&amp;gt; func); private: static int ALLOC_STEP; int mMaxSize; int mCurrentSize; std::queue&amp;lt;T *&amp;gt; mFreeMemList; std::set&amp;lt;T *&amp;gt; mUsedMemList; int newMemList(int size); }; template&amp;lt;class T&amp;gt; int MemoryPool&amp;lt;T&amp;gt;::ALLOC_STEP = 20; template&amp;lt;class T&amp;gt; MemoryPool&amp;lt;T&amp;gt;::MemoryPool() { this-&amp;gt;mCurrentSize = 0; this-&amp;gt;mMaxSize = 0; this-&amp;gt;newMemList(ALLOC_STEP); } template&amp;lt;class T&amp;gt; MemoryPool&amp;lt;T&amp;gt;::MemoryPool(int max_size) { this-&amp;gt;mCurrentSize = 0; this-&amp;gt;mMaxSize = max_size; this-&amp;gt;newMemList(ALLOC_STEP); } template&amp;lt;class T&amp;gt; MemoryPool&amp;lt;T&amp;gt;::~MemoryPool() { for_each(mUsedMemList.</description>
    </item>
    
    <item>
      <title>Go - Go Module</title>
      <link>https://jfy0o0.github.io/2021/go-go-module/</link>
      <pubDate>Tue, 05 Jan 2021 16:41:46 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/go-go-module/</guid>
      <description>go mod 命令 go mod download 下载依赖的module到本地cache（默认为$GOPATH/pkg/mod目录） go mod edit 编辑go.mod文件 go mod graph 打印模块依赖图 go mod init 初始化当前文件夹, 创建go.mod文件 go mod tidy 增加缺少的module，删除无用的module go mod vendor 将依赖复制到vendor下 go mod verify 校验依赖 go mod why 解释为什么需要依 例子 module github.com/Q1mi/studygo/blogger go 1.12 require ( github.com/DeanThompson/ginpprof v0.0.0-20190408063150-3be636683586 github.com/gin-gonic/gin v1.4.0 github.com/go-sql-driver/mysql v1.4.1 github.com/jmoiron/sqlx v1.2.0 github.com/satori/go.uuid v1.2.0 google.golang.org/appengine v1.6.1 // indirect )  module用来定义包名 require用来定义依赖包及版本 indirect表示间接引用  依赖的版本 go mod支持语义化版本号，比如go get foo@v1.2.3，也可以跟git的分支或tag，比如go get foo@master，当然也可以跟git提交哈希，比如go get foo@e3702bed2。关于依赖的版本支持以下几种格式：</description>
    </item>
    
    <item>
      <title>Other - protoBuf</title>
      <link>https://jfy0o0.github.io/2021/other-protobuf/</link>
      <pubDate>Tue, 05 Jan 2021 10:55:26 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/other-protobuf/</guid>
      <description>ProtoBuf 定义  protocol buffers 是一种语言无关、平台无关、可扩展的序列化结构数据的方法，它可用于（数据）通信协议、数据存储等。 Protocol Buffers 是一种灵活，高效，自动化机制的结构数据序列化方法－可类比 XML，但是比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单。 你可以定义数据的结构，然后使用特殊生成的源代码轻松的在各种数据流中使用各种语言进行编写和读取结构数据。你甚至可以更新数据结构，而不破坏由旧数据结构编译的已部署程序。  特点 简单来讲， ProtoBuf 是结构数据序列化[1] 方法，可简单类比于 XML[2]，其具有以下特点：
 语言无关、平台无关。即 ProtoBuf 支持 Java、C++、Python 等多种语言，支持多个平台 高效。即比 XML 更小（3 ~ 10倍）、更快（20 ~ 100倍）、更为简单 扩展性、兼容性好。你可以更新数据结构，而不影响和破坏原有的旧程序  序列化[1]：将结构数据或对象转换成能够被存储和传输（例如网络传输）的格式，同时应当要保证这个序列化结果在之后（可能在另一个计算环境中）能够被重建回原来的结构数据或对象。
类比于 XML[2]：这里主要指在数据通信和数据存储应用场景中序列化方面的类比，但个人认为 XML 作为一种扩展标记语言和 ProtoBuf 还是有着本质区别的。
使用 对 ProtoBuf 的基本概念有了一定了解之后，我们来看看具体该如何使用 ProtoBuf。
第一步，创建 .proto 文件，定义数据结构，如下例1所示： // 例1: 在 xxx.proto 文件中定义 Example1 message message Example1 { optional string stringVal = 1; optional bytes bytesVal = 2; message EmbeddedMessage { int32 int32Val = 1; string stringVal = 2; } optional EmbeddedMessage embeddedExample1 = 3; repeated int32 repeatedInt32Val = 4; repeated string repeatedStringVal = 5;}我们在上例中定义了一个名为 Example1 的 消息，语法很简单，message 关键字后跟上消息名称：</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - shared_ptr陷阱</title>
      <link>https://jfy0o0.github.io/2020/cpp_shared_ptr%E9%99%B7%E9%98%B1/</link>
      <pubDate>Thu, 24 Dec 2020 19:55:07 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_shared_ptr%E9%99%B7%E9%98%B1/</guid>
      <description>1：不要把一个原生指针给多个shared_ptr管理 int* ptr = new int; shared_ptr&amp;lt;int&amp;gt; p1(ptr); shared_ptr&amp;lt;int&amp;gt; p2(ptr); //logic error  ptr对象被删除了2次 这种问题比喻成“二龙治水”，在原生指针中也同样可能发生。  2：不要把this指针给shared_ptr #include &amp;lt;memory&amp;gt;#include &amp;lt;iostream&amp;gt; class Bad { public: std::shared_ptr&amp;lt;Bad&amp;gt; getptr() { return std::shared_ptr&amp;lt;Bad&amp;gt;(this); } ~Bad() { std::cout &amp;lt;&amp;lt; &amp;#34;Bad::~Bad() called&amp;#34; &amp;lt;&amp;lt; std::endl; } }; int main() { // 错误的示例，每个shared_ptr都认为自己是对象仅有的所有者 	std::shared_ptr&amp;lt;Bad&amp;gt; bp1(new Bad()); std::shared_ptr&amp;lt;Bad&amp;gt; bp2 = bp1-&amp;gt;getptr(); // 打印bp1和bp2的引用计数 	std::cout &amp;lt;&amp;lt; &amp;#34;bp1.use_count() = &amp;#34; &amp;lt;&amp;lt; bp1.use_count() &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;bp2.use_count() = &amp;#34; &amp;lt;&amp;lt; bp2.</description>
    </item>
    
    <item>
      <title>Boost - asio</title>
      <link>https://jfy0o0.github.io/2020/boost-asio/</link>
      <pubDate>Thu, 24 Dec 2020 15:01:01 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-asio/</guid>
      <description>asio  Boost.Asio是一个跨平台的C++库，主要用于网络和其他一些底层的I/O编程。 Boost.Asio成功的抽象了包括网络，串口、文件在内的同步和异步的I/O操作： Boost.Asio支持大多数操作系统，轻量可扩展的，目前网络部分支持TCP, UDP, IMCP，可以很方便的扩展自定义协议。  注意  把lambda表达式声明成类得成员变量 ，而不是一个局部变量。 虽然io_service拷贝handler以备异步调用，但是handler还引用了作为外部变量得自身，而io_service是不知道外部变量得，也就不会拷贝。 如果lambda表达式是一个函数内局部变量，那离开函数作用域 就会消失，io_service执行handler时候就会发生错误。  asio程序优雅的退出  Server对象还监听信号量，从而优雅的退出。 signal_set.async_wait(SignalHandler handler) void handler(const system::error_code&amp;amp;ec , int signal_number)  #include &amp;lt;cstdlib&amp;gt;#include &amp;lt;boost/asio.hpp&amp;gt;#include &amp;lt;boost/bind.hpp&amp;gt;#include &amp;lt;iostream&amp;gt; using namespace boost; using namespace boost::asio; using namespace std; class Server { public: Server(io_service &amp;amp; s) : io_(s), signals_(s) { signals_.add(SIGINT); signals_.add(SIGTERM); #if defined(SIGQUIT)  signals_.add(SIGQUIT); #endif  signals_.async_wait(boost::bind(&amp;amp;Server::stop, this)); } void run() { io_.run(); } private: void stop() { cout &amp;lt;&amp;lt; &amp;#34;x&amp;#34; &amp;lt;&amp;lt; endl; io_.</description>
    </item>
    
    <item>
      <title>Boost - log</title>
      <link>https://jfy0o0.github.io/2020/boost-log/</link>
      <pubDate>Wed, 23 Dec 2020 13:47:22 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-log/</guid>
      <description>log 简易demo  -lboost_log -lboost_system -lboost_thread -lboost_filesystem -DBOOST_LOG_DYN_LINK 输出所有信息到控制台  #include &amp;lt;iostream&amp;gt;#include &amp;lt;boost/log/trivial.hpp&amp;gt; using namespace std; namespace logging = boost::log; namespace sinks = boost::log::sinks; namespace src = boost::log::sources; namespace expr = boost::log::expressions; namespace attrs = boost::log::attributes; namespace keywords = boost::log::keywords; static void simple_example() { BOOST_LOG_TRIVIAL(trace) &amp;lt;&amp;lt; &amp;#34;A trace severity message&amp;#34;; BOOST_LOG_TRIVIAL(debug) &amp;lt;&amp;lt; &amp;#34;A debug severity message&amp;#34;; BOOST_LOG_TRIVIAL(info) &amp;lt;&amp;lt; &amp;#34;An informational severity message&amp;#34;; BOOST_LOG_TRIVIAL(warning) &amp;lt;&amp;lt; &amp;#34;A warning severity message&amp;#34;; BOOST_LOG_TRIVIAL(error) &amp;lt;&amp;lt; &amp;#34;An error severity message&amp;#34;; BOOST_LOG_TRIVIAL(fatal) &amp;lt;&amp;lt; &amp;#34;A fatal severity message&amp;#34;; } 设置filter #include &amp;lt;boost/log/core.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - STL源码剖析 - traits技术</title>
      <link>https://jfy0o0.github.io/2020/cpp_stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-traits%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Mon, 21 Dec 2020 18:45:25 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-traits%E6%8A%80%E6%9C%AF/</guid>
      <description>概念  之前已经介绍过迭代器，知道了不同的数据结构都有自己专属的迭代器，不同的迭代器也有不同的特性，由于算法的接口是统一的，通过迭代器的不同属性，算法自动选择正确的执行流程，在完全任务的同时，也尽可能提高算法的执行效率。 那算法如何获知迭代器的属性呢？这一光荣的任务就是traits完成的。 在STL实现中，traits编程技术得到大量的运用，它利用了“内嵌类型”的编程技巧与C++的template参数推导功能，弥补了C++类型识别方面的不足。 通过traits，算法可以原汁原味的将迭代器的属性萃取出来，帮助算法正确高效的运行。  引子 1.以迭代器所指对象的类型声明局部变量 下面是一个以迭代器为模板形参的函数模板：
template&amp;lt;typename Iterator&amp;gt; void func(Iterator iter) { //函数体 } 假如现在算法中需要声明一个变量，而变量的类型是迭代器所指对象的类型，应该怎么处理呢？
template&amp;lt;typename Iterator&amp;gt; void func(Iterator iter) { *Iterator var;//这样定义变量可以吗？ } 上面的代码是不可以通过编译的，虽然C++支持sizeof()，但是并不支持typeof()，就算是用到RTTI性质中的typeid()，获取到的也仅仅是类型的名字，因此不能直接用来声明变量。此时可以利用函数模板的参数类型推导机制解决问题，例如：
template&amp;lt;typename Iterator, typename T&amp;gt; void func_impl(Iterator iter, T t) { T temp;//这里就解决了问题  //这里做原本func()的工作 } template&amp;lt;typename Iterator&amp;gt; void func(Iterator iter) { func_impl(iter, *iter);//func的工作全部都移到func_impl里面了 } int main(int argc, const char *argv[]) { int i; func(&amp;amp;i); }  函数func作为对外接口，实际的操作却由函数func_impl执行，通过函数func_impl的参数类型推导，获取到Iterator指向对象的类型T，从而解决了问题。  2.以迭代器所指对象的类型声明返回类型 ​ 现在通过函数模板的参数类型推导解决了函数体内声明变量的问题，但问题又来了，如果需要返回类型是迭代器所指对象的类型又可以怎样做呢？</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - STL源码剖析 - 迭代器</title>
      <link>https://jfy0o0.github.io/2020/cpp_stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Mon, 21 Dec 2020 17:13:11 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>迭代器作用  在设计模式中有一种模式叫迭代器模式，简单来说就是提供一种方法，在不需要暴露某个容器的内部表现形式情况下，使之能依次访问该容器中的各个元素， 这种设计思维在STL中得到了广泛的应用，是STL的关键所在，通过迭代器，容器和算法可以有机的粘合在一起，只要对算法给予不同的迭代器，就可以对不同容器进行相同的操作。 在这里提到了一个叫迭代器的东西，说得简单一点，就是一种指针，学习C和C++的同学肯定不会对指针感到陌生，这确实是个让我们又爱又恨的东西。 以下以算法find为例，展示了容器、算法和迭代器如何合作：  template&amp;lt;typename InputIterator, typename T&amp;gt; InputIterator find(InputIterator first, InputIterator last, const T &amp;amp;value) { while (first != last &amp;amp;&amp;amp; *frist != value) ++first; return first; } 迭代器是一种智能指针  它将指针进行了一层封装，既包含了原生指针的灵活和强大，也加上很多重要的特性，使其能发挥更大的作用以及能更好的使用。 迭代器对指针的一些基本操作如*、-&amp;gt;、++、==、!=、=进行了重载，使其具有了遍历复杂数据结构的能力，其遍历机制取决于所遍历的数据结构。 下面上一段代码，了解一下迭代器的“智能”：  对于不同的数据容器，以上Iterator类中的成员函数operator++的实现会各不相同，
例如，对于数组的可能实现如下：
//对于数组的实现 template&amp;lt;typename T&amp;gt; Iterator&amp;amp; operator++() { ++m_ptr; retrun *this; } 对于链表，它会有一个类似于next的成员函数用于获取下一个结点，其可能实现如下：
//对于链表的实现 template&amp;lt;typename T&amp;gt; Iterator&amp;amp; operator++() { m_ptr = m_ptr-&amp;gt;next();//next()用于获取链表的下一个节点  return *this; } 不同的容器都有专属的迭代器 下面尝试实现一个自己的迭代器，由于迭代器的作用对象是容器，因此需要首先实现一个容器，下面代码展示了一个
单向链表的实现： template&amp;lt;typename T&amp;gt; class ListItem { public: ListItem() { m_pNext = 0;} ListItem(T v, ListItem *p = 0) { m_value = v; m_pNext = p;} T Value() const { return m_value;} ListItem* Next() const { return m_pNext;} private: T m_value;	//存储的数据  ListItem* m_pNext;	//指向下一个ListItem的指针 }; template&amp;lt;typename T&amp;gt; class List { public: //从链表尾部插入元素  void Push(T value) { m_pTail = new ListItem&amp;lt;T&amp;gt;(value); m_pTail = m_pTail-&amp;gt;Next(); } //打印链表元素  void Print(std::ostream &amp;amp;os = std::cout) const {	for (ListItem&amp;lt;T&amp;gt; *ptr = m_pHead; ptr; ptr = ptr-&amp;gt;Next()) os&amp;lt;&amp;lt;ptr-&amp;gt;Value&amp;lt;&amp;lt;&amp;#34; &amp;#34;; os&amp;lt;&amp;lt;endl; } //返回链表头部指针  ListItem&amp;lt;T&amp;gt;* Begin() const { return m_pHead;} //返回链表尾部指针  ListItem&amp;lt;T&amp;gt;* End() const { return 0;} //其它成员函数  private： ListItem&amp;lt;T&amp;gt; *m_pHead; //指向链表头部的指针  ListItem&amp;lt;T&amp;gt; *m_pTail; //指向链表尾部的指针  long m_nSize; //链表长度 }; 迭代器实现： template&amp;lt;typename T&amp;gt; class ListIter { public: ListIter(T *p = 0) : m_ptr(p){} //解引用，即dereference  T&amp;amp; operator*() const { return *m_ptr;} //成员访问，即member access  T* operator-&amp;gt;() const { return m_ptr;} //前置++操作  ListIter&amp;amp; operator++() { m_ptr = m_ptr-&amp;gt;Next(); //暴露了ListItem的东西  return *this; } //后置++操作  ListIter operator++(int) { ListIter temp = *this; ++*this; return temp; } //判断两个ListIter是否指向相同的地址  bool opeartor==(const ListIter &amp;amp;arg) const { return arg.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - STL源码剖析 - 空间配置器</title>
      <link>https://jfy0o0.github.io/2020/cpp_stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/</link>
      <pubDate>Mon, 21 Dec 2020 16:14:02 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/</guid>
      <description>空间配置器 前言 在STL中，容器的定义中都带一个模板参数，如vector
template &amp;lt;class T, class Alloc = alloc&amp;gt; class vector {...} 其中第二个参数就是该容器使用的空间配置器，其中缺省使用STL已经实现的空间配置器(alloc)，
该配置器使用malloc/free等为vector分配内存。
缺省的空间配置器  alloc定义了两级的空间配置器， 第一级是对malloc/free简单的封装。 而为了解决内存碎片的问题，跟进行内存管理，alloc实现的第二级的空间配置器。 第二级空间配置器在分配大块内存(大于128bytes)时，会直接调用第一级空间配置器， 而分配小于128bytes的内存时，则使用内存池跟free_list进行内存分配/管理。  第一级空间配置器  它可以设定一个处理内存不足的时候的处理函数(跟set_new_handler类似)。  class base_alloc { public: // 只是对malloc/free的简单封装  static void* allocate(size_t n) { void* res = malloc(n); if (0 == res) res = oom_malloc(n); return res; } static void* reallocate(void* p, size_t new_sz) { void* res = realloc(p, new_sz); if (0 == res) res = oom_realloc(p, new_sz); return res; } static void deallocate(void* p) { free(p); } // 用来设置内存不足时的处理函数 该函数参数跟返回值都是一个函数指针  // 一般会抛出异常/尝试回收内存  static void(*set_handler(void(*f)()))() { void(*old)() = _oom_handler; _oom_handler = f; return old; } private: // 用来处理内存不足的情况  static void* oom_malloc(size_t n) { void(*my_handler)(); void* res; for (;;) { my_handler = _oom_handler; if (0 == my_handler) { return NULL; } (*my_handler)(); if (res = malloc(n)) return res; } } // 用来处理内存不足的情况  static void* oom_realloc(void* p, size_t n) { void(*my_handler)(); void* res; for (;;) { my_handler = _oom_handler; if (0 == my_handler) { return NULL; } (*my_handler)(); if (res = reallocate(p, n)) return res; } } // 由用户设置，在内存不足的时候进行处理，由上面两个函数调用  static void(*_oom_handler)(); }; // 处理函数默认为0 void(*base_alloc::_oom_handler)() = 0; 第二级空间配置器  该配置器维护一个free_list，这是一个指针数组。 在分配内存的时候，补足8bytes的倍数，free_list数组中每个指针分别管理分配大小为8、16、24、32&amp;hellip;bytes的内存。 下图表示从二级空间配置器中分配内存时是如何维护free_list的(建议参考下面源码阅读)。 开始所有指针都为0，没有可分配的区块时(就是free_list[i]==0)会从内存池中分配内存(默认分配20个区块)插入到free_list[i]中。 然后改变free_list[i]的指向，指向下一个区块(free_list_link指向下一个区块，如果没有则为0)。  enum { _ALIGN = 8 }; // 对齐 enum { _MAX_BYTES = 128 }; // 区块大小上限 enum { _NFREELISTS = _MAX_BYTES / _ALIGN }; // free-list个数  class default_alloc { private: // 将bytes上调到8的倍数  static size_t ROUND_UP(size_t bytes) { return (bytes + _ALIGN - 1) &amp;amp; ~(_ALIGN - 1); } private: union obj { union obj* free_list_link; char client_data[1]; }; private: // 16个free-lists 各自管理分别为8,16,24.</description>
    </item>
    
    <item>
      <title>Boost - pool</title>
      <link>https://jfy0o0.github.io/2020/boost-pool/</link>
      <pubDate>Tue, 15 Dec 2020 20:19:51 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-pool/</guid>
      <description>内存池  boost的内存池实现了一个快速、紧凑的内存分配和管理器，使用它可以完全不用考虑delete释放问题。 常用的boost内存池有pool、object_pool、singleton_pool。  pool 说明  pool是一个简单的内存池类，它的模板类型通常使用默认的参数，构造函数的参数用来指定每次分配内存的大小，这个值可以通过成员get_requested_size()获得。 pool会根据需要自动向系统申请或归还使用的内存，在其析构的时候自动释放它持有的所有内存。常用的成员函数： malloc()：分配一块内存，返回类型为void*，内存分配失败返回NULL。 ordered_malloc()：分配一块内存并合并空闲块链表，不推荐使用该函数，因为其效率低。 is_from()：测试内存块是否属于本内存池。 free()：释放malloc()非配的内存，不建议调用该函数来手动释放内存，因为pool是自动管理内存分配的。 release_memory()：释放所有未被分配的内存。 purge_memory()：强制释放pool持有的所有内存。  使用 #include &amp;lt;iostream&amp;gt;using namespace std; #include &amp;#34;boost\pool\pool.hpp&amp;#34;using namespace boost; int main() { pool&amp;lt;&amp;gt; p1(sizeof(int)); int* p = (int*)p1.malloc(); //int *p = static_cast&amp;lt;int *&amp;gt;(p1.malloc()); 	BOOSTASSERT(p) *p = 10; cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl; return 0; } object_pool 说明  object_pool是类实例的内存池，其模板类型的参数用来指定使用的类， 其成员construct()用来分配一个类的对象，destroy()用来释放一个已分配的对象，is_from()用来测试对象是否属于本内存池分配的。  需要注意的三点：
 默认情况下成员函数construct最多支持3个参数，可以对construct进行扩展以支持3个参数以上的构造函数，具体扩展方法可参见罗剑锋的《Boost程序库完全开发指南》一书。 object_pool的成员函数destroy()效率很低，如果需要频繁释放已分配的对象的话谨慎考虑object_pool。 object_pool还提供了malloc()和free()成员，其可以像pool那样来分配和释放内存块。  使用 #include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std; #include &amp;#34;boost\pool\object_pool.</description>
    </item>
    
    <item>
      <title>Boost - filesystem</title>
      <link>https://jfy0o0.github.io/2020/boost-filesystem/</link>
      <pubDate>Tue, 15 Dec 2020 20:05:43 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-filesystem/</guid>
      <description>filesystem 说明  filesystem库是文件系统操作库，可以使用其中的basic_path类用来操作目录、文件，使用需要包含编译好的system库和filesystem库，我们一般不直接使用basic_path，而是使用typedef : path和wpath。 使用它需要包含&amp;quot;boost/filesystem.hpp&amp;quot;。  使用 boost::filesystem::path p1(&amp;#34;D:\\dir&amp;#34;); //windows下既可使用斜杠也可使用反斜杠（资源管理器地址栏中使用的就是反斜杠），又因为在c++中反斜杠是转义字符的标志，所以使用反斜杠的话还得再加一个反斜杠  boost::filesystem::path p2(&amp;#34;D:/dir/data.dat&amp;#34;); //windows下推荐使用正斜杠  boost::filesystem::path p3(&amp;#34;/user/dir&amp;#34;); //linux下使用正斜杠  boost::filesystem::path p4 = &amp;#34;./dir&amp;#34;; //path的构造函数没有声明为explicit，字符串可以隐式转换为path对象  p1 /= &amp;#34;child&amp;#34;; //path重载了 /=，其功能与成员append()相同。  cout &amp;lt;&amp;lt; p1 &amp;lt;&amp;lt; endl; //支持流输出操作，输出为&amp;#34;D:\dir\child&amp;#34;  if (p1 == p2); //支持比较操作  auto iter = p1.begin(); //支持迭代器来迭代其中的字符串  std::string strDir = p1.string(); //获取字符串（构造函数中传入的字符串为相对路径的话这里也是相对路径）  bool bRes = boost::filesystem::portable_posix_name(strDir); //判断是否符合posix文件命名规范  boost::filesystem::windows_name(strDir); //判断是否符合windows文件命名规范  boost::filesystem::portable_name(strDir); //相当于portable_posix_name() &amp;amp;&amp;amp; windows_name  boost::filesystem::native(strDir); //在windows下相当于windows_name，其它操作系统下只是简单的判断文件名不是空格且不含斜杠  boost::filesystem::path parentPath = p3.</description>
    </item>
    
    <item>
      <title>Boost - 同步</title>
      <link>https://jfy0o0.github.io/2020/boost-%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Tue, 15 Dec 2020 19:51:16 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E5%90%8C%E6%AD%A5/</guid>
      <description>互斥锁（互斥量） 说明  mutex是独占式的互斥锁。timed_mutex增加了超时功能。 成员函数：lock()用于锁定，try_lock()为非阻塞版本的锁定，unlock()用于解锁。timed_lock()只属于timed_mutex，它可以等待一定的时间，等待的时间可以是一个时间段，也可以是指定的时间。 使用方法：使用mutex必须配合try-catch块以保证解锁互斥量，eg：  使用 #include &amp;#34;boost\thread.hpp&amp;#34; int main() { boost::mutex mu; try { mu.lock(); cout &amp;lt;&amp;lt; &amp;#34;Need to be protected&amp;#34; &amp;lt;&amp;lt; endl; //io流是个共享资源，多线程内使用的话需要同步  mu.unlock(); } catch (...) { mu.unlock(); } return 0; } mutex还提供了一系列的RAII型的互斥锁，用于取消麻烦的try-catch块，它会在构造的时候锁定互斥量，析构时自动解锁，eg：
#include &amp;#34;boost\thread.hpp&amp;#34; int main() { boost::mutex mu; boost::mutex::scoped_lock lock(mu); cout &amp;lt;&amp;lt; &amp;#34;Need to be protected&amp;#34; &amp;lt;&amp;lt; endl; //io流是个共享资源，多线程内使用的话需要同步  return 0; } 递归锁 说明 recursive_mutex是递归锁，可以多次锁定，相应的也要多次解锁。recursive_timed_mutex增加了超时功能。递归锁的使用接口跟互斥锁基本相同。
读写锁 说明  shared_mutex是读写锁，提供了multiple-reader / single-writer功能。 读取锁定时我们使用shared_lock&amp;lt;shared_mutex&amp;gt;对象，写入锁定时我们使用unique_lock&amp;lt;shared_mutex&amp;gt;对象：  使用 boost::shared_mutex rw_mu; //read thread  { boost::shared_lock&amp;lt;boost::shared_mutex&amp;gt; sl(rw_mu); //读锁定  //.</description>
    </item>
    
    <item>
      <title>Boost - thread</title>
      <link>https://jfy0o0.github.io/2020/boost-thread/</link>
      <pubDate>Tue, 15 Dec 2020 19:44:34 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-thread/</guid>
      <description>thread 说明  静态函数this_thread::get_id()可以获得当前线程的线程ID。 静态函数thread::this_thread::sleep()可以让当前线程睡眠一段时间或到指定时间， 静态函数thread::hardware_concurrency()可以获得当前CPU的内核数量。 静态函数this_thread::yield()指示当前线程放弃时间片，允许其他线程运行。  简易使用 #include &amp;#34;boost\thread.hpp&amp;#34; void PrintThreadFunc(const int&amp;amp; n, const string&amp;amp; str) { cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; n &amp;lt;&amp;lt; endl; } int main() { int n1 = 1; string str1 = &amp;#34;hello&amp;#34;; boost::thread t1(PrintThreadFunc, ref(n1), ref(str1)); int n2 = 2; string str2 = &amp;#34;boost&amp;#34;; function&amp;lt;void()&amp;gt; fun = bind(PrintThreadFunc, ref(n2), ref(str2)); boost::thread t2(fun); t1.timed_join(boost::posix_time::seconds(1)); //最多等待1秒  t2.join(); //一直等待  return 0; } 中断线程 线程内部 void ThreadFun() try { //函数体 } catch (boost::thread_interrupted&amp;amp;) { //异常处理 } 线程外部 t.</description>
    </item>
    
    <item>
      <title>Boost - signals2</title>
      <link>https://jfy0o0.github.io/2020/boost-signals2/</link>
      <pubDate>Tue, 15 Dec 2020 19:40:22 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-signals2/</guid>
      <description>signals2 概念  插槽可以是函数指针、函数对象、bind表达式、function对象。调用signals的成员函数connect()来将插槽连接到信号上，相当于为信号注册一个处理的handler。对signal对象调用()即为产生一个信号（signal提供了operator()），从而导致连接的所有插槽被调用。产生信号即调用signal的operator()的返回值是一个optional类型的对象，可以使用解引用操作符*来获得真正的返回值，而且默认情况下，这个返回值是最后被调用的插槽的返回值。signal会把参数传递给所有连接的插槽。 就像function一样，signal也是一个模板类，第一个模板参数是插槽函数类型签名，除了第一个模板参数外其他的模板参数都有缺省值，所以可以只传入第一个参数。 signal::connect()的第一个参数为一个插槽，第二个参数为插入的位置，插入位置决定了插槽的调用顺序，默认值为at_back往后插入，at_front为往前插入，返回值是一个connection对象，可以这个对象来管理连接，如断开连接(disconnect)、测试连接(connected)等。 其它成员函数： num_slots()用来获得连接的插槽的个数，empty()用来判断连接的插槽数量是否为0。 combiner()用来获取合并器，set_combiner()用来设置合并器，不过一般是在signal构造函数中直接设置合并器。 disconnect()用来断开连接，disconnect_all_slots()用来断开所有连接的插槽，signal对象析构时会自动调用disconnect_all_slots()。  #include &amp;#34;boost/signals2.hpp&amp;#34; int slots1(int n) { int iRet = n * n; cout &amp;lt;&amp;lt; &amp;#34;slot1 called, return value: &amp;#34; &amp;lt;&amp;lt; iRet &amp;lt;&amp;lt; endl; return iRet; } int slots2(int n, int x) { int iRet = n * n * x; cout &amp;lt;&amp;lt; &amp;#34;slot2 called, return value: &amp;#34; &amp;lt;&amp;lt; iRet &amp;lt;&amp;lt; endl; return iRet; } int slots3(int n) { int iRet = n * n; cout &amp;lt;&amp;lt; &amp;#34;slot3 called, return value: &amp;#34; &amp;lt;&amp;lt; iRet &amp;lt;&amp;lt; endl; return iRet; } int slots4(int n) { int iRet = n * n; cout &amp;lt;&amp;lt; &amp;#34;slot4 called, return value: &amp;#34; &amp;lt;&amp;lt; iRet &amp;lt;&amp;lt; endl; return iRet; } int main() { boost::signals2::signal&amp;lt;int(int)&amp;gt; sig; //sig.</description>
    </item>
    
    <item>
      <title>Boost - function</title>
      <link>https://jfy0o0.github.io/2020/boost-function/</link>
      <pubDate>Tue, 15 Dec 2020 19:34:56 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-function/</guid>
      <description>function 概念  function是一个模板类，它就像一个包装了函数指针或函数对象的容器（只有一个元素）。 可以把它想象成一个泛化的函数指针，而且他非常适合代替函数指针，存储用于回调的函数。 如下定义了一个能够容纳void(int)类型的function对象： 使用function需要包含头文件&amp;quot;boost/function.hpp&amp;quot;，C++11已经支持function。  function&amp;lt;void(int)&amp;gt; funo; 一些成员函数：
 target()：返回对象内部的可调用物Functor的指针，对象为空则返回NULL contains()：检测是否持有一个Functor。 clear()：将对象清空，与&amp;quot;= 0&amp;quot;效果相同。 empty()：测试对象是否为空，也可以在一个bool上下文中直接测试它是否为空。 operator==、operator!=：与一个函数或函数对象进行比较。 operator()：调用内部的可调用物，它也会将参数传给可调用物。  使用 int FuncName(int a, int b) { return a + b; } int main() { function&amp;lt;int(int, int)&amp;gt; funo; funo = FuncName; if (funo) { cout &amp;lt;&amp;lt; funo(3, 4) &amp;lt;&amp;lt; endl; } return 0; } 回调 void call_back_func(int i) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; } class CTestClass { public: CTestClass(int i) :m_iNum(i) {} public: template&amp;lt;typename CallBack&amp;gt; void SetCallBack(CallBack f) { m_fFun = f; } void run() { if(m_fFun) m_fFun(m_iNum); } private: function&amp;lt;void(int)&amp;gt; m_fFun; int m_iNum; }; int main() { CTestClass dc(10); dc.</description>
    </item>
    
    <item>
      <title>Boost - bind</title>
      <link>https://jfy0o0.github.io/2020/boost-bind/</link>
      <pubDate>Tue, 15 Dec 2020 19:21:49 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-bind/</guid>
      <description>bind 概念  boost中的bind是bind1st/bind2nd的增强版，它也会返回一个函数对象，可以通过function来保存和调用。 bind()的第一个参数必须是一个可调用对象，比如函数、函数指针、函数对象，之后它最多接受九个参数。 占位符用来表示使用哪一个参数。boost中的bind位于头文件&amp;quot;boost/bind.hpp&amp;quot;中， c++11中已经增加了bind，头文件为，使用占位符的话需要其所在的命名空间：using namespace std::placeholders;  使用 绑定普通函数 #include &amp;lt;iostream&amp;gt;using namespace std; #include &amp;#34;boost/bind.hpp&amp;#34;#include &amp;#34;boost\function.hpp&amp;#34; void func1p(int num) { cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; endl; } void func3p(int a, int b, int c) { cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl; } int main() { int n = -1; //绑定变量n到func1p的参数：不用再传参；  boost::function&amp;lt;void()&amp;gt; fun = boost::bind(func1p, n); fun(); //输出-1  int x = 0, y = 5, z = 10; //绑定变量x到func3p的第一个参数：第一个参数直接使用x，不用传参；第二个参数使用实参列表的第一个参数；第三个参数使用实参列表的第二个参数  boost::function&amp;lt;void(int, int)&amp;gt; func = boost::bind(func3p, x, _1, _2); func(y, z); //输出0, 5, 10  //绑定变量y到func3p的第二个参数：第二个参数直接使用y，不用传参；第一个参数使用实参列表的第一个参数；第三个参数使用实参列表的第二个参数  func = boost::bind(func3p, _1, y, _2); func(x, z); //输出0, 5, 10  //绑定变量z到func3p的第三个参数：第三个参数直接使用z，不用传参；第一个参数使用实参列表的第一个参数；第二个参数使用实参列表的第二个参数  func = boost::bind(func3p, _1, _2, z); func(x, y); //输出0, 5, 10  return 0; } #include &amp;#34;boost/bind.</description>
    </item>
    
    <item>
      <title>Boost - ref</title>
      <link>https://jfy0o0.github.io/2020/boost-ref/</link>
      <pubDate>Tue, 15 Dec 2020 19:14:21 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-ref/</guid>
      <description>reference_wrapper 简介  reference_wrapper包含在ref库中，它是引用包装器类型，即其内部包装了引用。 成员函数get()、get_pointer()分别可以获得被包装的引用和其指针。使用需要包含头文件&amp;quot;boost/ref.hpp&amp;quot;。  eg #include &amp;#34;boost/ref.hpp&amp;#34;#include &amp;lt;cassert&amp;gt;int main() { int x = 5; boost::reference_wrapper&amp;lt;int&amp;gt; rw(x); rw.get() = 10; //获得引用  *rw.get_pointer() = 15; //获得指针  int n = rw; //隐式转换为int  assert(x == rw); //隐式转换为int  rw = 20; //错误！引用包装器不能作为左值  (int&amp;amp;)rw = 20; //显示转换为int&amp;amp;，这样可以作为左值  assert(x == 20); boost::reference_wrapper&amp;lt;int&amp;gt; rw2(rw); //拷贝构造  rw.get() = 25; assert(rw2.get() == 25);//rw2也是x的一个引用对象 	//在确实需要持有或者修改字符串的时候可以调用成员函数 to_string() 获得一个拷贝来保证安全  return 0; } ref 使用函数ref()和cref()可以很方便的构造reference_wrapper和const reference_wrapper对象，它们可以根据参数的类型推导出引用的类型。</description>
    </item>
    
    <item>
      <title>Boost - 实用工具</title>
      <link>https://jfy0o0.github.io/2020/boost-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Tue, 15 Dec 2020 18:58:30 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/</guid>
      <description>noncopyable 概念  让一个类从noncopyable继承可以实现禁止对象的复制，使用需要包含头文件&amp;quot;boost/noncopyable.hpp&amp;quot;或&amp;quot;boost/utility.hpp&amp;quot;。 noncopyable实际上是将类的拷贝构造函数和赋值操作符声明为了private来实现禁止对象的赋值。  optional 概念  optional类可以表示一个无意义的值， 比如以下代码，我们使用get_optional()查找xml上的一个节点，如果该节点不存在的话就会返回一个无效的optional对象，此时对象就是空的。  ptree pt; read_xml(&amp;#34;conf.xml&amp;#34;, pt); boost::optional&amp;lt;int&amp;gt; op = pt.get_optional&amp;lt;int&amp;gt;(&amp;#34;conf.gui&amp;#34;); if (op)//节点不存在则op为空  { int i = op.get(); } auto x = make_optional(5); auto y = make_optional&amp;lt;double&amp;gt;((*x &amp;gt; 10),1.0); 成员函数：
  无参数或参数为boost::none的构造函数用来构造一个无效的对象。
  如果构造函数中的参数是一个值的引用的话，那么optional中元素其实也是这个值的引用。
  get()可以获得元素的引用，get_value_or()也可以获得元素的引用，如果对象是无效的话get_value_or()还可以设置一个默认的返回值，get_ptr()可以获得元素的指针。
  提供了隐式bool类型转换以判断对象的有效性。
  重载了operator*和operator-&amp;gt;，*运算可以获得元素的值，-&amp;gt;操作可以获得元素的指针。
  支持==、!=、&amp;gt;等比较运算。
  使用make_optional()来创建optional对象的话可以不用指定参数的类型，它可以根据参数来自动推导optional的类型。
  BOOST_AUTO(x, boost::make_optional(5)); assert(*x == 5); in_place() 概念  optional要求参数具有拷贝语义， 因为它会使用参数值的临时拷贝， 如果参数是一个复杂的对象的话这种拷贝方式效率就会很慢， 我们可以使用boost库in_place_factory中的in_place()函数来就地创建对象，避免对参数值的临时拷贝，  使用 #include &amp;#34;boost/optional.</description>
    </item>
    
    <item>
      <title>Boost - 智能指针</title>
      <link>https://jfy0o0.github.io/2020/boost-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 15 Dec 2020 18:44:53 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
      <description>智能指针 auto_ptr 概念  auto_ptr是C++标准中的智能指针，在指针退出作用域的时候自动释放指针指向的内存，即使是异常退出的时候。 auto_ptr实际上是一个对象，重载了operator*和operator-&amp;gt;，且提供了一些成员函数，比如使用成员get()可以获得对应类型的原始指针。 auto_pt的特点是可以对其进行复制和赋值，但同一时刻只能有一个auto_ptr管理指针。  使用 std::auto_ptr&amp;lt;int&amp;gt; ap1(new int(5)); cout &amp;lt;&amp;lt; *ap1 &amp;lt;&amp;lt; endl; int* p = ap1.get(); cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl; std::auto_ptr&amp;lt;int&amp;gt; ap2(ap1);//ap1失去管理权，不再拥有指针，ap2得到管理权  assert(ap1.get() == 0);//get()获得的指针为空 scoped_ptr 概念  boost的scoped_ptr用法类似于auto_ptr，都不能用作容器的元素，不支持++、&amp;ndash;等指针算数操作。 scoped_ptr的特点是拷贝构造函数和赋值操作符都是私有的，所以scoped_ptr不能进行复制和赋值操作，保证了对对象的唯一管理权。  使用 boost::scoped_ptr&amp;lt;int&amp;gt; sp1(new int(10)); boost::scoped_ptr&amp;lt;int&amp;gt; sp2(sp1);//编译无法通过：不能转让sp1的管理权到sp2  boost::scoped_ptr&amp;lt;int&amp;gt; sp3(new int(30)); sp3 = sp1;//编译无法通过：不能转让sp1的管理权到sp3 scoped_array 使用 #include &amp;lt;boost/scoped_array.hpp&amp;gt;  int main() { boost::scoped_array&amp;lt;int&amp;gt; i(new int[2]); *i.get() = 1; i[1] = 2; i.reset(new int[3]); boost::scoped_array&amp;lt;Book&amp;gt; myBook(new Book[2]); myBook.</description>
    </item>
    
    <item>
      <title>Boost - 字符串转换</title>
      <link>https://jfy0o0.github.io/2020/boost-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Tue, 15 Dec 2020 15:17:09 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/</guid>
      <description>format  在字符串处理中少不了格式化字符串，C++中传统的格式化函数是C语言的sprintf，但它一个很大的问题就是不安全。 因此，在stl中引入了stringstream来实现安全格式化，但是stringstream却远不如sprintf来得直观。  eg //C风格的格式化字符串 	boost::format fmt = boost::format(&amp;#34;&amp;lt;%s&amp;gt; %s in the lower case&amp;#34;) % text % (is_all_lower? &amp;#34;is&amp;#34;: &amp;#34;is not&amp;#34;); string output = fmt.str(); //.net风格的格式化字符串 	boost::format fmt = boost::format(&amp;#34;&amp;lt;%1%&amp;gt; %2% in the lower case&amp;#34;) % text % (is_all_lower? &amp;#34;is&amp;#34;: &amp;#34;is not&amp;#34;); cout &amp;lt;&amp;lt; fmt &amp;lt;&amp;lt; endl; 格式化控制 //传统c语言风格  cout &amp;lt;&amp;lt; boost::format(&amp;#34;\n\n%s&amp;#34; &amp;#34;%1t 十进制 = [%d]\n&amp;#34; &amp;#34;%1t 格式化的十进制 = [%5d]\n&amp;#34; &amp;#34;%1t 格式化十进制，前补&amp;#39;0&amp;#39; = [%05d]\n&amp;#34; &amp;#34;%1t 十六进制 = [%x]\n&amp;#34; &amp;#34;%1t 八进制 = [%o]\n&amp;#34; &amp;#34;%1t 浮点 = [%f]\n&amp;#34; &amp;#34;%1t 格式化的浮点 = [%3.</description>
    </item>
    
    <item>
      <title>Boost - property_tree</title>
      <link>https://jfy0o0.github.io/2020/boost-property_tree/</link>
      <pubDate>Tue, 15 Dec 2020 15:07:28 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-property_tree/</guid>
      <description>property_tree   property_tree是一个保存了多个属性值的树形数据结构，可以用来解析xml、json、ini、info文件。
  要使用property_tree和xml解析组件的话需要包含&amp;quot;boost/property_tree/ptree.hpp&amp;quot;和&amp;quot;boost/property_tree/xml_parser.hpp&amp;quot;。
  我们一般使用property_tree中预定义好的typedef: ptree来处理数据。
  xml 格式 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;conf&amp;gt; &amp;lt;gui&amp;gt;0&amp;lt;/gui&amp;gt; &amp;lt;theme&amp;gt;matrix&amp;lt;/theme&amp;gt; &amp;lt;urls&amp;gt; &amp;lt;url&amp;gt;http:://www.url1.com&amp;lt;/url&amp;gt; &amp;lt;url&amp;gt;http:://www.url2.com&amp;lt;/url&amp;gt; &amp;lt;url&amp;gt;http:://www.url3.com&amp;lt;/url&amp;gt; &amp;lt;url&amp;gt;&amp;lt;/url&amp;gt; &amp;lt;/urls&amp;gt; &amp;lt;clock_style&amp;gt;24.35&amp;lt;/clock_style&amp;gt; &amp;lt;/conf&amp;gt; 解析 #include &amp;lt;cstdio&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;using std::string; #include &amp;#34;boost/property_tree/ptree.hpp&amp;#34;#include &amp;#34;boost/property_tree/xml_parser.hpp&amp;#34;#include &amp;#34;boost/typeof/typeof.hpp&amp;#34;#include &amp;#34;boost/optional.hpp&amp;#34;using namespace boost::property_tree; int main() { ptree pt; read_xml(&amp;#34;conf.xml&amp;#34;, pt); boost::optional&amp;lt;int&amp;gt; op = pt.get_optional&amp;lt;int&amp;gt;(&amp;#34;conf.gui&amp;#34;); //使用get_optional()获得节点，不存在则op为空  if (op) { int i = op.get(); } string str1 = pt.get&amp;lt;string&amp;gt;(&amp;#34;conf.theme&amp;#34;, &amp;#34;&amp;#34;); //使用get()获得节点，不存在则返回&amp;#34;&amp;#34;  boost::optional&amp;lt;ptree&amp;amp;&amp;gt; child_null_test = pt.</description>
    </item>
    
    <item>
      <title>Linux Soft - gdb</title>
      <link>https://jfy0o0.github.io/2020/linux-%E8%BD%AF%E4%BB%B6-gdb/</link>
      <pubDate>Mon, 14 Dec 2020 19:08:28 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/linux-%E8%BD%AF%E4%BB%B6-gdb/</guid>
      <description>gdb GDB是一个由GNU开源组织发布的、UNIX/LINUX操作系统下的、基于命令行的、功能强大的程序调试工具。 对于一名Linux下工作的c/c++程序员，gdb是必不可少的工具；
启动 gdb test gdb -q test //表示不打印gdb版本信息，界面较为干净； 运行命令    命令 缩写 说明     run r 运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步的命令。   continue c 继续执行，到下一个断点处（或运行结束）   next n 单步跟踪程序，当遇到函数调用时，也不进入此函数体；此命令同 step 的主要区别是，step 遇到用户自定义的函数，将步进到函数中去运行，而 next 则直接调用函数，不会进入到函数体内。   step s 单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的   until  当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。   until + line num  运行至某行，不仅仅用来跳出循环   finish  运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息。   call  调用程序中可见的函数，并传递“参数”，如：call gdb_test(55)   quit q 简记为 q ，退出gdb    设置断点    命令 缩写 说明     break n b n 在第n行处设置断点   b fn1 if a&amp;gt;b  条件断点设置   break func b 在函数func()的入口处设置断点，如：break cb_button   delete 断点号n  删除第n个断点   disable 断点号n  暂停第n个断点   enable 断点号n  开启第n个断点   clear 行号n  清除第n行的断点   info b  显示当前程序的断点设置情况   delete breakpoints  清除所有断点    查看源码    命令 缩写 说明     list l 列出程序的源代码，默认每次显示10行。   list line num  将显示当前文件以“行号”为中心的前后10行代码，如：list 12   list func  将显示“函数名”所在函数的源代码，如：list main   list  不带参数，将接着上一次 list 命令的，输出下边的内容。    打印表达式    命令 缩写 说明     print 表达式 p 其中“表达式”可以是任何当前正在被测试程序的有效表达式，比如当前正在调试C语言的程序，那么“表达式”可以是任何C语言的有效表达式，包括数字，变量甚至是函数调用。   print a  将显示整数 a 的值   print ++a  将把 a 中的值加1,并显示出来   p /x a  将显示整数 a 的十六进制值   p *array@3  将显示数组 array 的长度为3的值   print name  将显示字符串 name 的值   print gdb_test(22)  将以整数22作为参数调用 gdb_test() 函数   print gdb_test(a)  将以变量 a 作为参数调用 gdb_test() 函数   display 表达式  在单步运行时将非常有用，使用display命令设置一个表达式后，它将在每次单步进行指令后，紧接着输出被设置的表达式及值。如： display a   watch 表达式  设置一个监视点，一旦被监视的“表达式”的值改变，gdb将强行终止正在被调试的程序。如： watch a   whatis  查询变量或函数   info function  查询函数   info locals  显示当前堆栈页的所有变量    查看运行信息    命令 缩写 说明     where/bt  当前运行的堆栈列表；   backtrace bt 显示当前调用堆栈   up/down  改变堆栈显示的深度   set args  参数:指定运行时的参数   show args  查看设置好的参数   info program  来查看程序的是否在运行，进程号，被暂停的原因。    分割窗口    命令 缩写 说明     layout  用于分割窗口，可以一边查看代码，一边测试：   layout src  显示源代码窗口   layout asm  显示反汇编窗口   layout regs  显示源代码/反汇编和CPU寄存器窗口   layout split  显示源代码和反汇编窗口   Ctrl + L  刷新窗口    多线程    命令 缩写 说明     bt  看函数调用栈的所有信息，当程序执行异常时，可通过此命令查看程序的调用过程；   info threads  显示当前进程中的线程；   thread id  切换到具体的线程id，一般切换到具体的线程后再执行bt等操作。    attach  通过命令：$ ps -aux | grep main ,获取执行main的进程(pid)，例如执行main的进程为18786： 执行：$ gdb attach 18786，  gdb强行生成core文件  generate-core-file  core文件生成 ulimit</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - STL Algorithm</title>
      <link>https://jfy0o0.github.io/2020/cpp_stl_algorithm/</link>
      <pubDate>Sat, 12 Dec 2020 08:47:21 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_stl_algorithm/</guid>
      <description>非修改性序列操作（12个） 循环          对序列中的每个元素执行某操作 for_each()    查找          在序列中找出某个值的第一次出现的位置 find()   在序列中找出符合某谓词的第一个元素 find_if()   在序列中找出一子序列的最后一次出现的位置 find_end()   在序列中找出第一次出现指定值集中之值的位置 find_first_of()   在序列中找出相邻的一对值 adjacent_find()    计数          在序列中统计某个值出现的次数 count()   在序列中统计与某谓词匹配的次数 count_if()    比较          找出两个序列相异的第一个元素 mismatch()   两个序列中的对应元素都相同时为真 equal()    搜索          在序列中找出一子序列的第一次出现的位置 search()   在序列中找出一值的连续n次出现的位置 search_n()    修改性序列操作（27个） 复制          从序列的第一个元素起进行复制 copy()   从序列的最后一个元素起进行复制 copy_backward()    交换          交换两个元素 swap()   交换指定范围的元素 swap_ranges()   交换由迭代器所指的两个元素 iter_swap()    变换          将某操作应用于指定范围的每个元素 transform()    替换          用一个给定值替换一些值 replace()   替换满足谓词的一些元素 replace_if()   复制序列时用一给定值替换元素 replace_copy()   复制序列时替换满足谓词的元素 replace_copy_if()    填充          用一给定值取代所有元素 fill()   用一给定值取代前n个元素 fill_n()    生成          用一操作的结果取代所有元素 generate()   用一操作的结果取代前n个元素 generate_n()    删除          删除具有给定值的元素 remove()   删除满足谓词的元素 remove_if()   复制序列时删除具有给定值的元素 remove_copy()   复制序列时删除满足谓词的元素 remove_copy_if()    唯一          删除相邻的重复元素 unique()   复制序列时删除相邻的重复元素 unique_copy()    反转          反转元素的次序 reverse()   复制序列时反转元素的次序 reverse_copy()    环移          循环移动元素 rotate()   复制序列时循环移动元素 rotate_copy()    随机          采用均匀分布来随机移动元素 random_shuffle()    划分          将满足某谓词的元素都放到前面 partition()   将满足某谓词的元素都放到前面并维持原顺序 stable_partition()    序列排序及相关操作（27个） 排序          以很好的平均效率排序 sort()   排序，并维持相同元素的原有顺序 stable_sort()   将序列的前一部分排好序 partial_sort()   复制的同时将序列的前一部分排好序 partial_sort_copy()    第n个元素          将第n各元素放到它的正确位置 nth_element()    二分检索          找到大于等于某值的第一次出现 lower_bound()   找到大于某值的第一次出现 upper_bound()   找到（在不破坏顺序的前提下）可插入给定值的最大范围 equal_range()   在有序序列中确定给定元素是否存在 binary_search()    归并          归并两个有序序列 merge()   归并两个接续的有序序列 inplace_merge()    有序结构上的集合操作          一序列为另一序列的子序列时为真 includes()   构造两个集合的有序并集 set_union()   构造两个集合的有序交集 set_intersection()   构造两个集合的有序差集 set_difference()   构造两个集合的有序对称差集（并-交） set_symmetric_difference()    堆操作          向堆中加入元素 push_heap()   从堆中弹出元素 pop_heap()   从序列构造堆 make_heap()   给堆排序 sort_heap()    最大和最小          两个值中较小的 min()   两个值中较大的 max()   序列中的最小元素 min_element()   序列中的最大元素 max_element()    词典比较          两个序列按字典序的第一个在前 lexicographical_compare()    排列生成器          按字典序的下一个排列 next_permutation()   按字典序的前一个排列 prev_permutation()    函数对象类模板    函数对象类模板 成员函数 T operator ( const T &amp;amp; x, const T &amp;amp; y) 的功能     plus  return x + y;   minus &amp;lt; &amp;gt; return x - y;   multiplies  return x * y;   divides  return x / y;   modulus  return x % y;        成员函数 bool operator( const T &amp;amp; x, const T &amp;amp; y) 的功能   equal_to  return x == y;   not_equal_to  return x!</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - lambda表达式</title>
      <link>https://jfy0o0.github.io/2020/cpp_lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Fri, 11 Dec 2020 16:54:59 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>lambda 说明  lambda表达式 就是一个函数（匿名函数），也就是没有函数名的函数。 为什么不需要函数名呢，因为我们直接（一次性的）用它，嵌入式用的它，不需要其他地方调用它。 lambda表达式也叫闭包，闭就是封闭的意思，就是其他地方都不用他，包就是函数。 lambda表达式其实就是一个函数对象，他内部创建了一个重载()操作符的类。  简易入门 //最简单的一个lambda表达式。 int main() { [] { }();//[]代表lambda表达式的开始，{}代表函数体，什么都没有，()代表调用函数. } // []() {}(); // 加了一个()代表函数参数。什么参数都没有，就可以省略。 输出 int main() { [] { cout &amp;lt;&amp;lt; &amp;#34;Hello, World!&amp;#34;; }(); auto lam = [] { cout &amp;lt;&amp;lt; &amp;#34;Hello, World!&amp;#34;; }; lam(); } 返回值 // -&amp;gt; int ：代表返回int。  int main() { auto lam =[]() -&amp;gt; int { cout &amp;lt;&amp;lt; &amp;#34;Hello, World!&amp;#34;; return 1; }; auto ret = lam(); auto lam2 =[]() -&amp;gt; string { cout &amp;lt;&amp;lt; &amp;#34;Hello, World!</description>
    </item>
    
    <item>
      <title>Algorithm - 七大查找算法</title>
      <link>https://jfy0o0.github.io/2020/algorithm-%E4%B8%83%E5%A4%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 11 Dec 2020 09:57:19 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/algorithm-%E4%B8%83%E5%A4%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</guid>
      <description>顺序 说明： 顺序查找适用于存储结构为顺序存储或链式存储的线性表。
基本思想： ​ 顺序查找也称为线形查找，属于无序查找算法。从数据结构线性表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定K值进行比较，若相等则表示查找成功，若扫描结束仍旧没有找到关键字等于K的结点，则表示查找失败。
代码 #include&amp;lt;iostream&amp;gt;using namespace std; int SequenceSearch(int a[], int value, int n) { int i; for (i = 0; i&amp;lt;n; i++) if (a[i] == value) return i; return -1; } int main() { int a[] = { 2, 3, 5, 8, 6, 7, 9, 0 }; int key, index; int n = sizeof(a) / sizeof(a[0]); cout &amp;lt;&amp;lt; &amp;#34;请输入待查找的值：&amp;#34; &amp;lt;&amp;lt; endl; cin &amp;gt;&amp;gt; key; index = SequenceSearch(a, key, n); if (index &amp;gt;= 0) { cout &amp;lt;&amp;lt; &amp;#34;找到了&amp;#34; &amp;lt;&amp;lt; endl; } else { cout &amp;lt;&amp;lt; &amp;#34;没找到&amp;#34; &amp;lt;&amp;lt; endl; } system(&amp;#34;pause&amp;#34;); return 0; 二分 说明： 元素必须有序方能使用，无序则要先进行排序。</description>
    </item>
    
    <item>
      <title>Algorithm - 十大排序算法</title>
      <link>https://jfy0o0.github.io/2020/algorithm_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</link>
      <pubDate>Fri, 11 Dec 2020 09:25:20 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/algorithm_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</guid>
      <description>冒泡 步骤  从头开始，每次比较两元素，若大者在前，则交换两元素，直至数组末尾，此时最大元素为数组最后的元素； 重复以上步骤，从头开始至上一轮比较的末尾元素；  性质  稳定算法；  代码 // 冒泡排序 void bubbleSort(vector&amp;lt;int&amp;gt;&amp;amp; array) { for (size_t i = 0; i &amp;lt; array.size(); i++) { // 当前轮是否发生过交换事件标志位，若未发生交换，则表明列表已有序。  bool isExchanged = false; for (size_t j = 0; j &amp;lt; array.size() - i - 1; j++) { if (array[j] &amp;gt; array[j + 1]) { int temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; isExchanged = true; } } if (!</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - cast用法</title>
      <link>https://jfy0o0.github.io/2020/cpp_cast%E7%94%A8%E6%B3%95/</link>
      <pubDate>Thu, 10 Dec 2020 11:34:01 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_cast%E7%94%A8%E6%B3%95/</guid>
      <description>static_cast static_cast&amp;lt; new_type &amp;gt;(expression)  相当于传统的C语言里的强制转换 把expression转换为new_type类型 编译时检查，用于非多态的转换，可以转换指针及其他 没有运行时类型检查来保证转换的安全性  用法  用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。  进行上行转换（把派生类的指针或引用转换成基类表示）是安全的； 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。   用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。 把空指针转换成目标类型的空指针。 把任何类型的表达式转换成void类型。 static_cast不能转换掉expression的const、volatile、或者__unaligned属性  例子 char a = &amp;#39;a&amp;#39;; int b = static_cast&amp;lt;int&amp;gt;(a);//正确，将char型数据转换成int型数据  double *c = new double; void *d = static_cast&amp;lt;void*&amp;gt;(c);//正确，将double指针转换成void指针  int e = 10; const int f = static_cast&amp;lt;const int&amp;gt;(e);//正确，将int型数据转换成const int型数据  const int g = 20; int *h = static_cast&amp;lt;int*&amp;gt;(&amp;amp;g);//编译错误，static_cast不能转换掉g的const属性  class Base {}; class Derived : public Base {} Base* pB = new Base(); if(Derived* pD = static_cast&amp;lt;Derived*&amp;gt;(pB)) {}//下行转换是不安全的(坚决抵制这种方法)  Derived* pD = new Derived(); if(Base* pB = static_cast&amp;lt;Base*&amp;gt;(pD)) {}//上行转换是安全的 dynamic_cast dynamic_cast&amp;lt; type* &amp;gt;(e) //type必须是一个类类型且必须是一个有效的指针 dynamic_cast&amp;lt; type&amp;amp; &amp;gt;(e) //type必须是一个类类型且必须是一个左值 dynamic_cast&amp;lt; type&amp;amp;&amp;amp; &amp;gt;(e) //type必须是一个类类型且必须是一个右值 e的类型必须符合以下三个条件中的任何一个：</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - new的三种用法</title>
      <link>https://jfy0o0.github.io/2020/cpp_new%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95/</link>
      <pubDate>Fri, 04 Dec 2020 10:19:49 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_new%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95/</guid>
      <description>new用法总结 new可以说是个
 一个关键字， 一个运算符 可以被重载。  new operator 这个就是平时最经常用的new，用法如下程序所示：
class A { public: A(int i) :a(i){} private: int a; }; int main() { A* example = new A(1); } 说明 new operator实际上执行了以下三个步骤：
 调用operator new分配内存（后面要说的第二种new），  如果类本身定义了operator new，那么会调用类自己的operator new，而不是全局的； 如果未定义，则是全局的   调用A的构造函数A::A(int)； 返回相应的指针  operator new operator new不调用构造函数，而仅仅分配内存，
有两个版本，
 前者抛出异常 后者当失败时不抛出异常，而是直接返回：  void* operator new (std::size_t size); void* operator new (std::size_t size, const std::nothrow_t&amp;amp; nothrow_value) noexcept; class A { public: A(int i) :a(i){} void* operator new(size_t size) { cout &amp;lt;&amp;lt; &amp;#34;call A::operator new&amp;#34; &amp;lt;&amp;lt; endl; return malloc(size); } void operator delete(void* p) { cout &amp;lt;&amp;lt; &amp;#34;call A::operator delete&amp;#34; &amp;lt;&amp;lt; endl; return free(p); } void* operator new(size_t size, const nothrow_t&amp;amp; nothrow_value) noexcept { cout &amp;lt;&amp;lt; &amp;#34;call A::operator new (noexcept)&amp;#34; &amp;lt;&amp;lt; endl; return malloc(size); } void operator delete(void* p, const nothrow_t&amp;amp; nothrow_value) noexcept { cout &amp;lt;&amp;lt; &amp;#34;call A::operator delete (noexcept)&amp;#34; &amp;lt;&amp;lt; endl; free(p); } private: int a; }; int main() { A* example1 = new A(1); delete example1; A* example2 = new(nothrow) A(2); delete example2; } placement new placement new仅在一个已经分配好的内存指针上调用构造函数，基本形式如下：</description>
    </item>
    
    <item>
      <title>Other - 对象池</title>
      <link>https://jfy0o0.github.io/2020/other-%E5%AF%B9%E8%B1%A1%E6%B1%A0/</link>
      <pubDate>Fri, 04 Dec 2020 09:27:19 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/other-%E5%AF%B9%E8%B1%A1%E6%B1%A0/</guid>
      <description>对象池  对象池是一种空间换时间的技术，  对象被预先创建并初始化后放入对象池中， 对象提供者就能利用已有的对象来处理请求，并在不需要时归还给池子而非直接销毁   它减少对象频繁创建所占用的内存 空间和初始化时间  原理 描述一个对象池有两个很重要的参数，
  对象池的类型，
  对象池可以获得对象的数量
   对象池的实现和内存池的实现原理很像：  都是一开始申请大内存空间， 然后把大内存分配成小内存空间，当需要使用的时候直接分配使用，不在向系统申请内存空间，也不直接释放内存空间。 使用完之后都是放回池子里   不同的地方在内存池有一个映射数组，在使用时负责快速定位合适的内存池（一个内存池可以有很多内存块大小不同的池子） 但是每一个类型的对象只对应一个对象池，并自己管理自己的对象池。不同类型的对象池是相互独立的存在  优点  减少频繁创建和销毁对象带来的成本，实现对象的缓存和复用 提高了获取对象的响应速度，对实时性要求较高的程序有很大帮助 一定程度上减少了垃圾回收机制（GC）的压力  缺点  1、很难设定对象池的大小，如果太小则不起作用，过大又会占用内存资源过高 2、并发环境中, 多个线程可能(同时)需要获取池中对象, 进而需要在堆数据结构上进行同步或者因为锁竞争而产生阻塞, 这种开销要比创建销毁对象的开销高数百倍; 3、由于池中对象的数量有限, 势必成为一个可伸缩性瓶颈; 4、所谓的脏对象就是指的是当对象被放回对象池后，还保留着刚刚被客户端调用时生成的数据。  脏对象可能带来两个问题   脏对象持有上次使用的引用，导致内存泄漏等问题。
  脏对象如果下一次使用时没有做清理，可能影响程序的处理数据。
  什么条件下使用对象池  资源受限的, 不需要可伸缩性的环境: cpu性能不够强劲, 内存比较紧张, 垃圾收集, 内存抖动会造成比较大的影响, 需要提高内存管理效率,响应性比吞吐量更为重要; 数量受限的, 比如数据库连接; 创建对象的成本比较大，并且创建比较频繁。比如线程的创建代价比较大，于是就有了常用的线程池。  实现   在一部分内存空间（池子）中事先实例化好固定数量的对象，</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - 使用技巧</title>
      <link>https://jfy0o0.github.io/2020/cpp_%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Thu, 03 Dec 2020 18:44:42 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <description>变长数组 特点：
 变长 空间合理  eg: struct MutableLenArray { int count; char p[0]; }; 宏的妙用 1. “#”符号把一个符号直接转换为字符串，例如：
#define TO_STRING(x) #x const char *str = TO_STRING( test ); ##符号会连接两个符号，从而产生新的符号(词法层次)，例如：
#define SIGN( x ) INT_##x int SIGN( 1 ); //宏被展开后将成为：int INT_1; 2. 变参宏 #define LOG( format, ... ) printf( format, __VA_ARGS__ ) LOG( &amp;#34;%s %d&amp;#34;, str, count );  VA_ARGS是系统预定义宏，被自动替换为参数列表。 经常需要进行输出格式化，重定义时，可以用到以上技巧。  不定参 模板实现： template&amp;lt;typename... T&amp;gt; void func(T... args) { for (auto x : {args.</description>
    </item>
    
    <item>
      <title>Linux - 线程同步 - 条件变量</title>
      <link>https://jfy0o0.github.io/2020/linux-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</link>
      <pubDate>Fri, 20 Nov 2020 16:50:06 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/linux-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F/</guid>
      <description>条件变量 条件变量是利用线程间共享全局变量进行同步的一种机制。
条件变量上的基本操作有：
 触发条件(当条件变为 true 时)； 等待条件，挂起线程直到其他线程触发条件。  声明 //初始化条件变量　//尽管POSIX标准中为条件变量定义了属性，但在Linux中没有实现，因此cond_attr值通常为NULL，且被忽略。 int pthread_cond_init(pthread_cond_t *cond,pthread_condattr_t *cond_attr); //无条件等待 int pthread_cond_wait(pthread_cond_t *cond,pthread_mutex_t *mutex); //计时等待 int pthread_cond_timewait(pthread_cond_t *cond,pthread_mutex *mutex,const timespec *abstime); /* 无论哪种等待方式，都必须和一个互斥锁配合，以防止多个线程同时请求（用 pthread_cond_wait() 或 pthread_cond_timedwait() 请求）竞争条件（Race Condition）。 mutex互斥锁必须是普通锁（PTHREAD_MUTEX_TIMED_NP）或者适应锁（PTHREAD_MUTEX_ADAPTIVE_NP）， 且在调用pthread_cond_wait()前必须由本线程加锁（pthread_mutex_lock()）， 而在更新条件等待队列以前，mutex保持锁定状态，并在线程挂起进入等待前解锁。 在条件满足从而离开pthread_cond_wait()之前，mutex将被重新加锁，以与进入pthread_cond_wait()前的加锁动作对应。 */ //激活一个等待该条件的线程（存在多个等待线程时按入队顺序激活其中一个 int pthread_cond_signal(pthread_cond_t *cond); //激活所有等待线程 int pthread_cond_broadcast(pthread_cond_t *cond); //销毁条件变量 int pthread_cond_destroy(pthread_cond_t *cond); 说明：  pthread_cond_wait  自动解锁互斥量(如同执行了pthread_unlock_mutex)，并等待条件变量触发。 这时线程挂起，不占用CPU时间，直到条件变量被触发（变量为ture）。 在调用 pthread_cond_wait之前，应用程序必须加锁互斥量。 pthread_cond_wait函数返回前，自动重新对互斥量加锁(如同执行了pthread_lock_mutex)。 就是说 使用这个函数会自动解锁 ，在满足条件的时候自动加锁   互斥量的解锁和在条件变量上挂起都是自动进行的。  因此，在条件变量被触发前，如果所有的线程都要对互斥量加锁，这种机制可保证在线程加锁互斥量和进入等待条件变量期间，条件变量不被触发。 条件变量要和互斥量相联结，以避免出现条件竞争——个线程预备等待一个条件变量，当它在真正进入等待之前，另一个线程恰好触发了该条件（条件满足信号有可能在测试条件和调用pthread_cond_wait函数（block）之间被发出，从而造成无限制的等待）。   条件变量函数不是异步信号安全的，不应当在信号处理程序中进行调用。  特别要注意，如果在信号处理程序中调用 pthread_cond_signal 或 pthread_cond_boardcast 函数，可能导致调用线程死锁    例子 #include &amp;lt;pthread.</description>
    </item>
    
    <item>
      <title>Linux - 线程同步 - 读写锁</title>
      <link>https://jfy0o0.github.io/2020/linux-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E8%AF%BB%E5%86%99%E9%94%81/</link>
      <pubDate>Fri, 20 Nov 2020 16:44:48 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/linux-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E8%AF%BB%E5%86%99%E9%94%81/</guid>
      <description>读写锁  如果一个线程用读锁锁定了临界区，那么其他线程也可以用读锁来进入临界区，这样就可以多个线程并行操作。但这个时候，如果再进行写锁加锁就会发生阻塞，写锁请求阻塞后，后面如果继续有读锁来请求，这些后来的读锁都会被阻塞！这样避免了读锁长期占用资源，防止写锁饥饿！ 如果一个线程用写锁锁住了临界区，那么其他线程不管是读锁还是写锁都会发生阻塞！  声明 //初始化： int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock, const pthread_rwlockattr_t *restrict attr); //读写加锁 int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_unlock(pthread_rwlock_t *rwlock); int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict abs_timeout); int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock, const struct timespec *restrict abs_timeout); //销毁锁 int pthread_rwlock_destroy(pthread_rwlock_t *rwlock); 例子: #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;pthread.h&amp;gt; /* 初始化读写锁 */ pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER; //pthread_rwlock_t rwlock; /* 全局资源 */ int global_num = 10; void err_exit(const char *err_msg) { printf(&amp;#34;error:%s\n&amp;#34;, err_msg); exit(1); } /* 读锁线程函数 */ void *thread_read_lock(void *arg) { char *pthr_name = (char *)arg; while (1) { /* 读加锁 */ pthread_rwlock_rdlock(&amp;amp;rwlock); printf(&amp;#34;线程%s进入临界区，global_num = %d\n&amp;#34;, pthr_name, global_num); sleep(1); printf(&amp;#34;线程%s离开临界区.</description>
    </item>
    
    <item>
      <title>Linux - 线程同步 - 互斥锁</title>
      <link>https://jfy0o0.github.io/2020/linux-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E4%BA%92%E6%96%A5%E9%94%81/</link>
      <pubDate>Fri, 20 Nov 2020 16:36:13 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/linux-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E4%BA%92%E6%96%A5%E9%94%81/</guid>
      <description>互斥锁 锁机制是同一时刻只允许一个线程执行一个关键部分的代码。
声明 /* 其中参数 mutexattr 用于指定锁的属性（见下），如果为NULL则使用缺省属性。 互斥锁的属性在创建锁的时候指定，在LinuxThreads实现中仅有一个锁类型属性，不同的锁类型在试图对一个已经被锁定的互斥锁加锁时表现不同。当前有四个值可供选择： （1）PTHREAD_MUTEX_TIMED_NP，这是缺省值，也就是普通锁。当一个线程加锁以后，其余请求锁的线程将形成一个等待队列，并在解锁后按优先级获得锁。这种锁策略保证了资源分配的公平性。 （2）PTHREAD_MUTEX_RECURSIVE_NP，嵌套锁，允许同一个线程对同一个锁成功获得多次，并通过多次unlock解锁。如果是不同线程请求，则在加锁线程解锁时重新竞争。 （3）PTHREAD_MUTEX_ERRORCHECK_NP，检错锁，如果同一个线程请求同一个锁，则返回EDEADLK，否则与PTHREAD_MUTEX_TIMED_NP类型动作相同。这样就保证当不允许多次加锁时不会出现最简单情况下的死锁。 （4）PTHREAD_MUTEX_ADAPTIVE_NP，适应锁，动作最简单的锁类型，仅等待解锁后重新竞争。 */ int pthread_mutex_init(pthread_mutex_t *mutex,const pthread_mutex_attr_t *mutexattr); //阻塞加锁 int pthread_mutex_lock(pthread_mutex *mutex); //非阻塞加锁 int pthread_mutex_trylock( pthread_mutex_t *mutex); //解锁（要求锁是lock状态,并且由加锁线程解锁） int pthread_mutex_unlock(pthread_mutex *mutex); //销毁锁（此时锁必需unlock状态,否则返回EBUSY） int pthread_mutex_destroy(pthread_mutex *mutex); 例子 #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;pthread.h&amp;gt; pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER; //pthread_mutex_t mutex ; int gn; void* thread(void *arg) { printf(&amp;#34;thread&amp;#39;s ID is %d\n&amp;#34;,pthread_self()); pthread_mutex_lock(&amp;amp;mutex); gn = 12; printf(&amp;#34;Now gn = %d\n&amp;#34;,gn); pthread_mutex_unlock(&amp;amp;mutex); return NULL; } int main() { // pthread_mutex_init(&amp;amp;mutex,NULL);  pthread_t id; printf(&amp;#34;main thread&amp;#39;s ID is %d\n&amp;#34;,pthread_self()); gn = 3; printf(&amp;#34;In main func, gn = %d\n&amp;#34;,gn); if (!</description>
    </item>
    
    <item>
      <title>Linux - 线程同步 - 信号量</title>
      <link>https://jfy0o0.github.io/2020/linux-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link>
      <pubDate>Fri, 20 Nov 2020 16:23:29 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/linux-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid>
      <description>信号量 信号量和互斥锁(mutex)的区别：
 互斥锁只允许一个线程进入临界区 信号量允许多个线程同时进入临界区。  信号量强调的是线程（或进程）间的同步：“信号量用在多线程多任务同步的，一个线程完成了某一个动作就通过信号量告诉别的线程，别的线程再进行某些动作（大家都在sem_wait的时候，就阻塞在那里）。当信号量为单值信号量时，也可以完成一个资源的互斥访问。信号量测重于访问者对资源的有序访问，在大多数情况下，同步已经实现了互斥，特别是所有写入资源的情况必定是互斥的。少数情况是指可以允许多个访问者同时访问资源。
声明 #include&amp;lt;semaphore.h&amp;gt;/* -sem:是要初始化的信号量， -pshared:表示此信号量是在进程间共享还是线程间共享， -value:是信号量的初始值。 */ int sem_init(sem_t *sem, int pshared, unsigned int value); /* -sem:是要销毁的信号量。只有用sem_init初始化的信号量才能用sem_destroy销毁。 */ int sem_destroy(sem_t *sem); /* 等待信号量，如果信号量的值大于0,将信号量的值减1,立即返回。 如果信号量的值为0,则线程阻塞。相当于P操作。成功返回0,失败返回-1。 */ int sem_wait(sem_t *sem); /* 释放信号量，让信号量的值加1。相当于V操作。 */ int sem_post(sem_t *sem); 例子： #include &amp;lt;pthread.h&amp;gt;#include &amp;lt;semaphore.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt; /* @Scene: 某行业营业厅同时只能服务两个顾客。 * 有多个顾客到来，每个顾客如果发现服务窗口已满，就等待， * 如果有可用的服务窗口，就接受服务。 */ /* 将信号量定义为全局变量，方便多个线程共享 */ sem_t sem; /* 每个线程要运行的例程 */ void * get_service(void *thread_id) { /* 注意：立即保存thread_id的值，因为thread_id是对主线程中循环变量i的引用，它可能马上被修改 */ int customer_id = *((int *)thread_id); if(sem_wait(&amp;amp;sem) == 0) { usleep(100); /* service time: 100ms */ printf(&amp;#34;customer %d receive service .</description>
    </item>
    
    <item>
      <title>Linux - 进程通信 - 共享内存</title>
      <link>https://jfy0o0.github.io/2020/linux-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</link>
      <pubDate>Fri, 20 Nov 2020 10:28:40 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/linux-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/</guid>
      <description>共享内存 共享内存是 Unix下的多进程之间的通信方法,这种方法通常用于一个程序的多进程间通信，实际上多个程序间也可以通过共享内存来传递信息。
特点  所谓共享内存就是使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。 是针对其他通信机制运行效率较低而设计的。 但内部没有共享内存互斥访问机制，所以往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。  声明 #include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/ipc.h&amp;gt;#include &amp;lt;sys/shm.h&amp;gt;/* fname：指定的文件名（已经存在的文件名），一般使用当前目录，如：&amp;#34;.&amp;#34; id：id是子序号。虽然是int类型，但是只使用8bits(1-255)。 在一般的UNIX实现中，是将文件的索引节点号取出，前面加上子序号得到key_t的返回值。 如:指定文件的索引节点号为65538，换算成16进制为0x010002，而你指定的ID值为38， 换算成16进制为0x26，则最后的key_t返回值为0x26010002。 查询文件索引节点号的方法是： ls -i 当删除重建文件后，索引节点号由操作系统根据当时文件系统的使用情况分配， 因此与原来不同，所以得到的索引节点号也不同。 */ key_t ftok( const char * fname, int id ); /* -key 0(IPC_PRIVATE)：会建立新共享内存对象 大于0的32位整数：视参数shmflg来确定操作。通常要求此值来源于ftok返回的IPC键值 -size 大于0的整数：新建的共享内存大小，以字节为单位 0：只获取共享内存时指定为0 -shmflg 0：取共享内存标识符，若不存在则函数会报错 IPC_CREAT：当shmflg&amp;amp;IPC_CREAT为真时，如果内核中不存在键值与key相等的共享内存，则新建一个共享内存；如果存在这样的共享内存，返回此共享内存的标识符 IPC_CREAT|IPC_EXCL：如果内核中不存在键值与key相等的共享内存，则新建一个共享内存；如果存在这样的共享内存则报错 使用时需要与IPC对象存取权限（如0600）进行|运算来确定信号量集的存取权限 -函数返回值 成功：返回共享内存的标识符 出错：-1，错误原因存于error中 -错误代码 EINVAL：参数size小于SHMMIN或大于SHMMAX EEXIST：预建立key所指的共享内存，但已经存在 EIDRM：参数key所指的共享内存已经删除 ENOSPC：超过了系统允许建立的共享内存的最大值(SHMALL) ENOENT：参数key所指的共享内存不存在，而参数shmflg未设IPC_CREAT位 EACCES：没有权限 ENOMEM：核心内存不足 */ int shmget(key_t key, size_t size, int shmflg); /* shmid：共享内存标识符 cmd IPC_STAT：得到共享内存的状态，把共享内存的shmid_ds结构复制到buf中 IPC_SET：改变共享内存的状态，把buf所指的shmid_ds结构中的uid、gid、mode复制到共享内存的shmid_ds结构内 IPC_RMID：删除这片共享内存 buf：共享内存管理结构体。具体说明参见共享内存内核结构定义部分 函数返回值 成功：0 出错：-1，错误原因存于error中 错误代码 EACCESS：参数cmd为IPC_STAT，确无权限读取该共享内存 EFAULT：参数buf指向无效的内存地址 EIDRM：标识符为shmid的共享内存已被删除 EINVAL：无效的参数cmd或shmid EPERM：参数cmd为IPC_SET或IPC_RMID，却无足够的权限执行 */ int shmctl(int shmid, int cmd, struct shmid_ds *buf) 例子： 写端： #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>Linux - 进程通信 - 信号</title>
      <link>https://jfy0o0.github.io/2020/linux-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E4%BF%A1%E5%8F%B7/</link>
      <pubDate>Fri, 20 Nov 2020 10:10:16 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/linux-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E4%BF%A1%E5%8F%B7/</guid>
      <description>信号  信号是在软件层次上对中断机制的一种模拟，是一种异步通信方式 信号可以直接进行用户空间进程和内核进程之间的交互，内核进程也可以利用它来通知用户空间进程发生了哪些系统事件。 如果该进程当前并未处于执行态，则该信号就由内核保存起来，直到该进程恢复执行再传递给它；如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消时才被传递给进程。  响应 用户进程对信号的响应方式：
 忽略信号：对信号不做任何处理，但是有两个信号不能忽略：即SIGKILL及SIGSTOP。 捕捉信号：定义信号处理函数，当信号发生时，执行相应的处理函数。 执行缺省操作：Linux对每种信号都规定了默认操作  种类：  SIGINT：ctrl+c 终止信号 SIGQUIT：ctrl+\ 终止信号 SIGTSTP:ctrl+z 暂停信号 SIGALRM：闹钟信号 收到此信号后定时结束，结束进程 SIGCHLD：子进程状态改变，父进程收到信号 SIGKILL：杀死信号  声明 /* 功能：信号发送 -参数：pid：指定进程 -sig：要发送的信号 -返回值：成功 0；失败 -1 */ int kill(pid_t pid, int sig); /* 功能：进程向自己发送信号 -参数：sig：信号 -返回值：成功 0；失败 -1 */ int raise(int sig); /* 功能：在进程中设置一个定时器 -参数：seconds：定时时间，单位为秒 -返回值：如果调用此alarm()前，进程中已经设置了闹钟时间，则返回上一个闹钟时间的剩余时间，否则返回0。 */ unsigned int alarm(unsigned int seconds) 注意：一个进程只能有一个闹钟时间。如果在调用alarm时已设置过闹钟时间，则之前的闹钟时间被新值所代替 //功能：用于将调用进程挂起直到收到信号为止。 int pause(void); /* 功能：信号处理函数 参数： -signum：要处理的信号//不能是SIGKILL和SIGSTOP -handler：SIG_IGN：忽略该信号。 -SIG_DFL：采用系统默认方式处理信号。 自定义的信号处理函数指针 返回值：成功：设置之前的信号处理方式；失败：SIG_ERR */ void (*signal(int signum, void (*handler)(int)))(int); //　或者： 　typedef void (*sighandler_t)(int); sighandler_t signal(int signum, sighandler_t handler); //给自己发送异常终止信号，（6.</description>
    </item>
    
    <item>
      <title>Linux - 进程通信 - 消息队列</title>
      <link>https://jfy0o0.github.io/2020/linux-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link>
      <pubDate>Fri, 20 Nov 2020 09:52:58 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/linux-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid>
      <description>消息队列  消息队列实质为内核地址空间中的内部链表，在Linux中各个进程之间传递内容 消息顺序的发送到队列中，以不同的方式从队列中获取，消息队列可以用IPC标识符唯一地进行标识。 消息队列由IPC标识符进行区别，队列与队列之间是相互独立的。 每个消息队列中的消息，又构成一个独立的链表。  声明 #include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/ipc.h&amp;gt;#include &amp;lt;sys/msg.h&amp;gt;/* 用于创建一个新的消息队列，或者访问一个现有的队列。 -key：为键值，由ftok（）函数生成。 -msgflg： IPC_CREAT:内核中不存在该队列，则创建它； IPC_EXCL:当与IPC_CREAT一起使用时，如果队列早已存在则将出错。 */ int msgget ( key_t key ,int msgflg); /* 用于向一个队列传递消息。 -msqid：队列标识符，是由前面调用msgget（）获得的返回值。 -msgp：指向消息缓冲区。 -msgsz：消息缓冲区的大小。 -msgflag： 可以设置为0，表示忽略 可以设置为IPC_NOWAIT：如果消息队列已经满了，则不会写入消息队列。若没有写，则调用进程将被中断，直到可以写消息为止。 */ int msgsnd (int msqid, const void *msgp, size_t msgsz , int msgflag); /* 用于在消息队列上执行接收操作 -msqid：队列标识符，是由前面调用msgget（）获得的返回值。 -msgp：指向消息缓冲区。 -msgsz：消息缓冲区的大小。 -mtype:指定要从队列中获取的消息类型。 -msgflag: 若设置为IPC_NOWAIT作为一个标志传送给该函数，而队列没有消息，则会返回ENOMSG。否则进程将被阻塞。 如果在等待消息的时候队列被删除，则返回EIDRM。 如果进程阻塞并等待消息的到来时捕获到了一个信号，则返回EINTR。 */ int msgrcv (int msqid, void *msgp, size_t msgsz , long msgtyp ,int msgflag); /* 向内核发送一个cmd命令，内核根据此来判断进行何种操作。 -msqid：队列标识符，是由前面调用msgget（）获得的返回值。 -cmd: IPC_STAT:把msgid_ds结构中的数据设置为消息队列的当前关联值，即用消息队列的当前关联值覆盖msgid_ds的值。 IPC_SET：把消息列队的当前关联值设置为msgid_ds结构中给出的值 IPC_RMID：删除消息队列 */ int msgclt (int msqid, int cmd, struct msqid_ds *buf); struct msgbuf { __syscall_slong_t mtype;	/* type of received/sent message */ char mtext[1];	/* text of the message */ }; 例子 发端： #include &amp;lt;unistd.</description>
    </item>
    
    <item>
      <title>Linux - 进程通信 - 信号量</title>
      <link>https://jfy0o0.github.io/2020/linux-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E4%BF%A1%E5%8F%B7%E9%87%8F/</link>
      <pubDate>Fri, 20 Nov 2020 09:45:22 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/linux-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E4%BF%A1%E5%8F%B7%E9%87%8F/</guid>
      <description>信号量  信号量是一种计数器 生产者消费者的典型使用  声明 #include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/ipc.h&amp;gt;#include &amp;lt;sys/sem.h&amp;gt;/* 用于创建一个新的信号量集合 - key:ftok()生成的键值 - nsems:指定在新的集合中创建信号量的数目 - semflsg:打开信号量的方式 */ int semget (key_t key ,int nsems , int semflg); /* 对信号量的P、V操作 - sembuf：将要在信号量上执行的操作 - nsops：操作个数 */ int semop (int semid,struct sembuf *sops,unsigned nsops); /* 用于在信号量集合上执行控制操作。 */ int semctl (int semid,int semnum,int cmd,...); 例子： #include &amp;lt;iostream&amp;gt;#include &amp;lt;cstdio&amp;gt; using namespace std; #include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/ipc.h&amp;gt;#include &amp;lt;sys/sem.h&amp;gt; union semun { int val; struct semid_ds *buf; unsigned short *array; }arg; int CreateSem(key_t key,int value){ union semun sem; int semid ; sem.</description>
    </item>
    
    <item>
      <title>Linux - 进程通信 - 有名管道</title>
      <link>https://jfy0o0.github.io/2020/linux-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93/</link>
      <pubDate>Fri, 20 Nov 2020 09:36:37 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/linux-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93/</guid>
      <description>命名管道的基本概念  命名管道与前篇文章中的半双工管道非常相似 在文件系统中命名管道是以设备特殊文件的形式存在的 不同的进程可以通过命名管道共享数据，与普通管道不同的是可与无血缘关系的进程进行通信。  声明 #include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;sys/stat.h&amp;gt;int mkfifo (consta char* pathname , mode_t mode); 例子 写端： #include &amp;lt;stdio.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;fcntl.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;cstring&amp;gt;#include &amp;lt;iostream&amp;gt;using namespace std; int main(int argc , char **argv){ int wfd = open(&amp;#34;mypipe&amp;#34;,O_WDONLY); if( wfd &amp;lt; 0 ){ printf( &amp;#34;open failed &amp;#34; ); return -1; } int ret = mkfifo (&amp;#34;mypipe&amp;#34; , 0664); if( ret &amp;lt; 0){ printf ( &amp;#34;mkfifo failed&amp;#34; ); return -1; } while(1){ char buf[1024]; cin &amp;gt;&amp;gt; buf; ret = write(wfd , buf ,sizeof (buf)); if(ret &amp;gt;= 0 ){ printf( &amp;#34; buf: %s&amp;#34;,buf ); } } close (wfd); return 0; } 读端： #include &amp;lt;stdio.</description>
    </item>
    
    <item>
      <title>Linux - 进程通信 - 匿名管道</title>
      <link>https://jfy0o0.github.io/2020/linux-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93/</link>
      <pubDate>Fri, 20 Nov 2020 09:25:44 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/linux-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1-%E5%8C%BF%E5%90%8D%E7%AE%A1%E9%81%93/</guid>
      <description>管道 管道是一种古老的IPC通信形式。它有两个特点：
 半双工，即不能同时在两个方向上传输数据。有的系统可能支持全双工。 只能在父子进程间。经典的形式就是管道由父进程创建，进程fork子进程之后，就可以在父子进程之间使用了。 进程创建管道，每次创建两个文件描述符来操作管道。 其中一个对管道进行写，另一个对管道进行读操作。  声明 使用popen函数和pclose函数结合来执行系统命令，就用到了管道，它们声明如下：
FILE *popen(const char *command,const char *type); int pclose(FILE *stream); #include &amp;lt;unistd.h&amp;gt;int pipe(int filedes[2]);  filedes是一个文件描述符的数组，用于保存管道返回的两个文件描述符。 下标为0是为了读操作而创建打开的，下标为1是为了写操作而创建打开的。 执行成功返回0；失败返回1；  例子 我们看一个简单的使用管道的例子，这里使用了pipe函数来创建管道：
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;unistd.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#define MAX_LEN 128 int main() { /*0为读，1为写*/ int fd[2] = {0}; //描述符  pid_t pid = 0; char line[MAX_LEN] = {0}; int n = 0; /*创建管道，需要传入两个文件描述符*/ if(pipe(fd) &amp;lt; 0) { perror(&amp;#34;create pipe failed\n&amp;#34;); return -1; } /*fork子进程*/ if((pid = fork()) &amp;lt; 0) { perror(&amp;#34;fork failed\n&amp;#34;); return -1; } /*父进程*/ else if(pid &amp;gt; 0) { /*关闭管道的写描述符*/ close(fd[1]); /*从管道读取数据*/ n = read(fd[0],line,MAX_LEN); printf(&amp;#34;read %d bytes from pipe :%s\n&amp;#34;,n,line); } /*子进程*/ else { /*关闭管道的读描述符*/ close(fd[0]); /*向管道写入数据*/ write(fd[1],&amp;#34;www.</description>
    </item>
    
    <item>
      <title>Other - 同步、异步、阻塞、非阻塞</title>
      <link>https://jfy0o0.github.io/2020/other-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/</link>
      <pubDate>Tue, 17 Nov 2020 13:54:52 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/other-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/</guid>
      <description>1.同步与异步 同步和异步关注的是消息通信机制
指被调用者
同步  就是在发出一个调用时，在没有得到结果之前，该调用就不返回。 但是一旦调用返回，就得到返回值了。 换句话说，就是由调用者主动等待这个调用的结果。  异步  调用在发出之后，这个调用就直接返回了，所以没有返回结果。 换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。 而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。  例子： 你打电话问书店老板有没有《分布式系统》这本书，
 如果是同步通信机制，书店老板会说，你稍等，”我查一下&amp;quot;，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。 而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。  2. 阻塞与非阻塞 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.
指调用者
阻塞调用 是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用 指在不能立刻得到结果之前，该调用不会阻塞当前线程。
例子： 你打电话问书店老板有没有《分布式系统》这本书，
  你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，
  如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。
  在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。
  说明：  阻塞式发送：发送方进程会被一直阻塞， 直到消息被接受方进程收到。 非阻塞式发送： 发送方进程调用 send() 后， 立即就可以其他操作。 阻塞式接收：接收方调用 receive() 后一直阻塞， 直到消息到达可用。 非阻塞式接受：接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。  例子2： 老张爱喝茶，废话不说，煮开水。 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。
 老张把水壶放到火上，立等水开。（同步阻塞） 老张觉得自己有点傻 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞） 老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。 老张把响水壶放到火上，立等水开。（异步阻塞） 老张觉得这样傻等意义不大 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞） 老张觉得自己聪明了。  所谓同步异步，只是对于水壶**（被调用者）**而言。 普通水壶，同步；响水壶，异步。 虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。 同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</description>
    </item>
    
    <item>
      <title>Other - 大端、小端</title>
      <link>https://jfy0o0.github.io/2020/other-%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF/</link>
      <pubDate>Tue, 17 Nov 2020 13:54:52 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/other-%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF/</guid>
      <description>大端 概念 是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。
这是人类读写数值的方法。
小端 概念 数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，
这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。
简明区分 下面以unsigned int value = 0x12345678为例，
分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value
 Big-Endian: 低地址存放高位，如下：
​	高地址
​	buf[3] (0x78) &amp;ndash; 低位
​	buf[2] (0x56)
​	buf[1] (0x34)
​	buf[0] (0x12) &amp;ndash; 高位
​	低地址
 Little-Endian: 低地址存放低位，如下：
​	高地址
​	buf[3] (0x12) &amp;ndash; 高位
​	buf[2] (0x34)
​	buf[1] (0x56)
​	buf[0] (0x78) &amp;ndash; 低位
​	低地址
    内存地址 小端模式存放内容 大端模式存放内容     0x4000 0x78 0x12   0x4001 0x56 0x34   0x4002 0x34 0x56   0x4003 0x12 0x78    </description>
    </item>
    
    <item>
      <title>C&#43;&#43; - 运算符重载小技巧</title>
      <link>https://jfy0o0.github.io/2020/cpp_%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%B0%8F%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Thu, 12 Nov 2020 15:54:13 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid>
      <description>c++ - 运算符重载小技巧 重载 () ： 多次调用(),然后再调用print()
class A{ public: A operator()(int a) { cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt;endl; return *this; } void print() { cout &amp;lt;&amp;lt; &amp;#34;hello&amp;#34;&amp;lt;&amp;lt;endl; } }; int main() { A a; a(54)(434).print(); //54 	//434 	//hello } 重载 ++ ： ++ 运算符，还可分为前缀 ++ 和后缀 ++ 运算符。
class Length { private: int len_inches; public: //前缀++的声明  Length operator++ (); //后缀++的声明  Length operator++ (int); }; 重载前缀++运算符: C++允许重载前缀运算符，以使表达式 ++b 能递增 b 的长度值，并返回结果对象。该运算符可以作为成员函数来重载，这使得它的单个形参是隐含的， 所以重载运算符不需要形参。</description>
    </item>
    
    <item>
      <title>Boost - 容器</title>
      <link>https://jfy0o0.github.io/2020/boost-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Thu, 12 Nov 2020 10:23:27 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E5%AE%B9%E5%99%A8/</guid>
      <description>boost-容器  array unordered_map、unordered_set bimap circular_buffer dynamic_bitset multi_array  array: array相当于是一个增加了STL容器接口的数组，但它不像vector等容器一样可以动态增长，如果需要动态变动array的容量可以使用boost::scoped_array。array适用与对运行速度要求很高的场合。C++11中已支持array。
用法： #include &amp;lt;boost/array.hpp&amp;gt;#include &amp;lt;boost/typeof/typeof.hpp&amp;gt;int main() { array&amp;lt;int, 5&amp;gt; ary; array&amp;lt;int, 5&amp;gt; ary2 = { 1, 2, 3, 4, 5 };//可以使用{}初始化array  ary = ary2;//赋值  swap(ary, ary2)//互换  ary.assign(0);//所有元素赋值为0  ary[0] = 1;//头元素  ary.back() = 10;//尾元素  ary.at(5);//使用at访问元素  int*p = ary.c_array();//获得原始数组指针  int s = ary.size();//获得数组中元素个数  sort(ary.begin(), ary.end());//使用STL排序函数对其排序  for (BOOST_AUTO(pos, ary.begin()); pos != ary.end(); ++pos) //遍历数组，使用BOOST_AUTO需要包含&amp;#34;boost/typeof/typeof.</description>
    </item>
    
    <item>
      <title>Boost - 时间与日期</title>
      <link>https://jfy0o0.github.io/2020/boost-%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F/</link>
      <pubDate>Tue, 10 Nov 2020 19:38:42 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F/</guid>
      <description>boost - 时间与日期 boost-timer： timer类可以测量时间的流逝，是一个小型计时器。
使用： #include &amp;lt;boost/timer.hpp&amp;gt;int main() { boost::timer t; //声明时即计时  cout &amp;lt;&amp;lt; t.elapsed_max() &amp;lt;&amp;lt; endl; //可度量最大时间 ，小时单位  cout &amp;lt;&amp;lt; t.elapsed_min() &amp;lt;&amp;lt; endl; //可度量最小时间 ，秒单位  for(int i = 0;i&amp;lt;1000000000;i++); cout &amp;lt;&amp;lt; t.elapsed() &amp;lt;&amp;lt; endl; //输出流逝的时间 （cpu占用的时间） } boost-progress_timer: 继承自timer析构时自动输出时间，省去手动调elapsed()，
使用： #include &amp;lt;boost/progress.hpp&amp;gt;int main() { boost::progress_timer t; cout &amp;lt;&amp;lt; t.elapsed_max() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; t.elapsed_min() &amp;lt;&amp;lt; endl; } boost-progress_display: 表示进度
使用： boost::progress_display pd(10000000); for(int i = 0;i&amp;lt;10000000;i++) { ++pd; } 时间长度类time_duration 说明  类似日期长度类date_duration有days、weeks、months、years这些常用类， time_duration也有几个子类：hours、minutes、seconds、millisec、microsec、nanosec，他们都支持流输入输出、比较操作、加减乘除运算。  使用 //对象的定义  boost::posix_time::time_duration td(1, 10, 30, 1000); //1小时10分钟30秒1毫秒  boost::posix_time::time_duration td1(1, 60, 60, 1000); //2小时1分钟1毫秒，超出的时间会自动进位  boost::posix_time::time_duration td2 = boost::posix_time::duration_from_string(&amp;#34;1:10:30:001&amp;#34;); //1小时10分钟30秒1毫秒  //成员函数  assert(td.</description>
    </item>
    
    <item>
      <title>Boost - 数据类型</title>
      <link>https://jfy0o0.github.io/2020/boost-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 10 Nov 2020 19:03:32 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>Boost - 数据类型   auto
  decltype
  any
  tuple
  variant
  auto： auto是C++11中的关键字，它可以通过类型推导自动得到变量或对象的类型，需要注意的是auto会忽略引用，因为引用其实就代表原对象：
用法1： auto x = 1; 用法2： for(auto &amp;amp;x : arr) decltype: 如果我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量，那么可以使用decltype，需要注意的是如果decltype使用的变量加上一个括号的话那么decltype会返回对应的引用类型：
用法： int func(int i) { return i; } decltype(func(0)) num = 100; //num是int类型，不会调用func()  int i = 100; decltype((i)) d = num; //d是int引用类型，其指向num any： any功能与auto类似，二者不同之处在于：
  auto是一个类似int、double、string的C++关键字，它不是一个类，所以没有成员函数可调用，直接把他当做int、double、string这种关键字来使用。
  any是一个类，只能通过any_cast&amp;lt;&amp;gt;获得any的实际内部值，而不能像auto定义的对象那样直接使用它。
  any也可以用来存储任意类型元素，如int、double、string、vector或自定义类型。它能够存储任意类型的原因是其构造函数和赋值函数opeartor=是模板函数，可以接收任意类型。
  any不是一个模板类，所以定义元素的时候不必使用&amp;lt;&amp;gt;，如any a = 10;</description>
    </item>
    
    <item>
      <title>Boost - 断言</title>
      <link>https://jfy0o0.github.io/2020/boost-%E6%96%AD%E8%A8%80/</link>
      <pubDate>Tue, 10 Nov 2020 18:47:52 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E6%96%AD%E8%A8%80/</guid>
      <description>boost - 断言   标准assert宏的原型声明在&amp;lt;assert.h&amp;gt;中，其作用是如果它的测试条件为假，则调用abort()终止程序执行，程序退出的时候会弹出一个错误提示框，并向控制台输出所在文件及行号。
  assert()只针对debug版本，在Release版本中assert()是无效的。
  使用建议：  每个assert只检验一个条件,因为同时检验多个条件时,如果断言失败,无法直观的判断是哪个条件失败。 比如Object* p = new Object，返回空指针 所以，大的原则可以是这样：内部函数尽量简化容错机制，稍微苛刻一些，而对外接口则尽量容忍，出错处理也要温柔。 断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它。  简易使用： BOOST_ASSERT_MSG(false,&amp;#34;assert msg&amp;#34;); boost - 扩展： boost中的BOOST_ASSERT有两点扩展功能:
 可以通过定义BOOST_DISABLE_ASSERTS使在debug版本中也能停用BOOST_ASSERT()。 可以通过定义BOOST_ENABLE_ASSERT_HANDLER使断言出错的时候调用自定义的函数：  如果定义了 BOOST_ENABLE_ASSERT_HANDLER，  BOOST_ASSERT失败则会调用::boost::assertion_failed()， boost / assert.hpp中只声明了assertion_failed(), 可以自己定义它， 它有4个参数, 分别是出错表达式串, 函数名, 文件名, 行号。   如果未定义BOOST_ENABLE_ASSERT_HANDLER，则会调用标准的assert().    eg： #define BOOST_ENABLE_ASSERT_HANDLER #include &amp;#34;boost/assert.hpp&amp;#34; namespace boost { void assertion_failed(char const * expr, char const * function, char const * file, long line) { //todo  } } int main() { BOOST_ASSERT(false); return 0; } </description>
    </item>
    
    <item>
      <title>Linux Soft - iptables</title>
      <link>https://jfy0o0.github.io/2020/linux-%E8%BD%AF%E4%BB%B6-iptables/</link>
      <pubDate>Tue, 10 Nov 2020 14:18:28 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/linux-%E8%BD%AF%E4%BB%B6-iptables/</guid>
      <description>iptables iptables 是用来设置、维护和检查Linux内核]的IP包过滤规则的。
 可以定义不同的表，每个表都包含几个内部的链，也能包含用户定义的链。 每个链都是一个规则列表，对对应的包进行匹配：每条规则指定应当如何处理与之相匹配的包。 这被称作&amp;rsquo;target&#39;（目标），也可以跳向同一个表内的用户定义的链。  表  filter表：负责过滤功能，防火墙；内核模块：iptables_filter nat表：network address translation，网络地址转换功能；内核模块：iptable_nat mangle表：拆解报文，做出修改，并重新封装 的功能；iptable_mangle raw表：关闭nat表上启用的连接追踪机制；iptable_raw  流程 链的规则存放于哪些表中（从链到表的对应关系）：
  PREROUTING 的规则可以存在于：raw表，mangle表，nat表。
  INPUT 的规则可以存在于：mangle表，filter表，（centos7中还有nat表，centos6中没有）。
  FORWARD 的规则可以存在于：mangle表，filter表。
  OUTPUT 的规则可以存在于：raw表mangle表，nat表，filter表。
  POSTROUTING 的规则可以存在于：mangle表，nat表。
  表中的规则可以被哪些链使用（从表到链的对应关系）：
  raw 表中的规则可以被哪些链使用：PREROUTING，OUTPUT
  mangle 表中的规则可以被哪些链使用：PREROUTING，INPUT，FORWARD，OUTPUT，POSTROUTING
  nat 表中的规则可以被哪些链使用：PREROUTING，OUTPUT，POSTROUTING（centos7中还有INPUT，centos6中没有）
  filter 表中的规则可以被哪些链使用：INPUT，FORWARD，OUTPUT
  处理动作  ACCEPT:允许数据包通过 DROP:直接丢弃数据包 REJECT:拒绝数据包通过 SNAT:源地址转换 MASQUERADE:SNAT的特殊形式，适用于动态的、临时会变的ip上 DNAT:目标地址转发 REDIRECT:在本机做端口映射 LOG:/var/log/messages记录日志信息，将数据包传递给下一条规则，除了记录以外，不操作  命令 iptables -t 表名 -L 查看对应表的所有规则，-t选项指定要操作的表，省略&amp;#34;-t 表名&amp;#34;时，默认表示操作filter表，-L表示列出规则，即查看规则。 iptables -t 表名 -L 链名 查看指定表的指定链中的规则。 iptables -t 表名 -v -L 查看指定表的所有规则，并且显示更详细的信息（更多字段），-v表示verbose，表示详细的，冗长的，当使用-v选项时，会显示出&amp;#34;计数器&amp;#34;的信息，由于上例中使用的选项都是短选项，所以一般简写为iptables -t 表名 -vL iptables -t 表名 -n -L 表示查看表的所有规则，并且在显示规则时，不对规则中的IP或者端口进行名称反解，-n选项表示不解析IP地址。 iptables --line-numbers -t 表名 -L 表示查看表的所有规则，并且显示规则的序号，--line-numbers选项表示显示规则的序号，注意，此选项为长选项，不能与其他短选项合并，不过此选项可以简写为--line，注意，简写后仍然是两条横杠，仍然是长选项。 iptables -t 表名 -v -x -L 表示查看表中的所有规则，并且显示更详细的信息(-v选项)，不过，计数器中的信息显示为精确的计数值，而不是显示为经过可读优化的计数值，-x选项表示显示计数器的精确值。 iptables --line -t filter -nvxL iptables --line -t filter -nvxL INPUT 增删改查 在指定表的指定链的尾部添加一条规则，-A选项表示在对应链的末尾添加规则，省略-t选项时，表示默认操作filter表中的规则 命令语法：iptables -t 表名 -A 链名 匹配条件 -j 动作 示例：iptables -t filter -A INPUT -s 192.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - cmake</title>
      <link>https://jfy0o0.github.io/2020/cpp_cmake/</link>
      <pubDate>Mon, 09 Nov 2020 13:47:22 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_cmake/</guid>
      <description>cmake 1.指定 cmake 的最小版本 cmake_minimum_required(VERSION 3.4.1)这行命令是可选的，我们可以不写这句话，但在有些情况下，如果 CMakeLists.txt 文件中使用了一些高版本 cmake 特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行 cmake。
2.设置项目名称 project(demo)这个命令不是强制性的，但最好都加上。它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。
3.设置编译类型 add_executable(demo demo.cpp) # 生成可执行文件 add_library(common STATIC util.cpp) # 生成静态库 add_library(common SHARED util.cpp) # 生成动态库或共享库 #add_library 默认生成是静态库，通过以上命令生成文件名字， 4.指定编译包含的源文件 4.1 明确指定包含哪些源文件 add_library(demo demo.cpp test.cpp util.cpp)4.2 搜索所有的 cpp 文件 aux_source_directory(dir VAR) 发现一个目录下所有的源代码文件并将列表存储在一个变量中。 aux_source_directory(. SRC_LIST) # 搜索当前目录下的所有.cpp文件 add_library(demo ${SRC_LIST})4.3 自定义搜索规则 file(GLOB SRC_LIST &amp;#34;*.cpp&amp;#34; &amp;#34;protocol/*.cpp&amp;#34;)add_library(demo ${SRC_LIST})#或者 file(GLOB SRC_LIST &amp;#34;*.cpp&amp;#34;)file(GLOB SRC_PROTOCOL_LIST &amp;#34;protocol/*.cpp&amp;#34;)add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})#或者 aux_source_directory(. SRC_LIST)aux_source_directory(protocol SRC_PROTOCOL_LIST)add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})5.</description>
    </item>
    
    <item>
      <title>Linux Soft - rsync</title>
      <link>https://jfy0o0.github.io/2020/linux-%E8%BD%AF%E4%BB%B6-rsync/</link>
      <pubDate>Mon, 09 Nov 2020 11:20:43 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/linux-%E8%BD%AF%E4%BB%B6-rsync/</guid>
      <description>rsync 用处： Rsync（remote synchronize）是一个远程数据同步工具，可通过LAN/WAN快速同步多台主机间的文件，也可以使用 Rsync 同步本地硬盘中的不同目录。
 在使用 rsync 进行远程同步时，可以使用两种方式：  远程 Shell方式（建议使用 ssh，用户验证由 ssh 负责） C/S 方式（即客户连接远程 rsync 服务器，用户验证由 rsync 服务器负责）。   rsync 被称为是一个文件同步的快速方法，主要是因为其在同步文件时会检查文件之间是否有差异，它只同步存在差异或者不存在的文件，但是首次同步时速度依然很慢。  参数： rsync有许多选项： -n: 在不确定命令是否能按意愿执行时，务必要事先测试；-n可以完成此功能； -v: --verbose，详细输出模式 -q: --quiet，静默模式 -c: --checksum，开启校验功能，强制对文件传输进行校验 -r: --recursive，递归复制； -a: --archives，归档，保留文件的原有属性,等同于&amp;#34;-rtopgDl&amp;#34;。 -p: --perms 保留文件的权限 -t: --times 保留文件的时间戳 -l: --links 保留文件的符号链接 -g: --group 保留文件的属组 -o: --owner 保留文件的属主 -D： --devices 保留设备文件 -H, --hard-links 保留硬链结; -S, --sparse 对稀疏文件进行特殊处理以节省DST的 空间; -e ssh: 表示使用ssh协议作承载 -z: 对文件压缩后传输 --progress：显示进度条 --stats: 显示如何执行压缩和传输 --delete：删除那些DST中有而SRC没有的文件，即删除DST中多余的文件； --delete-excluded 同样删除接收端那些被该选项指定排除的文件。 --delete-after 传输结束以后再删除。 --ignore-errors 及时出现IO错误也进行删除。 --max-delete=NUM 最多删除NUM个文件。 --partial 保留那些因故没有完全传输的文件，以是加快随后的再次传输。 --force 强制删除目录，即使不为空。 --numeric-ids 不将数字的用户和组id匹配为用户名和组名。 --timeout=time ip超时时间，单位为秒。 -I, --ignore-times 不跳过那些有同样的时间和长度的文件。 --size-only 当决定是否要备份文件时，仅仅察看文件大小而不考虑文件时间。 --modify-window=NUM 决定文件是否时间相同时使用的时间戳窗口，默认为0。 -T --temp-dir=DIR 在DIR中创建临时文件。 --exclude=PATTERN 指定排除不需要传输的文件模式。 --include=PATTERN 指定不排除而需要传输的文件模式。 --exclude-from=FILE 排除FILE中指定模式的文件。 --include-from=FILE 不排除FILE指定模式匹配的文件。 --version 打印版本信息。 --address 绑定到特定的地址。 --config=FILE 指定其他的配置文件，不使用默认的rsyncd.</description>
    </item>
    
    <item>
      <title>Linux Soft - vsftpd</title>
      <link>https://jfy0o0.github.io/2020/linux-%E8%BD%AF%E4%BB%B6-vsftpd/</link>
      <pubDate>Mon, 09 Nov 2020 11:07:56 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/linux-%E8%BD%AF%E4%BB%B6-vsftpd/</guid>
      <description>vsftpd 服务：  启动ftp命令#service vsftpd start 停止ftp命令#service vsftpd stop 重启ftp命令#service vsftpd restart  配置文件： ftp的配置文件主要有三个，位于**/etc/vsftpd/**目录下，分别是：
 ftpusers 该文件用来指定那些用户不能访问ftp服务器。 user_list 该文件用来指示的默认账户在默认情况下也不能访问ftp  是和vsftpd.conf中的userlist_enable和userlist_deny两个配置项紧密相关的，它可以有效，也可以无效，有效时它可以是一个黑名单，也可以是一个白名单！ 当userlist_enable=YES时，userlist_deny=YES时：user_list是一个黑名单，即：所有出现在名单中的用户都会被拒绝登入； 当userlist_enable=YES时，userlist_deny=NO时：user_list是一个白名单，即：只有出现在名单中的用户才会被准许登入(user_list之外的用户都被拒绝登入)；另外需要特别提醒的是：使用白名单后，匿名用户将无法登入！除非显式在user_list中加入一行：anonymous   vsftpd.conf vsftpd的主配置文件  匿名用户操作：   切换目录cd /etc/vsftpd/
  修改vsftpd.conf文件vi vsftpd.conf
  去掉以下两行前面的’#&amp;lsquo;号
anon_upload_enable=YES anon_mkdir_write_enable=YES   非匿名用户操作： 修改vsftpd默认根目录： 如何修改 vsftpd 的默认根目录 /var/ftp/ 到另一个目录?
  默认配置下，匿名用户登录 vsftpd 服务后的根目录是 /var/ftp/；
  系统用户登录 vsftpd 服务后的根目录是系统用户的家目录。
  若要修改登录 vsftpd 服务后的根目录，只要修改 /etc/vsftpd/vsftpd.conf 文件即可。</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 访问者模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 09 Nov 2020 10:31:19 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>访问者模式： 　访问者模式的官方定义是这样的：
 表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。 官方的东西总是晦涩难懂的，那么我们现在就来拆解一下：  首先&amp;quot;一个作用于某对象结构中的各元素的操作&amp;quot;，提到了三个东西：对象结构、元素、操作。 我们都学习过数据结构，数据结构中大家对数据的访问一般都是直接访问其地址。 在面向对象的设计中，我们一般也是将数据的访问操作放在类的内部，便于访问。 这种设计看似没有什么问题，但当我们想要采用不同方式访问数据或对象结构时就必须要对类进行修改，这样就违反了OCP原则。于是大家会想到将数据结构与操作分离开来，当问们需要添加访问操作的时候直接添加新的类，原来的代码不需要做任何改变，这也是后半句提到的&amp;quot;可以在不改变各元素类的前提下定义作用于这些元素的新操作&amp;quot;。    访问者模式的角色：  Visitor：接口或抽象类，定义了对每个Element访问的行为，它的参数就是被访问的元素，它的方法个数理论上与元素的个数是一样的，因此，访问者模式要求元素的类型要稳定，如果经常添加、移除元素类，必然会导致频繁地修改visitor接口，如果出现这种情况，则说明不适合使用该模式。 ConcreteVisitor：具体的访问者，它需要给出对每一个元素类访问时所产生的具体行为。 Element：元素接口或抽象类，它定义了一个接受访问者的方法（accept），其意思就是说每一个元素都可以被访问者访问。 ConcreteElement：具体的元素类，它提供接受访问的具体实现，而这个具体实现通常情况下是使用访问者提供的访问该元素类的方法。 ObjectStructure：定义当中所提到的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素提供访问者访问。  优点：  各角色职责分离，符合单一职责原则。 具有优秀的扩展性，使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化。 灵活性  缺点：  具体元素对访问者公布细节，违反了迪米特原则。 具体元素变更比较困难。 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。  访问者模式的使用场景：  对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作&amp;quot;污染&amp;quot;这些对象的类，也不希望在增加新操作时修改这些类。　  eg: class Visitor { public: virtual void Visit( Element *element ){}; }; class Element { public: // Methods  virtual void Accept( Visitor *visitor ){}; }; //------------------------------------------------------- class Employee : public Element { public: string name; double income; int vacationDays; public : Employee( string name, double income, int vacationDays ) { this-&amp;gt;name = name; this-&amp;gt;income = income; this-&amp;gt;vacationDays = vacationDays; } void Accept( Visitor *visitor ) { visitor-&amp;gt;Visit( this ); } }; class IncomeVisitor : public Visitor { public: void Visit( Element *element ) { Employee *employee = ((Employee*)element); employee-&amp;gt;income *= 1.</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 迭代器模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 09 Nov 2020 09:18:29 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>迭代器模式: 　迭代器模式允许你访问一个数据项序列中的所有元素，而无须关心序列是什么类型（数组、链表、列表或任何其他类型）。它能有效地构建一个数据管道，经过一系列不同的转换或过滤后再从管道的另一端出来。迭代器模式就是提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示。
迭代器模式的角色：  抽象迭代器（Iterator）：接口声明了遍历集合所需的操作（获取下一个元素、获取当前位置和重新开始迭代等）。 具体迭代器（ConcreteIterator）：实现遍历集合的一种特定算法。迭代器对象必须跟踪自身遍历的进度。这使得多个迭代器可以相互独立地遍历同一个集合。 抽象聚合（Aggregate）：接口声明一个或多个方法来获取与集合兼容的迭代器。返回方法的类型必须被声明为迭代器接口。 具体聚合（ConcreteAggregate）：会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 客户端（Client）：通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。  迭代器模式适用性：  当集合背后为复杂的数据结构，且你希望对客户端隐藏其复杂性时（出于使用便利性或安全性的考虑），可以使用迭代器。 可以减少程序中重复的遍历代码。 如果你希望代码能够遍历不同的甚至是无法预知的数据结构，可以使用迭代器。  优点：  它支持以不同的方式遍历一个聚合对象。 迭代器简化了聚合类。 在同一个聚合上可以有多个遍历。 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。符合OCP原则。  缺点： 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
eg: class Iterator { public: Iterator(){} virtual ~Iterator(){}; virtual string First() = 0; virtual string Next() = 0; virtual string GetCur() = 0; virtual bool IsEnd() = 0; }; class Aggregate { public: virtual int Count() = 0; virtual void Push(const string &amp;amp;strValue) = 0; virtual string POp(const int cnt) = 0; virtual Iterator* CreateIterator() = 0; }; //----------------------------------------------------- class ConcreteIterator : public Iterator { public: ConcreteIterator(Aggregate *p_aggregate):m_aggregate(p_aggregate),m_cnt(0){} string First() { return m_aggregate-&amp;gt;POp(0); } string Next() { string str; m_cnt++; if (m_cnt &amp;lt; m_aggregate-&amp;gt;Count()) { str = m_aggregate-&amp;gt;POp(m_cnt); } return str; } string GetCur() { return m_aggregate-&amp;gt;POp(m_cnt); } bool IsEnd() { return m_cnt &amp;gt;= m_aggregate-&amp;gt;Count() ?</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 中介者模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:54:05 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>中介者模式： 　在现实生活中，有很多中介者模式的身影，例如QQ游戏平台，聊天室、QQ群、短信平台和房产中介。不论是QQ游戏还是QQ群，它们都是充当一个中间平台，QQ用户可以登录这个中间平台与其他QQ用户进行交流，如果没有这些中间平台，我们如果想与朋友进行聊天的话，可能就需要当面才可以了。电话、短信也同样是一个中间平台，有了这个中间平台，每个用户都不要直接依赖与其他用户，只需要依赖这个中间平台就可以了，一切操作都由中间平台去分发。中介者模式，定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。
中介者模式的角色：  抽象中介者（Mediator）：定义了同事对象到中介者对象的接口。 具体中介者（ConcreteMediator）：实现抽象类的方法，它需要知道具体的同事类并从具体同事类接受消息，向具体同事对象发出命令。 抽象同事类（Colleague）：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。 具体同事类（ConcreteColleague）：每个具体同事类只知道自己的行为，而不了解其他同事类的情况，但它们认识中介者对象。  优点：  简化了对象之间的关系，将系统的各个对象之间的相互关系进行封装，将各个同事类解耦，使得系统变为松耦合。 提供系统的灵活性，使得各个同事对象独立而易于复用。  缺点：  中介者模式中，中介者角色承担了较多的责任，所以一旦这个中介者对象出现了问题，整个系统将会受到重大的影响。 新增加一个同事类时，不得不去修改抽象中介者类和具体中介者类，此时可以使用观察者模式和状态模式来解决这个问题。  中介者使用的场景：  一组定义良好的对象，现在要进行复杂的相互通信。 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。  区别： 与观察者模式区别： 中介者模式主要是起到一个协调的作用，它知道所有的同事类且同事类含有中介者对象，即我有事通知你，你帮我协调一下。而观察者模式侧重在当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态。
eg: //抽象同事类 class Colleague { protected : Mediator *mediator; public: Colleague(Mediator* m) { mediator = m; } virtual void Sent(string message) = 0; }; //具体同事类 class ConcreteColleague1 :public Colleague { public: ConcreteColleague1(Mediator* m) : Colleague(m) {} void Sent(string message) { mediator-&amp;gt;Send(message, this); } void Notify(string message) { cout &amp;lt;&amp;lt; &amp;#34;同事1得到消息：&amp;#34; &amp;lt;&amp;lt; message &amp;lt;&amp;lt; endl; } }; class ConcreteColleague2 :public Colleague { public: ConcreteColleague2(Mediator* m) : Colleague(m) {} void Sent(string message) { mediator-&amp;gt;Send(message, this); } void Notify(string message) { cout &amp;lt;&amp;lt; &amp;#34;同事2得到消息：&amp;#34; &amp;lt;&amp;lt; message &amp;lt;&amp;lt; endl; } }; //----------------------------------------------------- //抽象中介者类 class Mediator { public: virtual void Send(string message, Colleague *colleague) = 0; }; //具体中介者类 class Concretemediator :public Mediator { private: ConcreteColleague1* colleague1; ConcreteColleague2* colleague2; public: void SetColleague1(Colleague* pColleague){ colleague1 = dynamic_cast&amp;lt;ConcreteColleague1*&amp;gt;(pColleague); } void SetColleague2(Colleague * pColleague){ colleague2 = dynamic_cast&amp;lt;ConcreteColleague2*&amp;gt;(pColleague); } void Send(string message, Colleague* colleague){ if (colleague == colleague1) colleague2-&amp;gt;Notify(message); else if (colleague == colleague2) colleague1-&amp;gt;Notify(message); } }; //----------------------------------------------------- //use 	Concretemediator* mediator = new Concretemediator(); ConcreteColleague1* colleague1 = new ConcreteColleague1(mediator);	//让他俩认识一下中介 	ConcreteColleague2* colleague2 = new ConcreteColleague2(mediator); mediator-&amp;gt;SetColleague1(colleague1);	//让中介认识一下他俩 	mediator-&amp;gt;SetColleague2(colleague2); colleague1-&amp;gt;Sent(&amp;#34;有男朋友没？&amp;#34;); colleague2-&amp;gt;Sent(&amp;#34;有了&amp;#34;); </description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 备忘录模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:47:53 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>备忘录模式： 　后悔药来啦！！！备忘录模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便在需要时能将该对象恢复到原先保存的状态。
备忘录模式的角色：  发起人（Originator）：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。 备忘录（Memento）：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。 管理者（CareTaker）：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。  优点：  给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 实现了信息的封装，使得用户不需要关心状态的保存细节。  缺点： 消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。
备忘录模式的应用场景：  　需要保存/恢复数据的相关状态场景。 　提供一个可回滚的操作。  class STMemento { private: int iVitality; public: STMemento(){} STMemento(int iVitality) { this-&amp;gt;iVitality = iVitality; } int GetVitality() const { return this-&amp;gt;iVitality; } }; //------------------------------------------------------- class STOriginator { private: int iVitality; string name; public: STOriginator(string strName, int iVit): iVitality(iVit), name(strName) { } STMemento* SaveState() { return new STMemento(iVitality); } void RecoverState(const STMemento* stMemento) { this-&amp;gt;iVitality = stMemento-&amp;gt;GetVitality(); } void SetVitality(int iVit) { this-&amp;gt;iVitality = iVit; } void Show() { cout&amp;lt;&amp;lt; &amp;#34;Name: &amp;#34;&amp;lt;&amp;lt; name&amp;lt;&amp;lt; endl; cout&amp;lt;&amp;lt; &amp;#34;Live: &amp;#34;&amp;lt;&amp;lt; iVitality&amp;lt;&amp;lt; endl; } }; //------------------------------------------------------- class STCareTaker { private: vector&amp;lt;STMemento*&amp;gt; vecStMemento; public: void AddMemento(STMemento* stMemento) { vecStMemento.</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 解释器模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:43:06 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>解释器模式： 　从名称上来看看这个模式，个人的最初理解“解释器”和Google的中英翻译功能类似。如果有一天你去国外旅游去了，比如去美国吧，美国人是讲英语的，我们是讲汉语的，如果英语听不懂，讲不好，估计沟通就完蛋了，不能沟通，估计玩的就很难尽兴了，因为有很多景点的解说你可能不明白（没有中文翻译的情况下，一般情况会有的）。所以我们需要一个软件，可以把中英文互译，那彼此就可以更好的理解对方的意思，我感觉翻译软件也可以称得上是解释器，把你不懂的解释成你能理解的。我们写代码，需要编译器把我们写的代码编译成机器可以理解的机器语言，从这方面来讲，C#的编译器也是一种解释器。
解释器模式的角色：  抽象解释器（AbstractExpression）：定义解释器的接口，约定解释器的解释操作。其中的Interpret接口，正如其名字那样，它是专门用来解释该解释器所要实现的功能。 终结符表达式（TermialExpression）：实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。 非终结符表达式（NonterminalExpression）：文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，“+”就是非终结符，解析“+”的解释器就是一个非终结符表达式。 环境角色（Context）：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。  优点：  易于改变和扩展文法。 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。  缺点：  对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。  解释器模式的应用场景：  当一个语言需要解释执行，并可以将该语言中的句子表示为一个抽象语法树的时候，可以考虑使用解释器模式（如XML文档解释、正则表达式等领域）。 一些重复出现的问题可以用一种简单的语言来进行表达。 一个语言的文法较为简单. 当执行效率不是关键和主要关心的问题时可考虑解释器模式（注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。）  eg: class Context { private: map&amp;lt;string,int&amp;gt; valueMap; public: void addValue(string key,int value) { valueMap.insert(std::pair&amp;lt;string,int&amp;gt;(key,value)); } int getValue(string key) { return valueMap[key]; } }; //-------------------------------------------------- class AbstractExpression { public : virtual int interpreter(Context context) = 0; }; class AddNonterminalExpression:public AbstractExpression { private : AbstractExpression *left; AbstractExpression *right; public: AddNonterminalExpression(AbstractExpression *left, AbstractExpression *right) { this-&amp;gt;left = left; this-&amp;gt;right = right; } int interpreter(Context context) { return this-&amp;gt;left-&amp;gt;interpreter(context) + this-&amp;gt;right-&amp;gt;interpreter(context); } }; class SubtractNonterminalExpression:public AbstractExpression { private : AbstractExpression *left; AbstractExpression *right; public: SubtractNonterminalExpression(AbstractExpression *left, AbstractExpression *right) { this-&amp;gt;left = left; this-&amp;gt;right = right; } int interpreter(Context context) { return this-&amp;gt;left-&amp;gt;interpreter(context) - this-&amp;gt;right-&amp;gt;interpreter(context); } }; class TerminalExpression :public AbstractExpression { private: int i; public: TerminalExpression(int i) { this-&amp;gt;i = i; } int interpreter(Context context) { return this-&amp;gt;i; } }; //-------------------------------------------------- //use  //a-b+c  cout&amp;lt;&amp;lt;&amp;#34;解释器模式:a-b+c&amp;#34;&amp;lt;&amp;lt;endl; Context context; context.</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 命令模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:36:09 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>命令模式： 　将请求封装成对象，以便使用不同的请求、日志、队列等来参数化其他对象。命令模式也支持撤销操作。
命令模式的角色：  传递命令对象（Invoker）：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。 抽象命令接口（Command）：声明执行命令的接口，拥有执行命令的抽象方法execute()。 具体的命令对象（ConcreteCommand）：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。 接受者对象（Receiver）：执行命令功能的相关操作，是具体命令对象业务的真正实现者。 客户端对象（Client）：创建具体命令的对象并且设置命令对象的接受者。  优点：  　降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。 　增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足OCP原则，对扩展比较灵活。 　可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 　方便实现 Undo 和 Redo 操作。命令模式可以与备忘录模式结合，实现命令的撤销与恢复。  缺点： 可能产生大量的具体命令类。
适用环境：  使用命令模式作为“CallBack”在面向对象系统中的替代。“CallBack”讲的便是先将一个函数登记上，然后在以后调用此函数。 需要在不同的时间指定请求、将请求排队。一个命令对象和原先的请求发出者可以有不同的生命期。换言之，原先的请求发出者可能已经不在了，而命令对象本身仍然是活动的。这时命令的接收者可以是在本地，也可以在网络的另外一个地址。命令对象可以在串形化之后传送到另外一台机器上去。 系统需要支持命令的撤消(undo)。命令对象可以把状态存储起来，等到客户端需要撤销命令所产生的效果时，可以调用undo()方法，把命令所产生的效果撤销掉。命令对象还可以提供redo()方法，以供客户端在需要时，再重新实施命令效果。 如果一个系统要将系统中所有的数据更新到日志里，以便在系统崩溃时，可以根据日志里读回所有的数据更新命令，重新调用Execute()方法一条一条执行这些命令，从而恢复系统在崩溃前所做的数据更新。  区别： 命令模式与策略模式的区别：  命令模式与策略模式都封装了变化，但命令模式封装的是请求的变化，而策略模式封装的是算法的变化。 命令模式可以抽象化成策略模式。策略模式较简单，而命令模式比较复杂。策略模式聚焦的是对相同请求更换解决方案的灵活性；而命令模式聚焦的是对多请求变化的封装以及对相同请求不同的请求形式解决方法的可复用性。  eg： class Barbecuer { public: void BakeMutton(){cout&amp;lt;&amp;lt;&amp;#34;Bake mutton&amp;#34;&amp;lt;&amp;lt;endl;} void BakeChickenWing(){cout&amp;lt;&amp;lt;&amp;#34;Bake ChickenWing&amp;#34;&amp;lt;&amp;lt;endl;} }; //----------------------------------------------  /*抽象命令类：是执行具体操作的接口*/ class Command { public: Command(){} Command(Barbecuer *receiver):p_receiver(receiver){} virtual void ExecuteCommand() = 0; //执行命令  protected: Barbecuer *p_receiver; }; /*具体命令类:烤羊肉串命令*/ class BakeMuttonCommand:public Command { public: BakeMuttonCommand(Barbecuer *receiver){p_receiver = receiver;} void ExecuteCommand(){p_receiver-&amp;gt;BakeMutton();} }; /*具体命令类:烤鸡翅串命令*/ class BakeChickenWingCommand:public Command { public: BakeChickenWingCommand(Barbecuer *receiver){p_receiver = receiver;} void ExecuteCommand() {p_receiver-&amp;gt;BakeChickenWing();} }; //----------------------------------------------  /*服务员类*/ class Waiter { public: void SetOrder(Command *command) { p_commandList.</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 状态模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:30:26 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
      <description>状态模式： 　在软件开发过程中，应用程序可能会根据不同的情况作出不同的处理。最直接的解决方案是将这些所有可能发生的情况全都考虑到，然后使用if else语句来做状态判断来进行不同情况的处理。但对复杂状态的判断就显得&amp;quot;力不从心了&amp;quot;，随着增加新的状态或者修改一个状体if else(或switch case)语句的增多或者修改）可能会引起很大的修改，违反OCP原则。状态模式就是在当控制一个对象状态转换的条件表达式过于复杂时，把相关&amp;quot;判断逻辑&amp;quot;提取出来，放到一系列的状态类当中，这样可以把原来复杂的逻辑判断简单化。
状态模式的角色：　  环境类（Context）：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。 抽象状态类（AbstractState）：定义一个接口以封装与Context的一个特定状态相关的行为。 具体状态类（ConcreteState）：实现抽象状态所对应的行为。  优点：  状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足”单一职责原则”。 减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。 有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。  缺点：  状态模式的使用必然会增加系统的类与对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。  状态模式的应用场景：  当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。 一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态。  区别： 状态模式与策略模式的区别： 　从UML图上我们会发现这两种设计模式几乎一摸一样，都是利用多态把一些操作分配到一组相关的简单的类中。然而在显示世界中，策略模式和状态模式是两种完全不同的思想。对状态进行建模时，状态迁移是一个核心问题；但策略模式与迁移毫无关系，策略模式允许一个客户选择或提供一种策略。
状态模式与责任链模式的区别： 　职责链模式和状态模式都可以解决if分支过多的问题，从定义来看，状态模式是一个对象内在状态发生改变（一个对象，相对稳定，处理完一个对象下一个对象一般已确定），而职责链模式是多个对象之间的改变（多个对象之间的话，就会出现某个对象不存在的问题，且该模式由客户端指定，不稳定），这也说明了这两个模式处理的情况不同。
eg： class State { public: virtual void Handle(Context *pContext) = 0; }; //------------------------------------------- class ConcreteStateA : public State { public: virtual void Handle(Context *pContext) { cout&amp;lt;&amp;lt;&amp;#34;I am concretestateA.&amp;#34;&amp;lt;&amp;lt;endl; } }; class ConcreteStateB : public State { public: virtual void Handle(Context *pContext) { cout&amp;lt;&amp;lt;&amp;#34;I am concretestateB.</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 观察者模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:22:11 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>观察者模式： 　指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
观察者模式的角色：  抽象目标（Subject）：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。 具体目标（ConcreteSubject）：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。 抽象观察者（Observer）：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。 具体观察者（ConcreteObserver）：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。  观察者模式的应用场景：  对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。  优点： 观察者和被观察者是抽象耦合的；建立的一套触发机制。
缺点：  如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。  eg： class Observer { public: Observer(); virtual ~Observer(); virtual void Update()=0; }; //--------------------------------------------- class ConcreteObserver :public Observer{ public: ConcreteObserver(ConcreteSubject *sub,string name){ pSubject = sub; mName = name; } void Update(){ mObserverState = pSubject-&amp;gt;mSubjectState; cout &amp;lt;&amp;lt; &amp;#34;观察者&amp;#34; &amp;lt;&amp;lt; mName &amp;lt;&amp;lt; &amp;#34; 状态&amp;#34; &amp;lt;&amp;lt;mObserverState&amp;lt;&amp;lt;endl; } virtual ~ConcreteObserver(); ConcreteSubject* getSubject() { return pSubject; } void setSubject( ConcreteSubject* subject) { pSubject = subject; } private: string mName; string mObserverState; ConcreteSubject *pSubject; }; //--------------------------------------------- class Subject { public: Subject(); virtual ~Subject(); void Attach(Observer* p){ observers.</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 职责链模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:17:54 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid>
      <description>职责链模式： 　在现实生活中，常常会出现这样的事例：一个请求需要多个对象处理，但每个对象的处理条件或权限不同。如公司员工报销差旅费，可审批的领导有部分负责人、副总经理、总经理等，但每个领导能审批的金额是不同的，不同的金额需要找相应的领导审批，也就是说要报销必须先搞清楚需要谁来审批。职责链模式就是为了解决这样的问题产生的。
　职责链模式，又叫责任链模式。是为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一个对象记住其下一个对象的引用而连成一条链。当发生请求时，可将请求沿着这条链传递，直到有对象处理它为止。
职责链模式的角色：  抽象处理者（Handler）：声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法 具体处理者（ConcreteHandler）：包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。 请求信息（Request）：定义请求的信息。 客户端（Client）：可根据程序逻辑一次性或者动态地生成链。值得注意的是，请求可发送给链上的任意一个处理者，而非必须是第一个处理者。  优点：  请求者和接收者松耦合。在职责链模式中，请求者并不知道接收者是谁，也不知道具体如何处理，请求者只是负责向职责链发送请求就可以了。而每个职责对象也不用管请求者或者是其他的职责对象，只负责处理自己的部分，其他的就交给其他的职责对象去处理。也就是说，请求者和接受者是完全解耦的。 动态组合职责。职责链模式会把功能处理分散到单独的职责对象中，然后再使用的时候，可以动态组合职责形成职责链，从而可以灵活地给对象分配职责，也可以灵活地实现和改变对象的职责。 减少代码中的if..else..判断，优化代码。  缺点：  产生很多细粒度对象。职责链模式会把功能处理分散到单独的职责对象中，也就是每个职责对象只处理一个方面的功能，要把整个业务处理完，需要很多职责对象的组合，这样会产生大量的细粒度职责对象。 不一定能被处理。职责链模式的每个职责对象只负责自己处理的那一部分，因此可能会出现某个请求把整个链传递完了都没有职责对象处理它。这就需要使用职责链模式的时候，需要提供默认的处理，并且注意构造的链的有效性。 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能由于职责链的错误设置而导致系统出错，如可能会造成循环调用。  职责链的应用场景：  有多个对象可以处理一个请求，哪个对象处理该请求由运行时刻自动确定。 可动态指定一组对象处理请求，或添加新的处理者 在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。  eg： class Manager { protected: Manager *m_manager; string m_name; public: Manager(Manager* manager,string name):m_manager(manager),m_name(name){} virtual void DealWithRequest(string name, int num) {} }; //-------------------------------------------------- class CommonManager : public Manager { public: CommonManager(Manager* manager,string name):Manager(manager,name){} void DealWithRequest(string name,int num) { if(num &amp;lt; 500) { cout &amp;lt;&amp;lt; &amp;#34;经理&amp;#34; &amp;lt;&amp;lt;m_name &amp;lt;&amp;lt; &amp;#34;批准&amp;#34; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34;加薪&amp;#34; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;#34;元&amp;#34; &amp;lt;&amp;lt;endl; } else { cout &amp;lt;&amp;lt; &amp;#34;经理&amp;#34; &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;#34;无法处理,交由总监处理&amp;#34; &amp;lt;&amp;lt;endl; m_manager-&amp;gt;DealWithRequest(name,num); } } }; class Majordomo:public Manager { public: Majordomo(Manager *manager,string name):Manager(manager,name){} virtual void DealWithRequest(string name,int num) { if(num &amp;lt; 1000) { cout &amp;lt;&amp;lt; &amp;#34;总监&amp;#34; &amp;lt;&amp;lt;m_name &amp;lt;&amp;lt; &amp;#34;批准&amp;#34; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34;加薪&amp;#34; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;#34;元&amp;#34; &amp;lt;&amp;lt;endl; } else { cout &amp;lt;&amp;lt; &amp;#34;总监&amp;#34; &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;#34;无法处理,交由总经理处理&amp;#34; &amp;lt;&amp;lt;endl; m_manager-&amp;gt;DealWithRequest(name,num); } } }; class GeneralManager : public Manager { public: GeneralManager(Manager *manager,string name):Manager(manager,name){} void DealWithRequest(string name,int num) { cout &amp;lt;&amp;lt; &amp;#34;总经理&amp;#34; &amp;lt;&amp;lt;m_name &amp;lt;&amp;lt; &amp;#34;批准&amp;#34; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34;加薪&amp;#34; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;#34;元&amp;#34; &amp;lt;&amp;lt;endl; } }; //-------------------------------------------------- //use  Manager *general = new GeneralManager(NULL,&amp;#34;a&amp;#34;); Manager *majordomo = new Majordomo(general,&amp;#34;b&amp;#34;); Manager *common = new CommonManager(majordomo,&amp;#34;c&amp;#34;); common-&amp;gt;DealWithRequest(&amp;#34;d&amp;#34;,400); common-&amp;gt;DealWithRequest(&amp;#34;d&amp;#34;,700); common-&amp;gt;DealWithRequest(&amp;#34;d&amp;#34;,1200); </description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 模板模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:13:59 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</guid>
      <description>模板模式: 　提到模板，可能大多数人想到的是&amp;quot;简历模板&amp;quot;、&amp;ldquo;论文模板&amp;quot;等，比如我们要写简历时，会从网上下载一份漂亮的简历模板，其格式是固定的，我们根据自己的情况填充不同的内容。模板模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
模板模式的角色：  模板方法（AbstractClass）：定义了一个或多个抽象操作，以便让子类实现，这些抽象操作称为基本操作； 模板方法的具体实现（ConcreteClass）：实现父类所定义的一个或多个抽象方法。  优点：  封装不变部分，扩展可变部分，符合OCP原则； 提取公共代码，便于维护； 行为由父类控制，子类实现。  缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。
eg： class AbstractClass { public: AbstractClass(); virtual ~AbstractClass(); virtual void PrimitiveOperation1() = 0; virtual void PrimitiveOperation2() = 0; void TemplateMethod(){ PrimitiveOperation1(); PrimitiveOperation2(); } }; //------------------------------------- class ConcreteClassA : public AbstractClass{ public: ConcreteClassA(); virtual ~ConcreteClassA(); void PrimitiveOperation1(){ cout&amp;lt;&amp;lt;&amp;#34;ConcreteClassA PrimitiveOperation1&amp;#34;&amp;lt;&amp;lt;endl; } void PrimitiveOperation2(){ cout&amp;lt;&amp;lt;&amp;#34;ConcreteClassA PrimitiveOperation2&amp;#34;&amp;lt;&amp;lt;endl; } }; class ConcreteClassB : public AbstractClass{ public: ConcreteClassB(); virtual ~ConcreteClassB(); void PrimitiveOperation1(){ cout&amp;lt;&amp;lt;&amp;#34;ConcreteClassB PrimitiveOperation1&amp;#34;&amp;lt;&amp;lt;endl; } void PrimitiveOperation2(){ cout&amp;lt;&amp;lt;&amp;#34;ConcreteClassB PrimitiveOperation2&amp;#34;&amp;lt;&amp;lt;endl; } }; //------------------------------------- //use 	AbstractClass * p = new ConcreteClassA(); p-&amp;gt;TemplateMethod(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 策略模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:06:29 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>策略模式： 　策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。
策略模式的角色：　  环境类（Context）：采用组合或聚合的方式维护一个对Strategy对象的引用。 抽象策略类（Strategy）：定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。 具体策略类（ConcreteStrategy）：实现Strategy接口。  优点：  策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。 策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。继承使得动态改变算法或行为变得不可能。 使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。  缺点：  客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。 策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。  策略模式的应用场景：  一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。  区别： 策略模式与工厂模式的区别？ 　从结构上看，策略模式和工厂模式都是子类继承抽象父类，通过传入参数到容器类（工厂模式的factory类，策略模式的Content类），选择对应的类进行行为操作。但是我们都知道工厂模式是创建型设计模式，而策略模式则是行为型设计模式。那两者到底有什么区别呢？
 工厂模式是用来创建对象，策略模式是让一个对象在许多行为中选择一种行为。 关注点不一样，一个关注对象的创建，一个关注的是行为封装。 解决不同的问题：工厂模式是创建型的设计模式，它接受指令，创建出符合要求的实例；它主要解决的是资源的统一分发，将对象的创建完全独立出来，让对象的创建和具体的使用客户无关。主要应用在多数据库选择，类库文件加载等。策略模式是为了解决的是策略的切换与扩展，更简洁的说是定义策略族，分别封装起来，让他们之间可以相互替换，策略模式让策略的变化独立于使用策略的客户。 工厂相当于黑盒子，策略相当于白盒子。  策略模式与桥接模式的区别？ 　在桥接模式中，Abstraction通过聚合的方式引用Implementor。策略模式中，Context也使用聚合的方式引用Strategy抽象接口。从两者的结构图可以看出，在这两种模式中，都存在一个对象使用聚合的方式引用另一个对象的抽象接口的情况，而且该抽象接口的实现可以有多种并且可以替换。可以说两者在表象上都是调用者与被调用者之间的解耦，以及抽象接口与实现的分离。但两者存在一定的区别：
 在形式上，在桥接模式中不仅Implementor具有变化（ConcreateImplementior），而且Abstraction也可以发生变化（RefinedAbstraction），而且两者的变化是完全独立的，RefinedAbstraction与ConcreateImplementior之间松散耦合，它们仅仅通过Abstraction与Implementor之间的关系联系起来。而在策略模式中，并不考虑Context的变化，只有算法的可替代性。 在语意上，桥接模式强调Implementor接口仅提供基本操作，而Abstraction则基于这些基本操作定义更高层次的操作。而策略模式强调Strategy抽象接口的提供的是一种算法，一般是无状态、无数据的，而Context则简单调用这些算法完成其操作。 桥接模式中不仅定义Implementor的接口而且定义Abstraction的接口，Abstraction的接口不仅仅是为了与Implementor通信而存在的，这也反映了结构型模式的特点：通过继承、聚合的方式组合类和对象以形成更大的结构。在策略模式中，Startegy和Context的接口都是两者之间的协作接口，并不涉及到其它的功能接口，所以它是行为模式的一种。行为模式的主要特点就是处理的是对象之间的通信方式，往往是通过引入中介者对象将通信双方解耦，在这里实际上就是将Context与实际的算法提供者解耦。 所以相对策略模式，桥接模式要表达的内容要更多，结构也更加复杂。桥接模式表达的主要意义其实是接口隔离的原则，即把本质上并不内聚的两种体系区别开来，使得它们可以松散的组合，而策略在解耦上还仅仅是某一个算法的层次，没有到体系这一层次。从结构图中可以看到，策略的结构是包容在桥接结构中的，桥接中必然存在着策略模式，Abstraction与Implementor之间就可以认为是策略模式，但是桥接模式一般Implementor将提供一系列的成体系的操作，而且Implementor是具有状态和数据的静态结构。而且桥接模式Abstraction也可以独立变化。  eg： class AbstractPay { public: virtual void pay() = 0; }; class CashPay :public AbstractPay { public: void pay() { cout &amp;lt;&amp;lt; &amp;#34;现金支付&amp;#34; &amp;lt;&amp;lt; endl; } }; class CreditcardPay :public AbstractPay { public: void pay() { cout &amp;lt;&amp;lt; &amp;#34;信用卡支付&amp;#34; &amp;lt;&amp;lt; endl; } }; //---------------------------------- class Context { private: AbstractPay* strategyPay; public: Context(AbstractPay* strategy){ this-&amp;gt;strategyPay = strategy; } void ContextPay(){ strategy-&amp;gt;Pay(); } }; //---------------------------------- //use  Context* context1; AbstractPay *basePay1 = new CashPay(); context1 = new Context(basePay1); context1-&amp;gt;ContextInterface(); Context* context2; AbstractPay *basePay2 = new CreditcardPay(); context2 = new Context(basePay2); context2-&amp;gt;ContextInterface(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 结构型模式 - 组合模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:01:11 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>组合模式： 定义： 　组合模式又叫部分整体模式，它是一种将对象组合成树状的层次结构模式，用来表示&amp;quot;部分-整体&amp;quot;的关系，使用户对单个对象和组合对象具有一致的访问性。
组合模式的角色：  抽象构建（Component）：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。 树叶构件（Leaf）：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。 树枝构件（Composite）：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。  优点：  组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的单个对象还是组合对象，这简化了客户端代码； 更容易在组合体内加入新的对象，客户端不会因为加入新的对象而更改源代码，满足OCP原则。  缺点：  设计较复杂，客户端需要花更多的时间理清类之间的层次关系； 不容易限制容器中的构件； 不容易用继承的方法来增加构件的新功能。  eg: class ComponentPtr { protected: std::string m_strName; public: ComponentPtr(std::string str) { m_strName = str; } virtual void add(ComponentPtr * p) = 0; virtual void remove(ComponentPtr * p) = 0; virtual void display() = 0; }; //----------------------------------------------- class LeafPtr : public ComponentPtr { public: LeafPtr(std::string str) : ComponentPtr(str) {} void add(ComponentPtr * p) { std::cout &amp;lt;&amp;lt; &amp;#34;Leaf cannot add&amp;#34; &amp;lt;&amp;lt; std::endl; } void remove(ComponentPtr * p) { std::cout &amp;lt;&amp;lt; &amp;#34;Leaf cannot remove&amp;#34; &amp;lt;&amp;lt; std::endl; } void display() { std::cout &amp;lt;&amp;lt; m_strName &amp;lt;&amp;lt; std::endl; } }; class CompositePtr : public ComponentPtr { private: // 这里使用智能指针不用自己释放new的内存 	std::vector&amp;lt;std::shared_ptr&amp;lt;ComponentPtr&amp;gt;&amp;gt; m_vec; public: CompositePtr(std::string str) : ComponentPtr(str) {}; ~CompositePtr() { if (!</description>
    </item>
    
    <item>
      <title>Design Patterns - 结构型模式 - 享元模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:52:09 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description>享元模式： 定义： 　运用共享技术有效地支持大量细粒度对象的复用。享元模式可以避免大量相似类的开销，在软件开发中如果需要生成大量细粒度的类实例，而这些类实例除了几个参数外基本上相同，那么这时就可以使用享元模式大幅度减少实例化类的数量。如果能把这些参数移动到实例外，在方法调用时将他们传递进去，这样就可以通过共享大幅度减少单个实例的数目。这里我们把移动到类实例外部的参数称为享元对象的外部状态，把在享元对象内部定义称为内部状态。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，他是一种结构型设计模式。
状态： 享元模式结构较为复杂，一般结合工厂模式一起使用。
 外部状态：随环境改变而改变的，不可以共享的状态。 内部状态：在享元对象内部并且不会随着环境的变化而改变的共享部分。  享元模式的角色：  抽象享元类（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。 具体享元类（ConcreteFlyweight）：它实现了抽象享元类，其实例称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。 非共享具体享元类（UnsharedConcreteFlyweight）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。 享元工厂类（FlyweightFactory）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计；当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在的话），返回新创建的实例并将其存储在享元池中。  优点： 降低系统中的对象的数量，从而降低了系统中细粒度对象给内存带来的压力。
缺点：  为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑更复杂，使系统复杂化。 享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。  区别： 享元模式与原型模式的区别：  享元模式是结构型设计模式，而原型模式是创建型设计模式。 原型模式关注的是类的重复创建问题，而享元模式关注的是对象的创建问题。 原型模式创建的对象属性完全一样，而享元模式会根据不同的外部状态创建不一样的对象实例。  享元模式与单例模式的区别： 通过搜索我发现有许多关于享元模式与单例模式的区别，现总结如下：
 享元设计模式是一个类有很多对象，而单例是一个类仅一个对象。 享元模式是为了节约内存空间，提升程序性能（避免大量的new操作），而单例模式则主要是出于共享状态的目的。  eg: class Flyweight { public: virtual void Operation(int n) = 0; }; class ConcreteFlyweight_0 : public Flyweight { public: void Operation(int n) { std::cout &amp;lt;&amp;lt; &amp;#34;ConcreteFlyweight_0:&amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl; } }; class ConcreteFlyweight_1 : public Flyweight { public: void Operation(int n) { std::cout &amp;lt;&amp;lt; &amp;#34;ConcreteFlyweight_1:&amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl; } }; class ConcreteFlyweight_2 : public Flyweight { public: void Operation(int n) { std::cout &amp;lt;&amp;lt; &amp;#34;ConcreteFlyweight_2:&amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl; } }; //---------------------------------------------- // 享元工厂 class FlyweightFactory { private: std::map&amp;lt;int, Flyweight *&amp;gt; m_map; public: FlyweightFactory() { m_map.</description>
    </item>
    
    <item>
      <title>Design Patterns - 结构型模式 - 桥接模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:46:17 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>桥接模式： 　桥接是用于把抽象化与实现化解耦，使得两者可以独立变化。
桥接模式的角色：  抽象化角色（Abstraction）：它是用于定义抽象接口，通常是抽象类而不是接口，其中定义了一个Implementor(实现接口)类型的对象并可以维护该对象，它与Implementor之间具有关联关系。 改善后的抽象化角色（RefinedAbstraction）：通常是具体类，实现了Abstraction中的抽象方法，在RefinedAbstraction中可以调用Implementor中定义的方法。 实现者角色（Implementor）：通常情况下提供一些基本操作的声明，将具体实现交给其子类。 具体的实现者角色（ConcreteImplementorA、ConcreteImplementorB）：实现了Implementor种定义的方法，运行时根据里氏替换原则，ConcreteImplementor对象将替换其父类对象，提供给抽象对象类具体的业务操作方法。  为什么使用桥接模式？ 　我们都知道遥控器的通用功能是开机、关机，早先我们的做法应该是这样的：创建一个抽象遥控器类，里面定义开机、关机的一组方法，然后创建具体的遥控器类去继承或实现这个接口，这样就可以满足每个电视机的需求。但突然有一天，客户觉得这个遥控器的功能太少了，需要增加一个返回按钮，这个时候你傻眼了，你给抽象类添加了一个新方法，突然发现程序大面积报错，原因是子类未实现父类方法，于是霹雳巴拉一通改。好不容易改好了，客户又说了：想要一个菜单功能，于是&amp;hellip;.
　从上面的例子看出，这种设计违背了OCP原则，原因是类与类之间的耦合性过高，那怎样降低耦合呢？桥接模式是用于把抽象化和实现化解耦，使得两者可以独立变化。
优点： 抽象接口与其实现解耦，其中的抽象和实现可以独立的进行扩展，不会影响对方。
缺点： 增加了系统的复杂度。
使用场景：  如果一个系统需要在构件的抽象化角色和具体化角色之间添加更多的灵活性，避免在两个层次之间建立静态的联系； 设计要求实现化角色的任何改变不应当影响客户端，或者实现化角色的改变对客户端是完全透明的； 需要跨越多个平台的图形和窗口系统上； 一个类存在两个独立变化的维度，且两个维度都需要进行扩展。  区别： 桥接模式和适配器模式、代理模式的区别：
 桥接模式提出是为了使用变化的，即需求发生多维度变化怎么办？而适配器模式的提出是为了解决兼容性问题，即由不兼容到兼容；代理模式提出主要是为了接口隔离。  eg： class COS { public: virtual void Run(){} }; class CLinuxOS : public COS { public: void Run(){cout &amp;lt;&amp;lt; &amp;#34;LinuxOS run()&amp;#34; &amp;lt;&amp;lt; endl;} }; class CUnixOS : public COS { public: void Run(){cout &amp;lt;&amp;lt; &amp;#34;CUnixOS run()&amp;#34; &amp;lt;&amp;lt; endl;} }; //------------------------------------ class CComputer { public: virtual void InstallOS(COS *os){} }; class CIBMComputer : public CComputer { public: void InstallOS(COS *os){ os-&amp;gt;Run();} }; class CHPComputer : public CComputer { public: void InstallOS(COS *os){ os-&amp;gt;Run();} }; //------------------------------------ //use  COS *os = new CLinuxOS(); CComputer *cmptr = new CIBMComputer(); cmptr-&amp;gt;InstallOS(os); </description>
    </item>
    
    <item>
      <title>Design Patterns - 结构型模式 - 适配器模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:40:50 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>适配器模式： 　将某个类的接口转换成客户端期望的另一个接口表示，主要的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。如读卡器是作为内存卡和笔记本之间的适配器，需要将内存卡插入读卡器，再将读卡器插入笔记本，这样笔记本就可以读取内存卡了。
适配器模式的主要角色：  目标接口（Target）：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者类（Adaptee）：被访问和适配的现存组件库中的组件接口。 适配器类（Adapter）：转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。  分类： 适配器模式主要分三类：
 类适配器模式、 对象适配器模式、 接口适配器模式。  优点： 　1、客户端通过适配器可以透明地调用目标接口。
　2、复用了现存的类，开发人员不需要修改原有代码而重用现有的适配者类。
　3、将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。
缺点： 　1、对类适配器来说，更换适配器的实现过程比较复杂。
　2、过多的适配器，会让系统零乱，不易整体进行把握。
类适配器模式 　当前去外地出差，工作繁忙，回到宾馆也不得不工作。当你拿出电脑，准备接电源，卧槽&amp;hellip;不支持！！！电源是两孔的，而插座是三孔的，怎么办呢？你会想到去楼下小商店买个转换插座，将三孔插座转成两孔的来用，简直太聪明了。
class ThreePhaseOutlet { public: void doThreePhasePlugin() { cout&amp;lt;&amp;lt;&amp;#34;三相插头强势插入！&amp;#34;&amp;lt;&amp;lt;endl; } }; class TwoPhaseOutlet { public: virtual void doPlugin() = 0; }; class OutletConvertor: public TwoPhaseOutlet,public ThreePhaseOutlet { public: void doPlugin() { doConvertor(); doThreePhasePlugin(); }	void doConvertor() { cout&amp;lt;&amp;lt;&amp;#34;三相插头转为两厢插头！&amp;#34;&amp;lt;&amp;lt;endl; } }; 对象适配器模式 　当手机没电需要充电，你不可能直接使用220V的电压，如果你真这么做了，请注意人身安全及购买一台新机。此时，充电器就起到了转换器的作用，将220V电压转换成手机可使用的5V电压。</description>
    </item>
    
    <item>
      <title>Design Patterns - 结构型模式 - 外观模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:35:57 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>外观模式： 　外部通过一个统一的接口，访问子系统中的一群接口。外观模式定义了一个高层接口，为子系统中的一组接口提供一个一致的入口，使得子系统更容易使用。外观模式相对比较简单，可以理解为中介，原先租房需要自己一个个筛选，联系房东，谈好价格，签合同等等，现在不需要这些了，只要你说出要求中介就会将房子找好，你只需要掏钱签合同就可以了，不需要关系其他琐碎的事情。
外观模式的角色：  外观角色：为多个子系统对外提供一个共同的接口； 子系统角色：实现系统的部分功能，客户可以通过外观角色访问它； 客户角色：通过一个外观角色访问各个子系统的功能。  优点： 外观模式是迪米特法则的典型应用。
 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类； 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易； 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。  缺点：  不能很好的限制客户使用子系统； 违背了开闭原则  eg： class SysOne { public: SysOne(); virtual ~SysOne(); void FuncOne(){ cout&amp;lt;&amp;lt;&amp;#34;FuncOne&amp;#34;&amp;lt;&amp;lt;endl; } }; class SysTwo { public: SysTwo (); virtual ~SysTwo (); void FuncTwo(){ cout&amp;lt;&amp;lt;&amp;#34;FuncTwo&amp;#34;&amp;lt;&amp;lt;endl; } }; class SysThree { public: SysThree (); virtual ~SysThree (); void FuncThree(){ cout&amp;lt;&amp;lt;&amp;#34;FuncThree&amp;#34;&amp;lt;&amp;lt;endl; } }; //------------------------ class Facade { public: Facade(){ p1 = new SysOne(); p2 = new SysTwo(); p3 = new SysThree(); } void FuncA(){ p1-&amp;gt;FuncOne(); p2-&amp;gt;FuncTwo(); } void FuncB(){ p1-&amp;gt;FuncOne(); p3-&amp;gt;FuncThree(); } virtual ~Facade(); private: SysOne *p1; SysTwo *p2; SysThree *p3; }; Facade * p =new Facade(); p-&amp;gt;FuncA(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 结构型模式 - 装饰模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:29:09 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</guid>
      <description>装饰者模式： 　允许向一个现有的对象添加新的功能，同时又不改变其结构。装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。
装饰者模式有四个角色： 　1）抽象构建（Component ）：给出一个抽象接口，来规范被添加职责的对象；
　2）具体构件（ConcreteComponent）：定义一个将要接收附加责任的具体对象；
　3）装饰抽象类（Decorator）：持有一个构件（Component）对象的实例，并定义一个与抽象构件接口一致的接口；
　4）具体装饰对象（ConreteDecorator）：负责给构件对象 ”贴上“附加的责任。起到给Component添加职责的功能。
要点： 　1）装饰者和被装饰对象有相同的超类型。
　2）可以用一个或多个装饰者包装一个对象。
　3）装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的。
　4）对象可以在任何时候被装饰，所以可以在运行时动态的，不限量的用你喜欢的装饰者来装饰对象。
　5）装饰模式中使用继承的关键是想达到装饰者和被装饰对象的类型匹配，而不是获得其行为。
　6）装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。在实际项目中可以根据需要为装饰者添加新的行为，做到“半透明”装饰者。
优点：  装饰这模式和继承的目的都是扩展对象的功能，但装饰者模式比继承更灵活； 通过使用不同的具体装饰类以及这些类的排列组合，设计师可以创造出很多不同行为的组合； 装饰者模式有很好地可扩展性  缺点： 装饰者模式会导致设计中出现许多小对象，如果过度使用，会让程序变的更复杂。并且更多的对象会是的差错变得困难，特别是这些对象看上去都很像。
区别： 装饰者模式与代理模式的区别：  两种模式的关注点不同，装饰者模式关注的是在一个对象上动态的添加方法，而代理模式关注的是控制对象的访问。 装饰者模式可以让使用者直观的看到增强了哪些功能，而代理模式完全限制了使用者，只去调用代理，至于代理里面增加了什么功能，使用者是不知道，隐藏了一个对象的具体信息，这正是为什么代理模式在初始化时不能像装饰模式一样传入一个原始对象的参数的原因。 代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。  //公共抽象类 class Phone { public: Phone() {} virtual ~Phone() {} virtual void ShowDecorate() {} }; //-------------------------------- //具体的手机类 class iPhone : public Phone { private: string m_name; //手机名称 public: iPhone(string name): m_name(name){} ~iPhone() {} void ShowDecorate() { cout&amp;lt;&amp;lt;m_name&amp;lt;&amp;lt;&amp;#34;的装饰&amp;#34;&amp;lt;&amp;lt;endl;} }; class NokiaPhone : public Phone { private: string m_name; public: NokiaPhone(string name): m_name(name){} ~NokiaPhone() {} void ShowDecorate() { cout&amp;lt;&amp;lt;m_name&amp;lt;&amp;lt;&amp;#34;的装饰&amp;#34;&amp;lt;&amp;lt;endl;} }; //-------------------------------- //装饰类 class DecoratorPhone : public Phone { private: Phone *m_phone; //要装饰的手机 public: DecoratorPhone(Phone *phone): m_phone(phone) {} virtual void ShowDecorate() { m_phone-&amp;gt;ShowDecorate(); } }; class DecoratorPhoneA : public DecoratorPhone { public: DecoratorPhoneA(Phone *phone) : DecoratorPhone(phone) {} void ShowDecorate() { DecoratorPhone::ShowDecorate(); cout&amp;lt;&amp;lt;&amp;#34;增加挂件&amp;#34;&amp;lt;&amp;lt;endl; } //增加的装饰 }; class DecoratorPhoneB : public DecoratorPhone { public: DecoratorPhoneB(Phone *phone) : DecoratorPhone(phone) {} void ShowDecorate() { DecoratorPhone::ShowDecorate(); cout&amp;lt;&amp;lt;&amp;#34;屏幕贴膜&amp;#34;&amp;lt;&amp;lt;endl; } }; //-------------------------------- //use 	Phone *iphone = new NokiaPhone(&amp;#34;6300&amp;#34;); Phone *dpa = new DecoratorPhoneA(iphone); //装饰，增加挂件 	Phone *dpb = new DecoratorPhoneB(dpa); //装饰，屏幕贴膜 	dpb-&amp;gt;ShowDecorate(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 结构型模式 - 代理模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:21:20 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>代理模式： 　代理模式就是给某一个对象提供一个代理，并由代理对象控制对原有对象的引用。在一些情况下，一个客户不想或者不能直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。例如windows桌面端的快捷方式就是一个代理。
代理模式按照使用目的可以分为：
 远程代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是本电脑中，也可以在另一台电脑中。如客户端调用web服务或wcf服务。 虚拟代理：根据需要创建一个资源消耗较大的对象，使得对象只在需要时才会被真正创建。 Copy-on-Write代理：虚拟代理的一种，把复制（或克隆）拖延到只有在客户端需要时，才真正采取行动。 保护（Protected or Access）代理：控制一个对象的访问，可以给不同的用户提供不同级别的使用权限。 Cache代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以操作这些结果。 防火墙（FireWall）代理：保护目标不让恶意用户接近。 同步化（Synchronization）代理 智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来。  代理模式角色分四种： 　1）主题接口（Searcher）：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；
　2）真实主题（RealSeracher）：真正实现业务逻辑的类；
　3）代理类（ProxySeracher）：用来代理和封装真实主题；
　4）客户端：使用代理类和主题完成工作。
优点： 　1）代理模式能够将调用用于真正被调用的对象隔离，在一定程度上降低了系统的耦合度；
　2）代理对象在客户端和目标对象之间起到一个中介的作用，这样可以起到对目标对象的保护。代理对象可以在对目标对象发出请求之前进行一个额外的操作，例如权限检查等。
缺点： 　1）由于在客户端和真实主题之间增加了一个代理对象，所以会造成请求的处理速度变慢；
　2）实现代理类也需要额外的工作，从而增加了系统的实现复杂度。
区别： 代理模式与适配器模式的区别？ 　学习完适配器模式和代理模式之后，会产生这样的疑问：貌似两种模式差不多？两者都是定义了一个目标对象（抽象对象），客户端依赖该抽象对象完成相应功能，这么一解释好像是一样的，那为什么大牛们会分成两种模式呢？适配器模式是因为新旧接口不一致导致出现了客户端无法得到满足的问题，但由于旧的接口是不能被完全重构掉的，因为我们还想使用实现了这个接口的一些服务。那么为了使用以前实现旧接口的服务，我们就应该把新的接口转换成旧接口；实现这个转换的类就是抽象意义的转换器。相比于适配器的应用场景，代理就不一样了，虽然代理也同样是增加了一层，但是，代理提供的接口和原本的接口是一样的，代理模式的作用是不把实现直接暴露给客户端，而是通过代理这个层，代理能够做一些处理。
代理模式与委托的区别？  代理是模式提供一种&amp;quot;一个类对另外一个类的控制权&amp;quot;是类与类之间关系；委托提供了&amp;quot;一种方法的执行会同时执行加载在上面的方法&amp;quot;是方法与方法之间的关系。 委托可以代替代理，但是代理不能代替委托。 委托可以动态加载方法，代理不能实现。 委托对象所加载的方法不一定要属于同一个类。但是代理的类必须属于同一个类。   eg: class SchoolGirl { public: SchoolGirl(string name):mName(name){}; virtual ~SchoolGirl(); string getName(){ return mName; } private: string mName; }; //-------------------------------- class GiveGift { public: GiveGift(); virtual ~GiveGift(); virtual void GiveDolls() = 0; virtual void GiveFlowers() = 0; virtual void GiveChocolate() = 0; }; class Pursuit : GiveGift{ public: Pursuit(SchoolGirl *p): pSchoolGirl(p){}; virtual ~Pursuit(); SchoolGirl *pSchoolGirl; virtual void GiveDolls() { cout&amp;lt;&amp;lt;pSchoolGirl-&amp;gt;getName()&amp;lt;&amp;lt;&amp;#34;GiveDolls&amp;#34;&amp;lt;&amp;lt;endl; } virtual void GiveFlowers() { cout&amp;lt;&amp;lt;pSchoolGirl-&amp;gt;getName()&amp;lt;&amp;lt;&amp;#34;GiveFlowers&amp;#34;&amp;lt;&amp;lt;endl; } virtual void GiveChocolate() { cout&amp;lt;&amp;lt;pSchoolGirl-&amp;gt;getName()&amp;lt;&amp;lt;&amp;#34;GiveChocolate&amp;#34;&amp;lt;&amp;lt;endl; } }; class Proxy : GiveGift{ public: Proxy(SchoolGirl *p){ pPursuit = new Pursuit(p); }; virtual ~Proxy(); Pursuit *pPursuit; virtual void GiveDolls() { pPursuit-&amp;gt;GiveDolls(); } virtual void GiveFlowers() { pPursuit-&amp;gt;GiveFlowers(); } virtual void GiveChocolate() { pPursuit-&amp;gt;GiveChocolate(); } }; //-------------------------------- //use  SchoolGirl *p =new SchoolGirl(&amp;#34;girl&amp;#34;); Proxy *daili =new Proxy(p); daili-&amp;gt;GiveDolls(); daili-&amp;gt;GiveFlowers(); daili-&amp;gt;GiveChocolate(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 创建型模式 - 建造者模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:14:54 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>建造者模式 引言： 　无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、底盘、发动机、方向盘等各种部件。而对于大部分用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车。有的人说：抽象工厂模式不是用来生产产品的吗，我们使用它来解决不是可以了吗？貌似有一定的道理，但是你有没有考虑到了安装细节，每辆汽车的零部件安装细节可能是不同的。抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。那怎么办呢？于是，建造者模式应运而生。
介绍： 　建造者模式又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。
　建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构造细节。
建造者模式有四个角色：  Product（产品）：一个具体的产品对象。（也可以使用抽象工厂模式来进行细分） Builder（抽象建造者）：创建一个Product对象的各个部件指定的接口。 ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件。 Diretor（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离客户与对象的生产过程，二是：负责控制产品对象的生产过程。  建造者模式的优点：  客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象 。 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合OCP原则。  建造模式的缺点：  产品之间差异性很大的情况： 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 产品内部变化很复杂的情况： 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。  eg： class Product { public: Product(); virtual ~Product(); void Add(string part){ mParts.push_back(part); } void Show(){ list &amp;lt;string&amp;gt;::iterator iter; for(iter = mParts.begin();iter!= mParts.end();iter++){ cout &amp;lt;&amp;lt; *iter &amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;endl; } } list &amp;lt;string&amp;gt; mParts ; }; //-------------------------------------- class Builder { public: Builder(); virtual ~Builder(); virtual void BuildPartA() = 0; virtual void BuildPartB() = 0; virtual Product* GetResult() = 0; }; class ConcreteBuilder1 :public Builder{ public: ConcreteBuilder1(){ pPro = new Product; }; virtual ~ConcreteBuilder1(); void BuildPartA(){ pPro-&amp;gt;Add(&amp;#34;Part A&amp;#34;); } void BuildPartB(){ pPro-&amp;gt;Add(&amp;#34;Part B&amp;#34;); } Product* GetResult(){ return pPro; } private: Product *pPro; }; class ConcreteBuilder2 :public Builder{ public: ConcreteBuilder2(){ pPro =new Product(); } virtual ~ConcreteBuilder2(); void BuildPartA(){ pPro-&amp;gt;Add(&amp;#34;Part X&amp;#34;); } void BuildPartB(){ pPro-&amp;gt;Add(&amp;#34;Part Y&amp;#34;); } Product* GetResult(){ return pPro; } private: Product *pPro; }; //-------------------------------------- class Director { public: Director(); virtual ~Director(); void Construct(Builder *build){ //告诉指挥者，需要什么样的小人 	build-&amp;gt;BuildPartA();//根据用户的选择建造小人 	build-&amp;gt;BuildPartB(); } }; //use 	Director * d= new Director(); Builder* b1 =new ConcreteBuilder1(); Builder* b2 =new ConcreteBuilder2(); d-&amp;gt;Construct(b1); b1-&amp;gt;GetResult()-&amp;gt;show(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 创建型模式 - 单例模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:09:02 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>单例模式 前言： 　单例模式，顾名思义，只存在一个实例。官方定义：对于类的单例模式设计，就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。
　单例模式在写法上有很多种，
有饿汉式（类加载的时候实例化），
懒汉式（类在使用的时候实例化），
保证线程安全的写法等。具体如下：(删除线表示不推荐使用)
　① 饿汉式（静态常量）
　② 饿汉式（静态代码块）
　③ 懒汉式（线程不安全）
　④ 懒汉式（线程安全，同步方法）
　⑤ 懒汉式（线程安全，同步方法）
　⑥ 双重检查double check
　⑦ 静态内部类
　⑧ 枚举
　在IOC模式中，通常使用生命周期来实现单例，如services.AddSingleton();
懒汉式 懒汉式(Lazy-Initialization)的方法是直到使用时才实例化对象，
也就说直到调用get_instance() 方法的时候才 new 一个单例的对象。
好处是如果被调用就不会占用内存。
class Singleton{ private: Singleton(){ std::cout&amp;lt;&amp;lt;&amp;#34;constructor called!&amp;#34;&amp;lt;&amp;lt;std::endl; } Singleton(Singleton&amp;amp;)=delete; Singleton&amp;amp; operator=(const Singleton&amp;amp;)=delete; static Singleton* m_instance_ptr; public: ~Singleton(){ std::cout&amp;lt;&amp;lt;&amp;#34;destructor called!&amp;#34;&amp;lt;&amp;lt;std::endl; } static Singleton* get_instance(){ if(m_instance_ptr==nullptr){ m_instance_ptr = new Singleton; } return m_instance_ptr; } void use() const { std::cout &amp;lt;&amp;lt; &amp;#34;in use&amp;#34; &amp;lt;&amp;lt; std::endl; } }; Singleton* Singleton::m_instance_ptr = nullptr; Singleton* instance = Singleton::get_instance(); Singleton* instance_2 = Singleton::get_instance(); return 0;  线程安全的问题,当多线程获取单例时有可能引发竞态条件：第一个线程在if中判断 m_instance_ptr是空的，于是开始实例化单例;同时第2个线程也尝试获取单例，这个时候判断m_instance_ptr还是空的，于是也开始实例化单例;这样就会实例化出两个对象,这就是线程安全问题的由来; 解决办法:加锁 内存泄漏.</description>
    </item>
    
    <item>
      <title>Design Patterns - 创建型模式 - 原型模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:02:53 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>原型模式 引言： 　原型模式是什么？它是在什么场景下被提出的呢？本章节，我们将详细了解下原型模式。
　在软件系统中，当创建一个类的实例过程过于昂贵或复杂，并且我们需要创建多个这样类的实例时，
 如果我们通过new来创建类实例，这就会增加创建类的复杂度和创建过程与客户代码复杂的耦合度。 如果采用工厂模式来创建这样的实例对象的话，随着产品类的不断增加，导致子类的数量不断增多，也导致了相应工厂类的增加，维护的代码维度增加了，因为有产品和工厂两个维度了，反而增加了系统复杂程度，所以在这里使用工厂模式来封装类创建过程并不合适。 由于每个类实例都是相同的（类型相同），但是每个实例的状态参数会有不同，如果状态数值也相同就没意义了，有一个这样的对象就可以了。 当我们需要多个相同的类实例时，可以通过对原来对象拷贝一份来完成创建，这个思路正是原型模式的实现方式。  定义： 　原型模式就是通过给出一个原型对象来指明所要创建的对象类型，然后用复制这个对象的方法来创建更多的同类型对象。
原型模式的两种类型： 　object类的clone方法只会拷贝对象中基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。
深拷贝： 　1、复制对象的基本数据类型的成员变量值。
　2、为所有引用类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝。
　3、深拷贝实现方式1：重写clone方法。
　4、深拷贝实现方式2：通过对象序列化。
原型模式的注意事项和细节： 　1、创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。
　2、不用重新初始化对象，而是动态地获取对象运行时的状态。
　3、如果原始对象发生变化（增加或减少属性），其它克隆对象也会发生相应的变化，无需修改代码。
　4、在实现深克隆的时候可能需要比较复杂的代码。　　5、使用原型模式复制不会调用类的构造方法。因为对象的复制是通过调用clone方法完成的，它直接在内存种复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中，我们通过私有化构造函数来实现单例模式，但clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的。
原型模式的优点： 　1、原型模式向客户隐藏了创建新实例的复杂性。
　2、原型模式允许动态增加或较少产品类。
　3、原型模式简化了实例的创建结构，工厂方法模式需要有一个与产品类等级结构相同的等级结构，而原型模式不需要这样。
　4、产品类不需要事先确定产品的等级结构，因为原型模式适用于任何的等级结构。
缺点： 　1、需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改源码，即违反了OCP原则。
eg： class Prototype { private: string str; public: Prototype(string s) { str = s; } void show() { cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl; } virtual Prototype *clone() = 0; }; class ConcretePrototype1 :public Prototype { public: ConcretePrototype1(string s) :Prototype(s) {} ConcretePrototype1(){} virtual Prototype *clone() { ConcretePrototype1 *p = new ConcretePrototype1(); *p = *this; return p; } }; class ConcretePrototype2 :public Prototype { public: ConcretePrototype2(string s) :Prototype(s) {} ConcretePrototype2(){} virtual Prototype *clone() { ConcretePrototype2 *p = new ConcretePrototype2(); *p = *this; return p; } }; //use  ConcretePrototype1 *test = new ConcretePrototype1(&amp;#34;小李&amp;#34;); ConcretePrototype2 *test2 = (ConcretePrototype2 *)test-&amp;gt;clone(); test-&amp;gt;show(); test2-&amp;gt;show(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 创建型模式 - 抽象工厂模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 05 Nov 2020 20:19:07 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>抽象工厂模式 前一章节，我们介绍了简单工厂模式以及工厂方法模式，但是这两种模式都存在一定的局限性，只能生产某一类型下的某一种产品，如果需求变更，同类型下出现了不同的产品，比如芝士披萨不仅有口味上的不同，同时存在外观上的不同。这种时候，工厂模式显然不再满足要求，该怎么办呢？于是我们想到DIP原则，它不正是为了解决这种情况而存在的吗？接下来我们来介绍下抽象工厂模式：
  抽象工厂模式定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。
  抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
  从设计层面来说，抽象工厂模式就是对简单工厂模式的改进（即进一步抽象化）
  将工厂抽象成两层，抽象工厂和具体的实现工厂。
  理解： 读过一些博主的博文以及评论，有一些理解还是蛮到位的：
 抽象工厂比工厂方法复杂的多，它们的目的不同。工厂方法意在延迟加载，而抽象方法意在高内聚低耦合。 工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂可以创建多个。  // 键盘 class KeyBoard { public: virtual void show() = 0; }; // 微软的键盘 class KeyBoardMicro : public KeyBoard { public: void show() { std::cout &amp;lt;&amp;lt; &amp;#34;微软的键盘&amp;#34; &amp;lt;&amp;lt; std::endl; } }; // 联想的键盘 class KeyBoardLenovo : public KeyBoard { public: void show() { std::cout &amp;lt;&amp;lt; &amp;#34;联想的键盘&amp;#34; &amp;lt;&amp;lt; std::endl; } }; class Mouse { public: virtual void show() = 0; }; // 微软的鼠标 class MouseMicro : public Mouse { public: void show() { std::cout &amp;lt;&amp;lt; &amp;#34;微软的鼠标&amp;#34; &amp;lt;&amp;lt; std::endl; } }; // 联想的鼠标 class MouseLenovo : public Mouse { public: void show() { std::cout &amp;lt;&amp;lt; &amp;#34;联想的鼠标&amp;#34; &amp;lt;&amp;lt; std::endl; } }; //----------------------------------------- class Factory { public: virtual KeyBoard * createKeyBoard() = 0; virtual Mouse * createMouse() = 0; }; // 微软的工厂 class FactoryMicro : public Factory { public: KeyBoard * createKeyBoard() { return new KeyBoardMicro(); } Mouse * createMouse() { return new MouseMicro(); } }; // 联想的工厂 class FactoryLenovo : public Factory { public: KeyBoard * createKeyBoard() { return new KeyBoardLenovo(); } Mouse * createMouse() { return MouseLenovo(); } }; //----------------------------------------- //use 	// 抽象工厂模式 	Factory * p = new FactoryMicro(); KeyBoard * pKeyBoard = p-&amp;gt;createKeyBoard(); pKeyBoard-&amp;gt;show(); auto pMouse = p-&amp;gt;createMouse(); pMouse-&amp;gt;show(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 创建型模式 - 工厂模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 05 Nov 2020 20:07:15 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>工厂设计模式： 　顾名思义，该模式是用来生产对象的。在面向对象的设计模式中，万物皆对象，若使用new来创建对象，就会对该对象产生强耦合，假如我们需要更换该对象，那么使用该对象的对象都需要进行修改，这显然违背了开闭原则（OCP）。如果我们使用工厂来产生对象，我们只需要与这个工厂打交道就可以了，无需关心具体的对象，达到解耦的目的。
　接下来我们从实际的案例出发，从无工厂到有工厂的区别。
eg 有一个销售管理系统支持多种支付方式，如现金支付，信用卡支付，代金券支付等。
在设计过如果不使用简单工厂模式，可能会存在如下的支付方式。
void pay(string pay_type) { if(pay_type==现金) { 现金支付处理手段 } else if(pay_type==信用卡) { 信用卡支付处理 } else if(pay_type==代金券) { 代金券处理 } ........ } 简单工厂模式包含三个角色：   工厂角色（Factory）
  抽象产品角色(Product)
  具体产品角色(ConcreteProduct)
  简单工厂模式优缺点：  由代码可以看出，虽然简单工厂模式一定程度上减少了因需求变更而导致的代码更改，但是实际仍违背了OCP原则。 所以简单工厂模式只适合产品对象相对较少，且产品固定的需求，对产品变化无常的需求来说显然不适合。  使用： //	将各种支付方式写成统一的抽象方法，为各种支付方式提供统一的接口 class AbstractPay { public: virtual void pay() = 0; }; //	将每种支付方式封装在一个独立的类中，各个支付方式类相对独立修改其一对于其他类没有任何影响， //	这些独立的支付方式类充当具体的产品类角色。是抽象类的派生类 class CashPay :public AbstractPay { public: void pay() { cout &amp;lt;&amp;lt; &amp;#34;现金支付&amp;#34; &amp;lt;&amp;lt; endl; } }; class CreditcardPay :public AbstractPay { public: void pay() { cout &amp;lt;&amp;lt; &amp;#34;信用卡支付&amp;#34; &amp;lt;&amp;lt; endl; } }; //	将针对于个种支付方式的对象的创建封装成一个统一的方法中，即：工厂化。 class PayMethodFactory { public: AbstractPay* getPayMethod(string type) { if (type == &amp;#34;cash&amp;#34;) { return new CashPay(); } else { return new CreditcardPay(); } } }; int main() { PayMethodFactory *pmf = new PayMethodFactory(); //基类指针指向带有虚函数的派生类对象形成多态 	AbstractPay* p = pmf-&amp;gt;getPayMethod(&amp;#34;cash&amp;#34;); //假定现在是现金支付 	p-&amp;gt;pay(); system(&amp;#34;pause&amp;#34;); return 0; } 工厂方法设计模式： 披萨项目需求变更，客户点披萨时可以点不同口味的披萨。</description>
    </item>
    
    <item>
      <title>Design Patterns - 开闭原则</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 05 Nov 2020 19:54:08 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</guid>
      <description>开闭原则： ​	软件对象（类、模块、方法等）应该对于扩展是开放的，对修改是关闭的。比如：一个网络模块，原来只有服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将客户端和服务端分开。公共部分抽象出来。
问题由来：
　在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。
解决办法：
　当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
　开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我&amp;quot;你进行设计的时候一定要遵守开闭原则&amp;quot;，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。
　在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的&amp;quot;平均得分&amp;quot;，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。
　其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。
　说到这里，再回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：
 单一职责原则告诉我们实现类要职责单一； 里氏替换原则告诉我们不要破坏继承体系； 依赖倒置原则告诉我们要面向接口编程； 接口隔离原则告诉我们在设计接口的时候要精简单一； 迪米特法则告诉我们要降低耦合。 而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。  为什么使用开闭原则？ 　1、只要是面向对象的编程，在开发过程中都会强调开闭原则
　2、是最基础的设计原则，其他五个设计原则都是开闭原则的具体形态
　3、可以提高代码的复用性
　4、可以提高代码的可维护性
如何使用开闭原则？ 　1、抽象约束
　抽象对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放。
　2、元数据控件模块行为　　3、制定项目章程
　4、封装变化
　将相同的变化封装到一个接口或抽象类中，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同变化出现在同一个接口或抽象类中。</description>
    </item>
    
    <item>
      <title>Design Patterns - 迪米特法则</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</link>
      <pubDate>Thu, 05 Nov 2020 19:51:41 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</guid>
      <description>迪米特法则： 　也叫最少知识原则。迪米特法则的定义是只与你的直接朋友交谈，不与&amp;quot;陌生人&amp;quot;说话。如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该应用。其目的是降低类之间的耦合度，提高模块的相对独立性。
　迪米特法则中的朋友是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。
优点： 　1、降低类之间的耦合度，提高模块的相对独立性。
　2、由于亲和度降低，从而提高了类的可复用率和系统的扩展性。
缺点： 　过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。
注意： 使用迪米特法则需要注意：
　1、在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
　2、在类的结构设计上，尽量降低类成员的访问权限。
　3、在类的设计上，优先考虑将一个类设置成不变类。
　4、在对其他类的引用上，将引用其他对象的次数降到最低。
　5、不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
　6、谨慎使用序列化（Serializable）功能。</description>
    </item>
    
    <item>
      <title>Design Patterns - 里氏替换原则</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 05 Nov 2020 19:48:54 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</guid>
      <description>里氏替换原则： 　子类应当可以替换父类并出现在父类能够出现的地方。比如：公司搞年度派对，都有员工都可以抽奖，那么不管是新员工还是老员工，也不管是总部员工还是外派员工，都应当可以参加抽奖。
　里氏替换至少包含一下两个含义：
 里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。 如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。  要求： 里氏转换原则应满足以下要求：
　1、子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
　2、子类可以增加自己特有的方法
　3、当子类的方法重载父类的方法时，方法的形参要比父类方法的输入参数更宽松
　4、当子类的方法实现父类的抽象方法时，方法的返回值应比父类更严格
优点： 　可以大大减少程序的bug以及增强代码的可读性</description>
    </item>
    
    <item>
      <title>Design Patterns - 依赖倒置原则</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 05 Nov 2020 19:46:00 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</guid>
      <description>依赖倒置原则：　 　1、高层模块不应该依赖底层模块，二者都应该依赖抽象。
　2、抽象不应该依赖细节，细节应该依赖抽象。
　3、依赖倒置的中心思想是面向接口编程。
　4、依赖倒置原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。
　5、使用接口或抽象类的目的是指定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类来完成。
本质： 依赖倒置原则的本质就是通过抽象(接口或抽象类)使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。我们在项目中使用这个原则要遵循下面的规则：
　1、每个类尽量都有接口或者抽象类，或者抽象类和接口两都具备
　2、变量的表面类型尽量是接口或者抽象类
　3、任何类都不应该从具体类派生
　4、尽量不要覆写基类的方法
　5、如果基类是一个抽象类，而这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会有一定的影响
　6、结合里氏替换原则使用</description>
    </item>
    
    <item>
      <title>Design Patterns - 接口隔离原则</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 05 Nov 2020 19:40:00 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</guid>
      <description>接口隔离原则： 　1、客户端不应依赖它不需要的接口
　2、类间的依赖关系应该建立在最小的接口上
 其实通俗来理解就是，不要在一个接口里面放很多的方法，这样会显得这个类很臃肿。 接口应该尽量细化，一个接口对应一个功能模块，同时接口里面的方法应该尽可能的少，使接口更加灵活轻便。 或许有的人认为接口隔离原则和单一职责原则很像，但两个原则还是存在着明显的区别。 单一职责原则是在业务逻辑上的划分，注重的是职责。接口隔离原则是基于接口设计考虑。  例如一个接口的职责包含10个方法，这10个方法都放在同一接口中，并且提供给多个模块调用，但不同模块需要依赖的方法是不一样的，这时模块为了实现自己的功能就不得不实现一些对其没有意义的方法，这样的设计是不符合接口隔离原则的。   接口隔离原则要求&amp;quot;尽量使用多个专门的接口&amp;quot;专门提供给不同的模块。  </description>
    </item>
    
    <item>
      <title>Design Patterns - 单一职责原则</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 05 Nov 2020 19:30:09 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</guid>
      <description>单一职责原则： 　对象不应承担太多功能，正如一心不能而用，比如太多的工作(种类)会使人崩溃。唯有专注才能保证对象的高内聚；唯有唯一，才能保证对象的细粒度。
解决问题： 　假如有A和B两个类，当A需求发生改变需要修改时，不能导致B类出问题。
现状： 　在实际情况很难去做到单一职责原则，因为随着业务的不断变更，类的职责也在发生着变化，即职责扩散。
  如类A完成职责P的功能，但是随着后期业务细化，职责P分解成更小粒度的P1与P2，这时根据单一职责原则则需要拆分类A以分别满足细分后的职责P1和P2。
  但是实际开发环节，若类的逻辑足够简单，可以在代码上级别上违背单一职责原则；
  若类的方法足够少，可以在方法级别上违背单一职责原则。
  优点： 　1、降低类的功能复杂度
　2、提高系统的可维护性
　3、变更风险低</description>
    </item>
    
    <item>
      <title>Other - git</title>
      <link>https://jfy0o0.github.io/1/other-git/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      
      <guid>https://jfy0o0.github.io/1/other-git/</guid>
      <description>一：创建版本库。   通过命令 git init 把这个目录变成git可以管理的仓库
  使用命令 git add readme.txt添加到暂存区里面去。
  用命令 git commit告诉Git，把文件提交到仓库。
  继续使用git status来查看下结果
  二：版本回退：  使用命令 git查看下历史记录 版本回退操作  git reset &amp;ndash;hard HEAD^ 那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 如果要回退到前100个版本的话，git reset &amp;ndash;hard HEAD~100    三：理解工作区与暂存区的区别？  工作区：就是你在电脑上看到的目录，比如目录下testgit里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。 版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。  我们前面说过使用Git提交文件到版本库有两步：
 第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。 第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。  四：Git撤销修改和删除文件操作。 一：撤销修改：
 如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。 我可以按以前的方法直接恢复到上一个版本。使用 git reset &amp;ndash;hard HEAD^ 可以发现，Git会告诉你，git checkout &amp;ndash; file 可以丢弃工作区的修改，如下命令： git checkout &amp;ndash; readme.</description>
    </item>
    
  </channel>
</rss>
