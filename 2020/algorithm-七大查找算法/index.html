<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Jiang .">
  
  
  
  <link rel="prev" href="https://jfy0o0.github.io/2020/algorithm_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" />
  
  <link rel="canonical" href="https://jfy0o0.github.io/2020/algorithm-%E4%B8%83%E5%A4%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Algorithm - 七大查找算法 | Jiang . &#39;s blog
       
  </title>
  <meta name="title" content="Algorithm - 七大查找算法 | Jiang . &#39;s blog">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/jfy0o0.github.io"
    },
    "articleSection" : "posts",
    "name" : "Algorithm - 七大查找算法",
    "headline" : "Algorithm - 七大查找算法",
    "description" : "顺序 说明： 顺序查找适用于存储结构为顺序存储或链式存储的线性表。\n基本思想： ​ 顺序查找也称为线形查找，属于无序查找算法。从数据结构线性表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定K值进行比较，若相等则表示查找成功，若扫描结束仍旧没有找到关键字等于K的结点，则表示查找失败。\n代码 #include\u0026lt;iostream\u0026gt;using namespace std; int SequenceSearch(int a[], int value, int n) { int i; for (i = 0; i\u0026lt;n; i\u002b\u002b) if (a[i] == value) return i; return -1; } int main() { int a[] = { 2, 3, 5, 8, 6, 7, 9, 0 }; int key, index; int n = sizeof(a) \/ sizeof(a[0]); cout \u0026lt;\u0026lt; \u0026#34;请输入待查找的值：\u0026#34; \u0026lt;\u0026lt; endl; cin \u0026gt;\u0026gt; key; index = SequenceSearch(a, key, n); if (index \u0026gt;= 0) { cout \u0026lt;\u0026lt; \u0026#34;找到了\u0026#34; \u0026lt;\u0026lt; endl; } else { cout \u0026lt;\u0026lt; \u0026#34;没找到\u0026#34; \u0026lt;\u0026lt; endl; } system(\u0026#34;pause\u0026#34;); return 0; 二分 说明： 元素必须有序方能使用，无序则要先进行排序。",
    "inLanguage" : "en-us",
    "author" : "Jiang",
    "creator" : "Jiang",
    "publisher": "Jiang",
    "accountablePerson" : "Jiang",
    "copyrightHolder" : "Jiang",
    "copyrightYear" : "2020",
    "datePublished": "2020-12-11 09:57:19 \u002b0800 CST",
    "dateModified" : "2020-12-11 09:57:19 \u002b0800 CST",
    "url" : "https:\/\/jfy0o0.github.io\/2020\/algorithm-%E4%B8%83%E5%A4%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95\/",
    "wordCount" : "1382",
    "keywords" : [ "Algorithm", "Jiang . \u0027s blog"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://jfy0o0.github.io">Jiang . &#39;s blog</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://jfy0o0.github.io">Jiang . &#39;s blog</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Algorithm - 七大查找算法</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://jfy0o0.github.io" rel="author">Jiang</a> with ♥ 
                <span class="post-time">
                on <time datetime=2020-12-11 itemprop="datePublished">December 11, 2020</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://jfy0o0.github.io/categories/algorithm/"> Algorithm </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          <h1 id="顺序">顺序</h1>
<h2 id="说明">说明：</h2>
<p>顺序查找适用于存储结构为顺序存储或链式存储的线性表。</p>
<h2 id="基本思想">基本思想：</h2>
<p>​    顺序查找也称为线形查找，属于无序查找算法。从数据结构线性表的一端开始，顺序扫描，依次将扫描到的结点关键字与给定K值进行比较，若相等则表示查找成功，若扫描结束仍旧没有找到关键字等于K的结点，则表示查找失败。</p>
<h2 id="代码">代码</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">SequenceSearch</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> value, <span style="color:#66d9ef">int</span> n)
{
	<span style="color:#66d9ef">int</span> i;
	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>n; i<span style="color:#f92672">++</span>)
	<span style="color:#66d9ef">if</span> (a[i] <span style="color:#f92672">==</span> value)
		<span style="color:#66d9ef">return</span> i;
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#66d9ef">int</span> a[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">9</span>, <span style="color:#ae81ff">0</span> };
	<span style="color:#66d9ef">int</span> key, index;
	<span style="color:#66d9ef">int</span> n <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(a) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(a[<span style="color:#ae81ff">0</span>]);
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;请输入待查找的值：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	cin <span style="color:#f92672">&gt;&gt;</span> key;
	index <span style="color:#f92672">=</span> SequenceSearch(a, key, n);
	<span style="color:#66d9ef">if</span> (index <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>)
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;找到了&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	<span style="color:#66d9ef">else</span>
	{
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;没找到&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	}
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;

</code></pre></div><h1 id="二分">二分</h1>
<h2 id="说明-1">说明：</h2>
<p>元素必须有序方能使用，无序则要先进行排序。</p>
<h2 id="基本思想-1">基本思想：</h2>
<p>​    二分查找也叫折半查找，属于有序查找算法。用给定K值先与中间节点的关键字进行比较，中间节点把线性表分层两个子表，若相等则查找成功；若不相等，再根据K与中间结点关键字的比较结果确定下一步查找哪个子表，这样递归进行，直到查找或查找结束没有发现表中有这样的结点。</p>
<h2 id="代码-1">代码</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">
<span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
 
<span style="color:#75715e">//二分查找（折半查找），版本1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BinarySearch1</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> value, <span style="color:#66d9ef">int</span> n)
{
	<span style="color:#66d9ef">int</span> low, high, mid;
	low <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	high <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;=</span> high)
	{
		mid <span style="color:#f92672">=</span> (low <span style="color:#f92672">+</span> high) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
		<span style="color:#66d9ef">if</span> (a[mid] <span style="color:#f92672">==</span> value)
			<span style="color:#66d9ef">return</span> mid;
		<span style="color:#66d9ef">if</span> (a[mid]<span style="color:#f92672">&gt;</span>value)
			high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
		<span style="color:#66d9ef">if</span> (a[mid]<span style="color:#f92672">&lt;</span>value)
			low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
	}
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}
 
<span style="color:#75715e">//二分查找，递归版本
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">BinarySearch2</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> value, <span style="color:#66d9ef">int</span> low, <span style="color:#66d9ef">int</span> high)
{
	<span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> low <span style="color:#f92672">+</span> (high <span style="color:#f92672">-</span> low) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>;
	<span style="color:#66d9ef">if</span> (a[mid] <span style="color:#f92672">==</span> value)
		<span style="color:#66d9ef">return</span> mid;
	<span style="color:#66d9ef">if</span> (a[mid]<span style="color:#f92672">&gt;</span>value)
		<span style="color:#66d9ef">return</span> BinarySearch2(a, value, low, mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>);
	<span style="color:#66d9ef">if</span> (a[mid]<span style="color:#f92672">&lt;</span>value)
		<span style="color:#66d9ef">return</span> BinarySearch2(a, value, mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, high);
}
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#66d9ef">int</span> a[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span> };
	<span style="color:#66d9ef">int</span> key, len;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;请键入KEY值：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	cin <span style="color:#f92672">&gt;&gt;</span> key;
	len <span style="color:#f92672">=</span> <span style="color:#66d9ef">sizeof</span>(a) <span style="color:#f92672">/</span> <span style="color:#66d9ef">sizeof</span>(a[<span style="color:#ae81ff">0</span>]);
	<span style="color:#75715e">//int index = BinarySearch1(a, key, len);
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> BinarySearch2(a, key, <span style="color:#ae81ff">0</span>, len<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>);
	<span style="color:#66d9ef">if</span> (index <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;找到&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;没找到&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h1 id="插值">插值</h1>
<h2 id="说明-2">说明：</h2>
<p>自适应的二分查找</p>
<h2 id="基本思想-2">基本思想：</h2>
<p>插值查找是根据要查找的关键字Key与查找表中最大最小记录的关键字比较后的查找方法，其核心在于插值的计算公式：Key-arr[low]/arr[high]-arr[low]。</p>
<ul>
<li>mid的计算公式为：(high-low)*(key-arr[low])/(arr[high]-arr[low])，</li>
<li>对半查找（折半查找、二分查找）的mid=(high-low)/2。</li>
<li>这种mid的改变的好处是：对于表长较长，且关键字分布比较均匀，插值查找算法的平均性能要高于折半查找，但是如果关键字分布极不均匀，那么插值查找不如折半查找。</li>
</ul>
<h2 id="代码-2">代码</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">//插值查找法 arr数组，length 数组长度，key 查找的关键字
</span><span style="color:#75715e">//返回查找值的下标 ，没查找到 返回-1
</span><span style="color:#75715e"></span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Interpolation_Search</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>arr, <span style="color:#66d9ef">int</span> length, <span style="color:#66d9ef">int</span> key)
{
	<span style="color:#66d9ef">int</span> low <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;<span style="color:#75715e">//低位下标
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> high <span style="color:#f92672">=</span> length <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//高位下标
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">int</span> mid;<span style="color:#75715e">//中间值下标
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;=</span> high)
	{
		mid <span style="color:#f92672">=</span> (high <span style="color:#f92672">-</span> low)<span style="color:#f92672">*</span>(key <span style="color:#f92672">-</span> arr[low]) <span style="color:#f92672">/</span> (arr[high] <span style="color:#f92672">-</span> arr[low]);<span style="color:#75715e">//插值
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&lt;</span> arr[mid])
		{
			high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
		}
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key <span style="color:#f92672">&gt;</span> arr[mid])
		{
			low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
		}
		<span style="color:#66d9ef">else</span>
		{
			<span style="color:#66d9ef">return</span> mid;
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#66d9ef">int</span> arr[<span style="color:#ae81ff">10</span>] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span> };
	<span style="color:#66d9ef">int</span> key;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;请键入key值：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	cin <span style="color:#f92672">&gt;&gt;</span> key;
	<span style="color:#66d9ef">int</span> index <span style="color:#f92672">=</span> Interpolation_Search(arr, <span style="color:#ae81ff">10</span>, key);
	<span style="color:#66d9ef">if</span> (index <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;找到了，index为&#34;</span> <span style="color:#f92672">&lt;&lt;</span> index <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#66d9ef">else</span>  cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;没找到&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h1 id="斐波那契">斐波那契</h1>
<h2 id="说明-3">说明：</h2>
<p>也是二分查找的一种提升算法</p>
<ul>
<li>斐波那契是一种特殊的分割方法，和二分、插值本质上是一样的，都是分割方法；</li>
<li>利用了斐波那契数列特殊的性质，一个长度只要可以被黄金分割，那么分割后的片段仍然可以继续进行黄金分割，循环。</li>
</ul>
<h2 id="基本思想-3">基本思想：</h2>
<p>通过运用黄金比例的概念在数列中选择查找点进行查找，提高查找效率。同样地，斐波那契查找也属于一种有序查找算法。</p>
<p>斐波那契查找与折半查找很相似，他是根据斐波那契序列的特点对有序表进行分割的。</p>
<p>他要求开始表中记录的个数为某个斐波那契数小1，及n=F(k)-1;</p>
<p>开始将k值与第F(k-1)位置的记录进行比较(及mid=low+F(k-1)-1),比较结果也分为三种</p>
<ul>
<li>1）相等，mid位置的元素即为所求</li>
<li>2）&gt;，low=mid+1,k-=2;
<ul>
<li>说明：low=mid+1说明待查找的元素在[mid+1,high]范围内，k-=2 说明范围[mid+1,high]内的元素个数为n-(F(k-1))= Fk-1-F(k-1)=Fk-F(k-1)-1=F(k-2)-1个，所以可以递归的应用斐波那契查找。</li>
</ul>
</li>
<li>3）&lt;，high=mid-1,k-=1。
<ul>
<li>说明：low=mid+1说明待查找的元素在[low,mid-1]范围内，k-=1 说明范围[low,mid-1]内的元素个数为F(k-1)-1个，所以可以递归 的应用斐波那契查找。</li>
</ul>
</li>
</ul>
<h2 id="代码-3">代码</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
<span style="color:#75715e">#define MAXN 20
</span><span style="color:#75715e"></span> 
<span style="color:#75715e">/*
</span><span style="color:#75715e">*产生斐波那契数列
</span><span style="color:#75715e">* */</span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Fibonacci</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>f)
{
	<span style="color:#66d9ef">int</span> i;
	f[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	f[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>; i <span style="color:#f92672">&lt;</span> MAXN; <span style="color:#f92672">++</span>i)
		f[i] <span style="color:#f92672">=</span> f[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>] <span style="color:#f92672">+</span> f[i <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>];
}
 
<span style="color:#75715e">/*
</span><span style="color:#75715e">* 查找
</span><span style="color:#75715e">* */</span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Fibonacci_Search</span>(<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>a, <span style="color:#66d9ef">int</span> key, <span style="color:#66d9ef">int</span> n)
{
	<span style="color:#66d9ef">int</span> i, low <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>, high <span style="color:#f92672">=</span> n <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">int</span> mid <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> k <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">int</span> F[MAXN];
	Fibonacci(F);
	<span style="color:#66d9ef">while</span> (n <span style="color:#f92672">&gt;</span> F[k] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) 			<span style="color:#75715e">//计算出n在斐波那契中的数列
</span><span style="color:#75715e"></span>		<span style="color:#f92672">++</span>k;
	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> n; i <span style="color:#f92672">&lt;</span> F[k] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>; <span style="color:#f92672">++</span>i) <span style="color:#75715e">//把数组补全
</span><span style="color:#75715e"></span>		a[i] <span style="color:#f92672">=</span> a[high];
	<span style="color:#66d9ef">while</span> (low <span style="color:#f92672">&lt;=</span> high)
	{
		mid <span style="color:#f92672">=</span> low <span style="color:#f92672">+</span> F[k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;  <span style="color:#75715e">//根据斐波那契数列进行黄金分割
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">if</span> (a[mid] <span style="color:#f92672">&gt;</span> key)
		{
			high <span style="color:#f92672">=</span> mid <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
			k <span style="color:#f92672">=</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>;
		}
		<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (a[mid] <span style="color:#f92672">&lt;</span> key)
		{
			low <span style="color:#f92672">=</span> mid <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
			k <span style="color:#f92672">=</span> k <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>;
		}
		<span style="color:#66d9ef">else</span>
		{
			<span style="color:#66d9ef">if</span> (mid <span style="color:#f92672">&lt;=</span> high) <span style="color:#75715e">//如果为真则找到相应的位置
</span><span style="color:#75715e"></span>				<span style="color:#66d9ef">return</span> mid;
			<span style="color:#66d9ef">else</span>
				<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
		}
	}
	<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
}
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#66d9ef">int</span> a[MAXN] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">15</span>, <span style="color:#ae81ff">19</span>, <span style="color:#ae81ff">20</span>, <span style="color:#ae81ff">25</span>, <span style="color:#ae81ff">31</span>, <span style="color:#ae81ff">38</span>, <span style="color:#ae81ff">41</span>, <span style="color:#ae81ff">45</span>, <span style="color:#ae81ff">49</span>, <span style="color:#ae81ff">52</span>, <span style="color:#ae81ff">55</span>, <span style="color:#ae81ff">57</span> };
	<span style="color:#66d9ef">int</span> k, res <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;请输入要查找的数字:&#34;</span>;
	cin<span style="color:#f92672">&gt;&gt;</span>k;
	res <span style="color:#f92672">=</span> Fibonacci_Search(a, k, <span style="color:#ae81ff">13</span>);
	<span style="color:#66d9ef">if</span> (res <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>)
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;在数组的第&#34;</span> <span style="color:#f92672">&lt;&lt;</span> res <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;个位置找到元素:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> k <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#66d9ef">else</span>
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;未在数组中找到元素:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> k <span style="color:#f92672">&lt;&lt;</span> endl;
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h1 id="二叉查找树">二叉查找树</h1>
<h2 id="说明-4">说明：</h2>
<p><strong>二叉查找树</strong>（BinarySearch Tree，也叫二叉搜索树，或称二叉排序树Binary Sort Tree）或者是一棵空树，或者是具有下列性质的二叉树：</p>
<p>1）若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p>
<p>2）若任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p>
<p>3）任意节点的左、右子树也分别为二叉查找树。</p>
<h2 id="基本思想-4">基本思想：</h2>
<p>二叉查找树是先对待查找的数据进行生成树，确保树的左分支的值小于右分支的值，然后在就行和每个节点的父节点比较大小，查找最适合的范围。 这个算法的查找效率很高，但是如果使用这种查找方法要首先创建树。</p>
<p>复杂度分析：</p>
<ul>
<li>它和二分查找一样，插入和查找的时间复杂度均为O(logn)，但是在最坏的情况下仍然会有O(n)的时间复杂度。</li>
<li>原因在于插入和删除元素的时候，树没有保持平衡（比如，我们查找上图（b）中的“93”，我们需要进行n次查找操作）。</li>
<li>我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++">
<span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iomanip&gt;//输出控制的头文件</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
 
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span>{
	<span style="color:#66d9ef">int</span> data;
	<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> <span style="color:#f92672">*</span>left, <span style="color:#f92672">*</span>right;
}BTNode;
 
<span style="color:#75715e">//创建二叉树
</span><span style="color:#75715e"></span>BTNode <span style="color:#f92672">*</span><span style="color:#a6e22e">CreateBTtree</span>(<span style="color:#66d9ef">int</span> a[], <span style="color:#66d9ef">int</span> n)
{
	BTNode <span style="color:#f92672">*</span>root, <span style="color:#f92672">*</span>c, <span style="color:#f92672">*</span>pa<span style="color:#f92672">=</span>NULL, <span style="color:#f92672">*</span>p;
	<span style="color:#66d9ef">int</span> i;
	root <span style="color:#f92672">=</span> (BTNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(BTNode));
	root<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> a[<span style="color:#ae81ff">0</span>];
	root<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> root<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> NULL;
	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>; i<span style="color:#f92672">&lt;</span>n; i<span style="color:#f92672">++</span>)
	{
		p <span style="color:#f92672">=</span> (BTNode <span style="color:#f92672">*</span>)malloc(<span style="color:#66d9ef">sizeof</span>(BTNode));
		p<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> p<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> NULL;
		p<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">=</span> a[i];
		c <span style="color:#f92672">=</span> root;
		<span style="color:#66d9ef">while</span> (c)
		{
			pa <span style="color:#f92672">=</span> c;
			<span style="color:#66d9ef">if</span> (c<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">&lt;</span>p<span style="color:#f92672">-&gt;</span>data)
				c <span style="color:#f92672">=</span> c<span style="color:#f92672">-&gt;</span>right;
			<span style="color:#66d9ef">else</span>
				c <span style="color:#f92672">=</span> c<span style="color:#f92672">-&gt;</span>left;
		}
		<span style="color:#66d9ef">if</span> (pa<span style="color:#f92672">-&gt;</span>data<span style="color:#f92672">&lt;</span>p<span style="color:#f92672">-&gt;</span>data)
			pa<span style="color:#f92672">-&gt;</span>right <span style="color:#f92672">=</span> p;
		<span style="color:#66d9ef">else</span>
			pa<span style="color:#f92672">-&gt;</span>left <span style="color:#f92672">=</span> p;
	}
	<span style="color:#66d9ef">return</span> root;
}
 
<span style="color:#75715e">//前序遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Forder</span>(BTNode <span style="color:#f92672">*</span>root)
{
	<span style="color:#66d9ef">if</span> (root)
	{
		<span style="color:#75715e">//printf(&#34;%5d&#34;, root-&gt;data);
</span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> setw(<span style="color:#ae81ff">5</span>) <span style="color:#f92672">&lt;&lt;</span> root<span style="color:#f92672">-&gt;</span>data;
		Forder(root<span style="color:#f92672">-&gt;</span>left);
		Forder(root<span style="color:#f92672">-&gt;</span>right);
	}
}
 
<span style="color:#75715e">//中序遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Inorder</span>(BTNode <span style="color:#f92672">*</span>root)
{
	<span style="color:#66d9ef">if</span> (root)
	{
		Inorder(root<span style="color:#f92672">-&gt;</span>left);
		<span style="color:#75715e">//printf(&#34;%5d&#34;, root-&gt;data);
</span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> setw(<span style="color:#ae81ff">5</span>) <span style="color:#f92672">&lt;&lt;</span> root<span style="color:#f92672">-&gt;</span>data;
		Inorder(root<span style="color:#f92672">-&gt;</span>right);
	}
}
 
<span style="color:#75715e">//后序遍历
</span><span style="color:#75715e"></span><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Porder</span>(BTNode <span style="color:#f92672">*</span>root)
{
	<span style="color:#66d9ef">if</span> (root)
	{
		Porder(root<span style="color:#f92672">-&gt;</span>left);
		Porder(root<span style="color:#f92672">-&gt;</span>right);
		<span style="color:#75715e">//printf(&#34;%5d&#34;, root-&gt;data);
</span><span style="color:#75715e"></span>		cout <span style="color:#f92672">&lt;&lt;</span> setw(<span style="color:#ae81ff">5</span>) <span style="color:#f92672">&lt;&lt;</span> root<span style="color:#f92672">-&gt;</span>data;
	}
}
 
BTNode <span style="color:#f92672">*</span><span style="color:#a6e22e">FindNode</span>(BTNode <span style="color:#f92672">*</span>root, <span style="color:#66d9ef">int</span> key)
{
	BTNode <span style="color:#f92672">*</span>p;
	<span style="color:#66d9ef">if</span> (<span style="color:#f92672">!</span>root)
		<span style="color:#66d9ef">return</span> NULL;
	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (root<span style="color:#f92672">-&gt;</span>data <span style="color:#f92672">==</span> key)
		<span style="color:#66d9ef">return</span> root;
	<span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> (key<span style="color:#f92672">&lt;</span>root<span style="color:#f92672">-&gt;</span>data)
		<span style="color:#66d9ef">return</span> FindNode(root<span style="color:#f92672">-&gt;</span>left, key);
	<span style="color:#66d9ef">else</span>
		<span style="color:#66d9ef">return</span> FindNode(root<span style="color:#f92672">-&gt;</span>right, key);
}
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#66d9ef">int</span> a[<span style="color:#ae81ff">8</span>] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">7</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span> };
	BTNode <span style="color:#f92672">*</span>root, <span style="color:#f92672">*</span>p;
	<span style="color:#66d9ef">int</span> key;
	cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;任意键入一个key值：&#34;</span>;
	cin<span style="color:#f92672">&gt;&gt;</span>key;
	root <span style="color:#f92672">=</span> CreateBTtree(a, <span style="color:#ae81ff">8</span>);
	<span style="color:#75715e">//前序遍历
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;前序遍历为:&#34;</span>;
	Forder(root);
	cout <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#75715e">//中序遍历
</span><span style="color:#75715e"></span>	cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;中序遍历为:&#34;</span>;
	Inorder(root);
	cout <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#75715e">//后序遍历
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;后序遍历为:&#34;</span>;
	Porder(root);
	cout <span style="color:#f92672">&lt;&lt;</span> endl;
	p <span style="color:#f92672">=</span> FindNode(root, key);
	<span style="color:#75715e">//printf(&#34;地址为：%x\n&#34;, p);
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;地址为：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> p <span style="color:#f92672">&lt;&lt;</span> endl;
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h1 id="分块">分块</h1>
<h2 id="说明-5">说明</h2>
<p>分块查找又称索引顺序查找，它是顺序查找的一种改进方法。</p>
<h2 id="基本思想-5">基本思想</h2>
<ul>
<li>将n个数据元素&quot;按块有序&quot;划分为m块（m ≤ n）。</li>
<li>每一块中的结点不必有序，但块与块之间必须&quot;按块有序&quot;；即第1块中任一元素的关键字都必须小于第2块中任一元素的关键字；而第2块中任一元素又都必须小于第3块中的任一元素，……</li>
</ul>
<h2 id="代码-4">代码</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">//分块查找算法
</span><span style="color:#75715e"></span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
 
 
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">index</span>  <span style="color:#75715e">//定义一个结构体用来分块
</span><span style="color:#75715e"></span>{
	<span style="color:#66d9ef">int</span> key;
	<span style="color:#66d9ef">int</span> start;
	<span style="color:#66d9ef">int</span> end;
}index[<span style="color:#ae81ff">4</span>];
 
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">search</span>(<span style="color:#66d9ef">int</span> key, <span style="color:#66d9ef">int</span> a[]);
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#66d9ef">int</span> i, j <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, k, key;
	<span style="color:#66d9ef">int</span> a[] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">42</span>, <span style="color:#ae81ff">63</span>, <span style="color:#ae81ff">82</span>, <span style="color:#ae81ff">89</span>, <span style="color:#ae81ff">111</span>, <span style="color:#ae81ff">146</span>, <span style="color:#ae81ff">219</span>, <span style="color:#ae81ff">254</span>, <span style="color:#ae81ff">325</span>, <span style="color:#ae81ff">336</span>, <span style="color:#ae81ff">348</span>, <span style="color:#ae81ff">795</span>, <span style="color:#ae81ff">867</span>, <span style="color:#ae81ff">951</span>, <span style="color:#ae81ff">998</span> };
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;已知有一数组&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">15</span>; i<span style="color:#f92672">++</span>)
		cout <span style="color:#f92672">&lt;&lt;</span> a[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; &#34;</span>;
	cout <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">3</span>; i<span style="color:#f92672">++</span>)  <span style="color:#75715e">//3个块
</span><span style="color:#75715e"></span>	{
		index[i].start <span style="color:#f92672">=</span> j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;<span style="color:#75715e">//确定每个块的起始值
</span><span style="color:#75715e"></span>		j <span style="color:#f92672">=</span> j <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
		index[i].end <span style="color:#f92672">=</span> j <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>;<span style="color:#75715e">//确定每个块的结束值
</span><span style="color:#75715e"></span>		j <span style="color:#f92672">=</span> j <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span>;
		index[i].key <span style="color:#f92672">=</span> a[j];<span style="color:#75715e">//确定每个块范围中的元素最大值
</span><span style="color:#75715e"></span>	}
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;请输入你要查找的数：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	cin <span style="color:#f92672">&gt;&gt;</span> key;
	k <span style="color:#f92672">=</span> search(key, a);
	<span style="color:#66d9ef">if</span> (k <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">0</span>)
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;查找成功！你要找的数字在数组中的位置是：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> k <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#66d9ef">else</span>
		cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;查找失败！你要找的数字不在数组中。&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
 
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">search</span>(<span style="color:#66d9ef">int</span> key, <span style="color:#66d9ef">int</span> a[])
{
	<span style="color:#66d9ef">int</span> i, j;
	i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
	<span style="color:#66d9ef">while</span> (i<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">3</span> <span style="color:#f92672">&amp;&amp;</span> key<span style="color:#f92672">&gt;</span>index[i].key)<span style="color:#75715e">//确定在哪个块中
</span><span style="color:#75715e"></span>		i<span style="color:#f92672">++</span>;
	<span style="color:#66d9ef">if</span> (i <span style="color:#f92672">&gt;=</span> <span style="color:#ae81ff">3</span>)<span style="color:#75715e">//大于分得的块数 返回0
</span><span style="color:#75715e"></span>		<span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
	j <span style="color:#f92672">=</span> index[i].start;<span style="color:#75715e">//j等于块范围的起始值
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (j <span style="color:#f92672">&lt;=</span> index[i].end<span style="color:#f92672">&amp;&amp;</span>a[j] <span style="color:#f92672">!=</span> key)<span style="color:#75715e">//在确定的块内进行查找
</span><span style="color:#75715e"></span>		j<span style="color:#f92672">++</span>;
	<span style="color:#66d9ef">if</span> (j<span style="color:#f92672">&gt;</span>index[i].end)<span style="color:#75715e">//如果大于块范围的结束值 则说明没有要查找的数 j置-1
</span><span style="color:#75715e"></span>		j <span style="color:#f92672">=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
	<span style="color:#66d9ef">return</span> j;
}
</code></pre></div><h1 id="哈希">哈希</h1>
<h2 id="说明-6">说明</h2>
<p>我们使用一个下标范围比较大的数组来存储元素。</p>
<h2 id="基本思想-6">基本思想</h2>
<p>可以设计一个函数（哈希函数， 也叫做散列函数），使得每个元素的关键字都与一个函数值（即数组下标）相对应，于是用这个数组单元来存储这个元素；也可以简单的理解为，按照关键字为每一个元素&quot;分类&quot;，然后将这个元素存储在相应&quot;类&quot;所对应的地方。但是，不能够保证每个元素的关键字与函数值是一一对应的，因此极有可能出现对于不同的元素，却计算出了相同的函数值，这样就产生了&quot;冲突&quot;，换句话说，就是把不同的元素分在了相同的&quot;类&quot;之中。后面我们将看到一种解决&quot;冲突&quot;的简便做法。</p>
<h2 id="代码-5">代码</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">#include</span><span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span><span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std;
 
<span style="color:#75715e">#define OK 1
</span><span style="color:#75715e"></span> 
 
<span style="color:#75715e">#define HASHSIZE 7 </span><span style="color:#75715e">/* 定义散列表长为数组的长度 */</span><span style="color:#75715e">
</span><span style="color:#75715e">#define NULLKEY -32768 
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">int</span> Status;
<span style="color:#66d9ef">typedef</span> <span style="color:#66d9ef">struct</span>
{
	<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>elem; <span style="color:#75715e">/* 数据元素存储地址，动态分配数组 */</span>
	<span style="color:#66d9ef">int</span> count; <span style="color:#75715e">/*  当前数据元素个数 */</span>
}HashTable;
 
<span style="color:#66d9ef">int</span> m <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">/* 散列表表长，全局变量 */</span>
 
<span style="color:#75715e">/*初始化*/</span>
Status <span style="color:#a6e22e">Init</span>(HashTable <span style="color:#f92672">*</span>hashTable)
{
	<span style="color:#66d9ef">int</span> i;
 
	m <span style="color:#f92672">=</span> HASHSIZE;
	hashTable<span style="color:#f92672">-&gt;</span>elem <span style="color:#f92672">=</span> (<span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>)malloc(m<span style="color:#f92672">*</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">int</span>)); <span style="color:#75715e">//申请内存
</span><span style="color:#75715e"></span>	hashTable<span style="color:#f92672">-&gt;</span>count <span style="color:#f92672">=</span> m;
	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>m; i<span style="color:#f92672">++</span>)
	{
		hashTable<span style="color:#f92672">-&gt;</span>elem[i] <span style="color:#f92672">=</span> NULLKEY;
	}
	<span style="color:#66d9ef">return</span> OK;
}
 
<span style="color:#75715e">/*哈希函数(除留余数法)*/</span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Hash</span>(<span style="color:#66d9ef">int</span> data)
{
	<span style="color:#66d9ef">return</span> data<span style="color:#f92672">%</span>m;
}
 
<span style="color:#75715e">/*插入*/</span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Insert</span>(HashTable <span style="color:#f92672">*</span>hashTable, <span style="color:#66d9ef">int</span> data)
{
	<span style="color:#66d9ef">int</span> hashAddress <span style="color:#f92672">=</span> Hash(data); <span style="color:#75715e">//求哈希地址
</span><span style="color:#75715e"></span> 
	<span style="color:#75715e">//发生冲突
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (hashTable<span style="color:#f92672">-&gt;</span>elem[hashAddress] <span style="color:#f92672">!=</span> NULLKEY)
	{
		<span style="color:#75715e">//利用开放定址的线性探测法解决冲突
</span><span style="color:#75715e"></span>		hashAddress <span style="color:#f92672">=</span> (<span style="color:#f92672">++</span>hashAddress) <span style="color:#f92672">%</span> m;
	}
 
	<span style="color:#75715e">//插入值
</span><span style="color:#75715e"></span>	hashTable<span style="color:#f92672">-&gt;</span>elem[hashAddress] <span style="color:#f92672">=</span> data;
}
 
<span style="color:#75715e">/*查找*/</span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">Search</span>(HashTable <span style="color:#f92672">*</span>hashTable, <span style="color:#66d9ef">int</span> data)
{
	<span style="color:#66d9ef">int</span> hashAddress <span style="color:#f92672">=</span> Hash(data); <span style="color:#75715e">//求哈希地址
</span><span style="color:#75715e"></span> 
	<span style="color:#75715e">//发生冲突
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">while</span> (hashTable<span style="color:#f92672">-&gt;</span>elem[hashAddress] <span style="color:#f92672">!=</span> data)
	{
		<span style="color:#75715e">//利用开放定址的线性探测法解决冲突
</span><span style="color:#75715e"></span>		hashAddress <span style="color:#f92672">=</span> (<span style="color:#f92672">++</span>hashAddress) <span style="color:#f92672">%</span> m;
 
		<span style="color:#66d9ef">if</span> (hashTable<span style="color:#f92672">-&gt;</span>elem[hashAddress] <span style="color:#f92672">==</span> NULLKEY <span style="color:#f92672">||</span> hashAddress <span style="color:#f92672">==</span> Hash(data)) <span style="color:#66d9ef">return</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>;
	}
 
	<span style="color:#75715e">//查找成功
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">return</span> hashAddress;
}
 
<span style="color:#75715e">/*打印结果*/</span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">Display</span>(HashTable <span style="color:#f92672">*</span>hashTable)
{
	<span style="color:#66d9ef">int</span> i;
	cout <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;**********展示结果**********&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
 
	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>hashTable<span style="color:#f92672">-&gt;</span>count; i<span style="color:#f92672">++</span>)
	{
		cout <span style="color:#f92672">&lt;&lt;</span> hashTable<span style="color:#f92672">-&gt;</span>elem[i] <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;,&#34;</span>;
	}
 
	cout <span style="color:#f92672">&lt;&lt;</span> endl;
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;**********展示完毕**********&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
	<span style="color:#66d9ef">int</span> i, j, result, key;
	HashTable hashTable;
	<span style="color:#66d9ef">int</span> arr[HASHSIZE] <span style="color:#f92672">=</span> { <span style="color:#ae81ff">13</span>, <span style="color:#ae81ff">29</span>, <span style="color:#ae81ff">27</span>, <span style="color:#ae81ff">28</span>, <span style="color:#ae81ff">26</span>, <span style="color:#ae81ff">30</span>, <span style="color:#ae81ff">38</span> };
 
	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;***************哈希查找(C++版)***************&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
 
	<span style="color:#75715e">//初始化哈希表
</span><span style="color:#75715e"></span>	Init(<span style="color:#f92672">&amp;</span>hashTable);
 
	<span style="color:#75715e">//插入数据
</span><span style="color:#75715e"></span>	<span style="color:#66d9ef">for</span> (i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i<span style="color:#f92672">&lt;</span>HASHSIZE; i<span style="color:#f92672">++</span>)
	{
		Insert(<span style="color:#f92672">&amp;</span>hashTable, arr[i]);
	}
	Display(<span style="color:#f92672">&amp;</span>hashTable);
 
	<span style="color:#75715e">//查找数据
</span><span style="color:#75715e"></span>	cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;请键入key值：&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	cin <span style="color:#f92672">&gt;&gt;</span> key;
	result <span style="color:#f92672">=</span> Search(<span style="color:#f92672">&amp;</span>hashTable, key);
	<span style="color:#66d9ef">if</span> (result <span style="color:#f92672">==</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;对不起，没有找到！&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
	<span style="color:#66d9ef">else</span> cout <span style="color:#f92672">&lt;&lt;</span> key <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;在哈希表中的位置是:&#34;</span> <span style="color:#f92672">&lt;&lt;</span> result <span style="color:#f92672">&lt;&lt;</span> endl;
	getchar();
	system(<span style="color:#e6db74">&#34;pause&#34;</span>);
	<span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div>
    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Jiang . </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://jfy0o0.github.io/2020/algorithm-%E4%B8%83%E5%A4%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/>https://jfy0o0.github.io/2020/algorithm-%E4%B8%83%E5%A4%A7%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://jfy0o0.github.io/tags/algorithm/">
                    #Algorithm</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://jfy0o0.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://jfy0o0.github.io/2020/algorithm_%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/" class="prev" rel="prev" title="Algorithm - 十大排序算法"><i class="iconfont icon-left"></i>&nbsp;Algorithm - 十大排序算法</a>
         
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2011 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://jfy0o0.github.io">Jiang .</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
