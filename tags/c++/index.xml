<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>c&#43;&#43; on Jiang . &#39;s blog</title>
    <link>https://jfy0o0.github.io/tags/c&#43;&#43;/</link>
    <description>Recent content in c&#43;&#43; on Jiang . &#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 27 Aug 2021 08:38:24 +0800</lastBuildDate><atom:link href="https://jfy0o0.github.io/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>C&#43;&#43; - 性能测试</title>
      <link>https://jfy0o0.github.io/2021/cpp_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</link>
      <pubDate>Fri, 27 Aug 2021 08:38:24 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/cpp_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/</guid>
      <description>锁 未加锁 int MAX_CNT = 1000 * 10000; bool run = true; int gTestN = 0; TIME_COST([&amp;amp;](){ while (run) { gTestN++; if (gTestN &amp;gt; MAX_CNT) { run = false; } } }) // 23 ms 单线程加锁 int MAX_CNT = 1000 * 10000; bool run = true; int gTestN = 0; mutex m ; TIME_COST([&amp;amp;]() { while (run) { m.lock(); gTestN++; if (gTestN &amp;gt; MAX_CNT) { run = false; } m.unlock(); } }) // 187ms &amp;lt;---&amp;gt; 100 0000  // 187 000 μs &amp;lt;---&amp;gt; 100 0000  // 187 000 000 ns &amp;lt;---&amp;gt; 100 0000  // 187 ns &amp;lt;---&amp;gt; 1 多线程加锁 int MAX_CNT = 1000 * 10000; bool run = true; int gTestN = 0; thread th1 ([&amp;amp;]() { TIME_COST([&amp;amp;]() { while (run) { m.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - 并发详解</title>
      <link>https://jfy0o0.github.io/2021/cpp_%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/</link>
      <pubDate>Fri, 13 Aug 2021 10:14:55 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/cpp_%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/</guid>
      <description>线程 创建线程 创建线程非常的简单的，下面就是一个使用了多线程的Hello World示例：
// 01_hello_thread.cpp  #include &amp;lt;iostream&amp;gt;#include &amp;lt;thread&amp;gt; // ① using namespace std; // ②  void hello() { // ③  cout &amp;lt;&amp;lt; &amp;#34;Hello World from new thread.&amp;#34; &amp;lt;&amp;lt; endl; } int main() { thread t(hello); // ④  t.join(); // ⑤  return 0; } 对于这段代码说明如下：
 为了使用多线程的接口，我们需要#include 头文件。 为了简化声明，本文中的代码都将using namespace std;。 新建线程的入口是一个普通的函数，它并没有什么特别的地方。 创建线程的方式就是构造一个thread对象，并指定入口函数。与普通对象不一样的是，此时编译器便会为我们创建一个新的操作系统线程，并在新的线程中执行我们的入口函数。 关于join函数在下文中讲解。  int main() { thread t([] { cout &amp;lt;&amp;lt; &amp;#34;Hello World from lambda thread.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - 标准属性</title>
      <link>https://jfy0o0.github.io/2021/cpp_%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7/</link>
      <pubDate>Sat, 20 Feb 2021 15:06:32 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/cpp_%E6%A0%87%E5%87%86%E5%B1%9E%E6%80%A7/</guid>
      <description>标准属性  C++11后引入了 C++ 标准属性。在 C++ 11 中，属性提供一种标准化的方法添加批注的其他信息，也可能不是特定于供应商的 C++ 构造 （包括但不是限于类、 函数、 变量和块）。 用于生成信息性消息，或应用特殊逻辑，编译特性化的代码时，编译器可以使用此信息。 编译器将忽略无法识别的任何属性，这意味着你不能定义自定义属性。 使用此语法，属性将由双方括号标明。     attribute-token 属性 值 标准 作用     carries_dependency [[carries_dependency]] 200809L (C++11) 指示释放消费 std::memory_order 中的依赖链传进和传出该函数，这允许编译器跳过不必要的内存栅栏指令。   noreturn [[noreturn]] 200809L (C++11) 表示函数不返回值,并只能应用在函数上面,如果函数真的有返回值，那么该属性无效,并且会给出警告   deprecated [[deprecated]] [[deprecated(“reason”)]] 201309L (C++14) 表示某些实体已经废弃，或者因为某些原因废弃，可以用在类，定义类型名，变量，非静态数据成员，枚举，模板实例   fallthrough [[fallthrough]] 201603L (C++17) 指示从前一 case 标号直落是有意的，而在发生直落时给出警告的编译器不应该为此诊断。   maybe_unused [[maybe_unused]] 201603L (C++17) 压制编译器在未使用实体上的警告，若存在。   nodiscard [[nodiscard]] [[nodiscard(“reason”)]] 201603L (C++17) (C++20) 若返回值被舍弃，则鼓励编译器发布警告。   likely [[likely]] 201803L C++20) 指示编译器应该针对通过某语句的执行路径比任何其他执行路径更可能或更不可能的情况进行优化。   unlikely [[unlikely]] 201803L (C++20) 指示编译器应该针对通过某语句的执行路径比任何其他执行路径更可能或更不可能的情况进行优化。   no_unique_address [[no_unique_address]] 201803L (C++20) 指示非静态数据成员不需要拥有不同于其类的所有其他非静态数据成员的地址。    </description>
    </item>
    
    <item>
      <title>C&#43;&#43; - openmp</title>
      <link>https://jfy0o0.github.io/2021/cpp_openmp/</link>
      <pubDate>Fri, 29 Jan 2021 10:49:45 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/cpp_openmp/</guid>
      <description>openmp 并行开发
标准并行模式执行代码的基本思想是，
 程序开始时只有一个主线程， 程序中的串行部分都由主线程执行， 并行的部分是通过派生其他线程来执行， 但是如果并行部分没有结束时是不会执行串行部分的  使用 1.头文件 #include &amp;lt;omp.h&amp;gt; 2.cmake add_link_options(-fopenmp)add_executable(test main.cpp)FIND_PACKAGE(OpenMP REQUIRED)if (OPENMP_FOUND) message(&amp;#34;OPENMP FOUND&amp;#34;) set(CMAKE_C_FLAGS &amp;#34;${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}&amp;#34;) set(CMAKE_CXX_FLAGS &amp;#34;${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}&amp;#34;)endif ()指令格式 在C++中，OpenMP的指令格式为：
＃pragma omp 指令 [子句[子句]…] **例如： **
#pragma omp parallel private(i, j) parallel 就是指令， private是子句
1. OpenMP的指令 OpenMP的指令有以下一些：（常用的已标黑）
 parallel，用在一个代码段之前，表示这段代码将被多个线程并行执行 for，用于for循环之前，将循环分配到多个线程中并行执行，必须保证每次循环之间无相关性。 parallel for， parallel 和 for语句的结合，也是用在一个for循环之前，表示for循环的代码将被多个线程并行执行。 sections，用在可能会被并行执行的代码段之前 parallel sections，parallel和sections两个语句的结合 critical，用在一段代码临界区之前 single，用在一段只被单个线程执行的代码段之前，表示后面的代码段将被单线程执行。 flush， barrier，用于并行区内代码的线程同步，所有线程执行到barrier时要停止，直到所有线程都执行到barrier时才继续往下执行。 atomic，用于指定一块内存区域被制动更新 master，用于指定一段代码块由主线程执行 ordered， 用于指定并行区域的循环按顺序执行 threadprivate, 用于指定一个变量是线程私有的。  例子1：
#include &amp;lt;iostream&amp;gt;#include &amp;#34;omp.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - c&#43;&#43;17特性</title>
      <link>https://jfy0o0.github.io/2021/cpp_17%E7%89%B9%E6%80%A7/</link>
      <pubDate>Thu, 28 Jan 2021 17:05:27 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/cpp_17%E7%89%B9%E6%80%A7/</guid>
      <description>c++17特性 1.关键字 1. auto关键字 从c++11开始，auto关键字能够通过初始化器推导出变量的类型。在c++14中，auto关键字的能力进一步提升，能够通过return语句推导出函数的返回类型。 使用auto关键字能够提高编码效率，同时能够简化重构流程。但是，C++11中的auto推导，往往结果与预期的不同。
c++11 中为了支持统一初始化，引入了新的统一初始化语法，如下所示。
// c++11 auto x3{ 1, 2 }; // std::initializer_list&amp;lt;int&amp;gt; auto x4 = { 3 }; // decltype(x4) is std::initializer_list&amp;lt;int&amp;gt; auto x5{ 3 }; // std::initializer_list&amp;lt;int&amp;gt; 这三种方式初始化的变量，最终类型推导的结果都是 std::initializer_list ， 而不是我们认为的int。 这是因为 当用于auto声明变量的表达式是{}括起来的，推导的型别就会变成 std::initializer_list。
在C++17中，对auto表达式推导的规则进行了改变
// c++17 auto x3{ 1, 2 }; // error: not a single element auto x4 = { 3 }; // decltype(x4) is std::initializer_list&amp;lt;int&amp;gt; auto x5{ 3 }; // decltype(x5) is int 对比发现， auto x5{3}, 会直接将变量推导成 x5， 而 x3{1, 2} 这种方式也会编译失败。auto推导的规则变得更加直观。</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - c&#43;&#43;14特性</title>
      <link>https://jfy0o0.github.io/2021/cpp_14%E7%89%B9%E6%80%A7/</link>
      <pubDate>Thu, 28 Jan 2021 16:35:46 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/cpp_14%E7%89%B9%E6%80%A7/</guid>
      <description>C++14 Lambda 函数 C++14 的泛型 Lambda 使编写如下语句成为可能：
auto lambda = [](auto x， auto y) {return x + y;}; 而另一方面，C++11 要求 Lambda 参数使用具体的类型声明，比如：
auto lambda = [](int x， int y) {return x + y;}; 此外，新标准中的 std::move 函数可用于捕获 Lambda 表达式中的变量，这是通过移动对象而非复制或引用对象实现的：
std::unique_ptr ptr (new int (10)); auto lambda = [value = std::move (ptr)] {return *value;}; int a = 2; [a = sin(a)]() { cout &amp;lt;&amp;lt; cos(a) &amp;lt;&amp;lt; endl; //0.6143 	}(); cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl; //2 	cout &amp;lt;&amp;lt; cos(a) &amp;lt;&amp;lt; endl;//-0.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - c&#43;&#43;11特性</title>
      <link>https://jfy0o0.github.io/2021/cpp_11%E7%89%B9%E6%80%A7/</link>
      <pubDate>Thu, 28 Jan 2021 15:31:27 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2021/cpp_11%E7%89%B9%E6%80%A7/</guid>
      <description>C++11 特性 1 变量和基本类型 1.1 long long 类型 扩展精度浮点数，10位有效数字
1.2 列表初始化 初始化的几种不同形式，其中用花括号来初始化变量称为列表初始化；
int i = 0; int i = {0}; int i{0}; int i(0);  需要注意的是，当用于内置类型的变量时，这种初始化形式有一个重要的特点： 如果我们使用初始化且初始值存在丢失信息的风险，则编译器报错；  long double ld = 3.1414141414; int a{ld}, b = {ld}; //报错 int c(ld), d = ld; //正确 1.3 nullptr 常量 int *p1 = nullptr; // 等价于int *p1 = 0; 1.4 constexpr 变量 将变量声明为constexpr类型以便由编译器来验证变量的值是否是一个常量表达式；
声明为constexpr的变量一定是一个常量，而且必须用常量表达式来初始化，比如说下面的情况则是不正确的：
int t = 10; constexpr int q = t + 20; cout &amp;lt;&amp;lt; &amp;#34;q&amp;#34; &amp;lt;&amp;lt; q &amp;lt;&amp;lt; endl; 需要将t声明为 const 才是正确的；</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - shared_ptr陷阱</title>
      <link>https://jfy0o0.github.io/2020/cpp_shared_ptr%E9%99%B7%E9%98%B1/</link>
      <pubDate>Thu, 24 Dec 2020 19:55:07 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_shared_ptr%E9%99%B7%E9%98%B1/</guid>
      <description>1：不要把一个原生指针给多个shared_ptr管理 int* ptr = new int; shared_ptr&amp;lt;int&amp;gt; p1(ptr); shared_ptr&amp;lt;int&amp;gt; p2(ptr); //logic error  ptr对象被删除了2次 这种问题比喻成“二龙治水”，在原生指针中也同样可能发生。  2：不要把this指针给shared_ptr #include &amp;lt;memory&amp;gt;#include &amp;lt;iostream&amp;gt; class Bad { public: std::shared_ptr&amp;lt;Bad&amp;gt; getptr() { return std::shared_ptr&amp;lt;Bad&amp;gt;(this); } ~Bad() { std::cout &amp;lt;&amp;lt; &amp;#34;Bad::~Bad() called&amp;#34; &amp;lt;&amp;lt; std::endl; } }; int main() { // 错误的示例，每个shared_ptr都认为自己是对象仅有的所有者 	std::shared_ptr&amp;lt;Bad&amp;gt; bp1(new Bad()); std::shared_ptr&amp;lt;Bad&amp;gt; bp2 = bp1-&amp;gt;getptr(); // 打印bp1和bp2的引用计数 	std::cout &amp;lt;&amp;lt; &amp;#34;bp1.use_count() = &amp;#34; &amp;lt;&amp;lt; bp1.use_count() &amp;lt;&amp;lt; std::endl; std::cout &amp;lt;&amp;lt; &amp;#34;bp2.use_count() = &amp;#34; &amp;lt;&amp;lt; bp2.</description>
    </item>
    
    <item>
      <title>Boost - asio</title>
      <link>https://jfy0o0.github.io/2020/boost-asio/</link>
      <pubDate>Thu, 24 Dec 2020 15:01:01 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-asio/</guid>
      <description>asio  Boost.Asio是一个跨平台的C++库，主要用于网络和其他一些底层的I/O编程。 Boost.Asio成功的抽象了包括网络，串口、文件在内的同步和异步的I/O操作： Boost.Asio支持大多数操作系统，轻量可扩展的，目前网络部分支持TCP, UDP, IMCP，可以很方便的扩展自定义协议。  注意  把lambda表达式声明成类得成员变量 ，而不是一个局部变量。 虽然io_service拷贝handler以备异步调用，但是handler还引用了作为外部变量得自身，而io_service是不知道外部变量得，也就不会拷贝。 如果lambda表达式是一个函数内局部变量，那离开函数作用域 就会消失，io_service执行handler时候就会发生错误。  asio程序优雅的退出  Server对象还监听信号量，从而优雅的退出。 signal_set.async_wait(SignalHandler handler) void handler(const system::error_code&amp;amp;ec , int signal_number)  #include &amp;lt;cstdlib&amp;gt;#include &amp;lt;boost/asio.hpp&amp;gt;#include &amp;lt;boost/bind.hpp&amp;gt;#include &amp;lt;iostream&amp;gt; using namespace boost; using namespace boost::asio; using namespace std; class Server { public: Server(io_service &amp;amp; s) : io_(s), signals_(s) { signals_.add(SIGINT); signals_.add(SIGTERM); #if defined(SIGQUIT)  signals_.add(SIGQUIT); #endif  signals_.async_wait(boost::bind(&amp;amp;Server::stop, this)); } void run() { io_.run(); } private: void stop() { cout &amp;lt;&amp;lt; &amp;#34;x&amp;#34; &amp;lt;&amp;lt; endl; io_.</description>
    </item>
    
    <item>
      <title>Boost - log</title>
      <link>https://jfy0o0.github.io/2020/boost-log/</link>
      <pubDate>Wed, 23 Dec 2020 13:47:22 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-log/</guid>
      <description>log 简易demo  -lboost_log -lboost_system -lboost_thread -lboost_filesystem -DBOOST_LOG_DYN_LINK 输出所有信息到控制台  #include &amp;lt;iostream&amp;gt;#include &amp;lt;boost/log/trivial.hpp&amp;gt; using namespace std; namespace logging = boost::log; namespace sinks = boost::log::sinks; namespace src = boost::log::sources; namespace expr = boost::log::expressions; namespace attrs = boost::log::attributes; namespace keywords = boost::log::keywords; static void simple_example() { BOOST_LOG_TRIVIAL(trace) &amp;lt;&amp;lt; &amp;#34;A trace severity message&amp;#34;; BOOST_LOG_TRIVIAL(debug) &amp;lt;&amp;lt; &amp;#34;A debug severity message&amp;#34;; BOOST_LOG_TRIVIAL(info) &amp;lt;&amp;lt; &amp;#34;An informational severity message&amp;#34;; BOOST_LOG_TRIVIAL(warning) &amp;lt;&amp;lt; &amp;#34;A warning severity message&amp;#34;; BOOST_LOG_TRIVIAL(error) &amp;lt;&amp;lt; &amp;#34;An error severity message&amp;#34;; BOOST_LOG_TRIVIAL(fatal) &amp;lt;&amp;lt; &amp;#34;A fatal severity message&amp;#34;; } 设置filter #include &amp;lt;boost/log/core.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - STL源码剖析 - traits技术</title>
      <link>https://jfy0o0.github.io/2020/cpp_stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-traits%E6%8A%80%E6%9C%AF/</link>
      <pubDate>Mon, 21 Dec 2020 18:45:25 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-traits%E6%8A%80%E6%9C%AF/</guid>
      <description>概念  之前已经介绍过迭代器，知道了不同的数据结构都有自己专属的迭代器，不同的迭代器也有不同的特性，由于算法的接口是统一的，通过迭代器的不同属性，算法自动选择正确的执行流程，在完全任务的同时，也尽可能提高算法的执行效率。 那算法如何获知迭代器的属性呢？这一光荣的任务就是traits完成的。 在STL实现中，traits编程技术得到大量的运用，它利用了“内嵌类型”的编程技巧与C++的template参数推导功能，弥补了C++类型识别方面的不足。 通过traits，算法可以原汁原味的将迭代器的属性萃取出来，帮助算法正确高效的运行。  引子 1.以迭代器所指对象的类型声明局部变量 下面是一个以迭代器为模板形参的函数模板：
template&amp;lt;typename Iterator&amp;gt; void func(Iterator iter) { //函数体 } 假如现在算法中需要声明一个变量，而变量的类型是迭代器所指对象的类型，应该怎么处理呢？
template&amp;lt;typename Iterator&amp;gt; void func(Iterator iter) { *Iterator var;//这样定义变量可以吗？ } 上面的代码是不可以通过编译的，虽然C++支持sizeof()，但是并不支持typeof()，就算是用到RTTI性质中的typeid()，获取到的也仅仅是类型的名字，因此不能直接用来声明变量。此时可以利用函数模板的参数类型推导机制解决问题，例如：
template&amp;lt;typename Iterator, typename T&amp;gt; void func_impl(Iterator iter, T t) { T temp;//这里就解决了问题  //这里做原本func()的工作 } template&amp;lt;typename Iterator&amp;gt; void func(Iterator iter) { func_impl(iter, *iter);//func的工作全部都移到func_impl里面了 } int main(int argc, const char *argv[]) { int i; func(&amp;amp;i); }  函数func作为对外接口，实际的操作却由函数func_impl执行，通过函数func_impl的参数类型推导，获取到Iterator指向对象的类型T，从而解决了问题。  2.以迭代器所指对象的类型声明返回类型 ​ 现在通过函数模板的参数类型推导解决了函数体内声明变量的问题，但问题又来了，如果需要返回类型是迭代器所指对象的类型又可以怎样做呢？</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - STL源码剖析 - 迭代器</title>
      <link>https://jfy0o0.github.io/2020/cpp_stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E8%BF%AD%E4%BB%A3%E5%99%A8/</link>
      <pubDate>Mon, 21 Dec 2020 17:13:11 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E8%BF%AD%E4%BB%A3%E5%99%A8/</guid>
      <description>迭代器作用  在设计模式中有一种模式叫迭代器模式，简单来说就是提供一种方法，在不需要暴露某个容器的内部表现形式情况下，使之能依次访问该容器中的各个元素， 这种设计思维在STL中得到了广泛的应用，是STL的关键所在，通过迭代器，容器和算法可以有机的粘合在一起，只要对算法给予不同的迭代器，就可以对不同容器进行相同的操作。 在这里提到了一个叫迭代器的东西，说得简单一点，就是一种指针，学习C和C++的同学肯定不会对指针感到陌生，这确实是个让我们又爱又恨的东西。 以下以算法find为例，展示了容器、算法和迭代器如何合作：  template&amp;lt;typename InputIterator, typename T&amp;gt; InputIterator find(InputIterator first, InputIterator last, const T &amp;amp;value) { while (first != last &amp;amp;&amp;amp; *frist != value) ++first; return first; } 迭代器是一种智能指针  它将指针进行了一层封装，既包含了原生指针的灵活和强大，也加上很多重要的特性，使其能发挥更大的作用以及能更好的使用。 迭代器对指针的一些基本操作如*、-&amp;gt;、++、==、!=、=进行了重载，使其具有了遍历复杂数据结构的能力，其遍历机制取决于所遍历的数据结构。 下面上一段代码，了解一下迭代器的“智能”：  对于不同的数据容器，以上Iterator类中的成员函数operator++的实现会各不相同，
例如，对于数组的可能实现如下：
//对于数组的实现 template&amp;lt;typename T&amp;gt; Iterator&amp;amp; operator++() { ++m_ptr; retrun *this; } 对于链表，它会有一个类似于next的成员函数用于获取下一个结点，其可能实现如下：
//对于链表的实现 template&amp;lt;typename T&amp;gt; Iterator&amp;amp; operator++() { m_ptr = m_ptr-&amp;gt;next();//next()用于获取链表的下一个节点  return *this; } 不同的容器都有专属的迭代器 下面尝试实现一个自己的迭代器，由于迭代器的作用对象是容器，因此需要首先实现一个容器，下面代码展示了一个
单向链表的实现： template&amp;lt;typename T&amp;gt; class ListItem { public: ListItem() { m_pNext = 0;} ListItem(T v, ListItem *p = 0) { m_value = v; m_pNext = p;} T Value() const { return m_value;} ListItem* Next() const { return m_pNext;} private: T m_value;	//存储的数据  ListItem* m_pNext;	//指向下一个ListItem的指针 }; template&amp;lt;typename T&amp;gt; class List { public: //从链表尾部插入元素  void Push(T value) { m_pTail = new ListItem&amp;lt;T&amp;gt;(value); m_pTail = m_pTail-&amp;gt;Next(); } //打印链表元素  void Print(std::ostream &amp;amp;os = std::cout) const {	for (ListItem&amp;lt;T&amp;gt; *ptr = m_pHead; ptr; ptr = ptr-&amp;gt;Next()) os&amp;lt;&amp;lt;ptr-&amp;gt;Value&amp;lt;&amp;lt;&amp;#34; &amp;#34;; os&amp;lt;&amp;lt;endl; } //返回链表头部指针  ListItem&amp;lt;T&amp;gt;* Begin() const { return m_pHead;} //返回链表尾部指针  ListItem&amp;lt;T&amp;gt;* End() const { return 0;} //其它成员函数  private： ListItem&amp;lt;T&amp;gt; *m_pHead; //指向链表头部的指针  ListItem&amp;lt;T&amp;gt; *m_pTail; //指向链表尾部的指针  long m_nSize; //链表长度 }; 迭代器实现： template&amp;lt;typename T&amp;gt; class ListIter { public: ListIter(T *p = 0) : m_ptr(p){} //解引用，即dereference  T&amp;amp; operator*() const { return *m_ptr;} //成员访问，即member access  T* operator-&amp;gt;() const { return m_ptr;} //前置++操作  ListIter&amp;amp; operator++() { m_ptr = m_ptr-&amp;gt;Next(); //暴露了ListItem的东西  return *this; } //后置++操作  ListIter operator++(int) { ListIter temp = *this; ++*this; return temp; } //判断两个ListIter是否指向相同的地址  bool opeartor==(const ListIter &amp;amp;arg) const { return arg.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - STL源码剖析 - 空间配置器</title>
      <link>https://jfy0o0.github.io/2020/cpp_stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/</link>
      <pubDate>Mon, 21 Dec 2020 16:14:02 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_stl%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90-%E7%A9%BA%E9%97%B4%E9%85%8D%E7%BD%AE%E5%99%A8/</guid>
      <description>空间配置器 前言 在STL中，容器的定义中都带一个模板参数，如vector
template &amp;lt;class T, class Alloc = alloc&amp;gt; class vector {...} 其中第二个参数就是该容器使用的空间配置器，其中缺省使用STL已经实现的空间配置器(alloc)，
该配置器使用malloc/free等为vector分配内存。
#include &amp;lt;vector&amp;gt; int main() { std::vector&amp;lt;int&amp;gt; v; // Do something; return 0; }  从用户代码std::vector&amp;lt;int&amp;gt; v;开始，vector的模板参数class T被替换为int， 同时第二个模板参数因为没有指定，所以为默认模板参数，即allocator&amp;lt;int&amp;gt;， 这个vector对象v会在内部实例一个allocator&amp;lt;int&amp;gt;的对象，用来管理内存。  假设我们自己写了一个allocator，叫做my_alloc，就可以指定它来为vector分配空间：
allocator 标准接口 这是STL标准要求的allocator必要接口：
// 以下几种自定义类型是一种type_traits技巧，暂时不需要了解 allocator::value_type allocator::pointer allocator::const_pointer allocator::reference allocator::const_reference allocator::size_type allocator::difference // 一个嵌套的(nested)class template，class rebind&amp;lt;U&amp;gt;拥有唯一成员other，那是一个typedef，代表allocator&amp;lt;U&amp;gt; allocator::rebind allocator::allocator() // 默认构造函数 allocator::allocator(const allocator&amp;amp;) // 拷贝构造函数 template &amp;lt;class U&amp;gt;allocator::allocator(const allocator&amp;lt;U&amp;gt;&amp;amp;) // 泛化的拷贝构造函数 allocator::~allocator() // 析构函数  // 返回某个对象的地址，a.</description>
    </item>
    
    <item>
      <title>Boost - pool</title>
      <link>https://jfy0o0.github.io/2020/boost-pool/</link>
      <pubDate>Tue, 15 Dec 2020 20:19:51 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-pool/</guid>
      <description>内存池  boost的内存池实现了一个快速、紧凑的内存分配和管理器，使用它可以完全不用考虑delete释放问题。 常用的boost内存池有pool、object_pool、singleton_pool。  pool 说明  pool是一个简单的内存池类，它的模板类型通常使用默认的参数，构造函数的参数用来指定每次分配内存的大小，这个值可以通过成员get_requested_size()获得。 pool会根据需要自动向系统申请或归还使用的内存，在其析构的时候自动释放它持有的所有内存。常用的成员函数： malloc()：分配一块内存，返回类型为void*，内存分配失败返回NULL。 ordered_malloc()：分配一块内存并合并空闲块链表，不推荐使用该函数，因为其效率低。 is_from()：测试内存块是否属于本内存池。 free()：释放malloc()非配的内存，不建议调用该函数来手动释放内存，因为pool是自动管理内存分配的。 release_memory()：释放所有未被分配的内存。 purge_memory()：强制释放pool持有的所有内存。  使用 #include &amp;lt;iostream&amp;gt;using namespace std; #include &amp;#34;boost\pool\pool.hpp&amp;#34;using namespace boost; int main() { pool&amp;lt;&amp;gt; p1(sizeof(int)); int* p = (int*)p1.malloc(); //int *p = static_cast&amp;lt;int *&amp;gt;(p1.malloc()); 	BOOSTASSERT(p) *p = 10; cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl; return 0; } object_pool 说明  object_pool是类实例的内存池，其模板类型的参数用来指定使用的类， 其成员construct()用来分配一个类的对象，destroy()用来释放一个已分配的对象，is_from()用来测试对象是否属于本内存池分配的。  需要注意的三点：
 默认情况下成员函数construct最多支持3个参数，可以对construct进行扩展以支持3个参数以上的构造函数，具体扩展方法可参见罗剑锋的《Boost程序库完全开发指南》一书。 object_pool的成员函数destroy()效率很低，如果需要频繁释放已分配的对象的话谨慎考虑object_pool。 object_pool还提供了malloc()和free()成员，其可以像pool那样来分配和释放内存块。  使用 #include &amp;lt;iostream&amp;gt;#include &amp;lt;string&amp;gt;using namespace std; #include &amp;#34;boost\pool\object_pool.</description>
    </item>
    
    <item>
      <title>Boost - filesystem</title>
      <link>https://jfy0o0.github.io/2020/boost-filesystem/</link>
      <pubDate>Tue, 15 Dec 2020 20:05:43 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-filesystem/</guid>
      <description>filesystem 说明  filesystem库是文件系统操作库，可以使用其中的basic_path类用来操作目录、文件，使用需要包含编译好的system库和filesystem库，我们一般不直接使用basic_path，而是使用typedef : path和wpath。 使用它需要包含&amp;quot;boost/filesystem.hpp&amp;quot;。  使用 boost::filesystem::path p1(&amp;#34;D:\\dir&amp;#34;); //windows下既可使用斜杠也可使用反斜杠（资源管理器地址栏中使用的就是反斜杠），又因为在c++中反斜杠是转义字符的标志，所以使用反斜杠的话还得再加一个反斜杠  boost::filesystem::path p2(&amp;#34;D:/dir/data.dat&amp;#34;); //windows下推荐使用正斜杠  boost::filesystem::path p3(&amp;#34;/user/dir&amp;#34;); //linux下使用正斜杠  boost::filesystem::path p4 = &amp;#34;./dir&amp;#34;; //path的构造函数没有声明为explicit，字符串可以隐式转换为path对象  p1 /= &amp;#34;child&amp;#34;; //path重载了 /=，其功能与成员append()相同。  cout &amp;lt;&amp;lt; p1 &amp;lt;&amp;lt; endl; //支持流输出操作，输出为&amp;#34;D:\dir\child&amp;#34;  if (p1 == p2); //支持比较操作  auto iter = p1.begin(); //支持迭代器来迭代其中的字符串  std::string strDir = p1.string(); //获取字符串（构造函数中传入的字符串为相对路径的话这里也是相对路径）  bool bRes = boost::filesystem::portable_posix_name(strDir); //判断是否符合posix文件命名规范  boost::filesystem::windows_name(strDir); //判断是否符合windows文件命名规范  boost::filesystem::portable_name(strDir); //相当于portable_posix_name() &amp;amp;&amp;amp; windows_name  boost::filesystem::native(strDir); //在windows下相当于windows_name，其它操作系统下只是简单的判断文件名不是空格且不含斜杠  boost::filesystem::path parentPath = p3.</description>
    </item>
    
    <item>
      <title>Boost - 同步</title>
      <link>https://jfy0o0.github.io/2020/boost-%E5%90%8C%E6%AD%A5/</link>
      <pubDate>Tue, 15 Dec 2020 19:51:16 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E5%90%8C%E6%AD%A5/</guid>
      <description>互斥锁（互斥量） 说明  mutex是独占式的互斥锁。timed_mutex增加了超时功能。 成员函数：lock()用于锁定，try_lock()为非阻塞版本的锁定，unlock()用于解锁。timed_lock()只属于timed_mutex，它可以等待一定的时间，等待的时间可以是一个时间段，也可以是指定的时间。 使用方法：使用mutex必须配合try-catch块以保证解锁互斥量，eg：  使用 #include &amp;#34;boost\thread.hpp&amp;#34; int main() { boost::mutex mu; try { mu.lock(); cout &amp;lt;&amp;lt; &amp;#34;Need to be protected&amp;#34; &amp;lt;&amp;lt; endl; //io流是个共享资源，多线程内使用的话需要同步  mu.unlock(); } catch (...) { mu.unlock(); } return 0; } mutex还提供了一系列的RAII型的互斥锁，用于取消麻烦的try-catch块，它会在构造的时候锁定互斥量，析构时自动解锁，eg：
#include &amp;#34;boost\thread.hpp&amp;#34; int main() { boost::mutex mu; boost::mutex::scoped_lock lock(mu); cout &amp;lt;&amp;lt; &amp;#34;Need to be protected&amp;#34; &amp;lt;&amp;lt; endl; //io流是个共享资源，多线程内使用的话需要同步  return 0; } 递归锁 说明 recursive_mutex是递归锁，可以多次锁定，相应的也要多次解锁。recursive_timed_mutex增加了超时功能。递归锁的使用接口跟互斥锁基本相同。
读写锁 说明  shared_mutex是读写锁，提供了multiple-reader / single-writer功能。 读取锁定时我们使用shared_lock&amp;lt;shared_mutex&amp;gt;对象，写入锁定时我们使用unique_lock&amp;lt;shared_mutex&amp;gt;对象：  使用 boost::shared_mutex rw_mu; //read thread  { boost::shared_lock&amp;lt;boost::shared_mutex&amp;gt; sl(rw_mu); //读锁定  //.</description>
    </item>
    
    <item>
      <title>Boost - thread</title>
      <link>https://jfy0o0.github.io/2020/boost-thread/</link>
      <pubDate>Tue, 15 Dec 2020 19:44:34 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-thread/</guid>
      <description>thread 说明  静态函数this_thread::get_id()可以获得当前线程的线程ID。 静态函数thread::this_thread::sleep()可以让当前线程睡眠一段时间或到指定时间， 静态函数thread::hardware_concurrency()可以获得当前CPU的内核数量。 静态函数this_thread::yield()指示当前线程放弃时间片，允许其他线程运行。  简易使用 #include &amp;#34;boost\thread.hpp&amp;#34; void PrintThreadFunc(const int&amp;amp; n, const string&amp;amp; str) { cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; n &amp;lt;&amp;lt; endl; } int main() { int n1 = 1; string str1 = &amp;#34;hello&amp;#34;; boost::thread t1(PrintThreadFunc, ref(n1), ref(str1)); int n2 = 2; string str2 = &amp;#34;boost&amp;#34;; function&amp;lt;void()&amp;gt; fun = bind(PrintThreadFunc, ref(n2), ref(str2)); boost::thread t2(fun); t1.timed_join(boost::posix_time::seconds(1)); //最多等待1秒  t2.join(); //一直等待  return 0; } 中断线程 线程内部 void ThreadFun() try { //函数体 } catch (boost::thread_interrupted&amp;amp;) { //异常处理 } 线程外部 t.</description>
    </item>
    
    <item>
      <title>Boost - signals2</title>
      <link>https://jfy0o0.github.io/2020/boost-signals2/</link>
      <pubDate>Tue, 15 Dec 2020 19:40:22 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-signals2/</guid>
      <description>signals2 概念  插槽可以是函数指针、函数对象、bind表达式、function对象。调用signals的成员函数connect()来将插槽连接到信号上，相当于为信号注册一个处理的handler。对signal对象调用()即为产生一个信号（signal提供了operator()），从而导致连接的所有插槽被调用。产生信号即调用signal的operator()的返回值是一个optional类型的对象，可以使用解引用操作符*来获得真正的返回值，而且默认情况下，这个返回值是最后被调用的插槽的返回值。signal会把参数传递给所有连接的插槽。 就像function一样，signal也是一个模板类，第一个模板参数是插槽函数类型签名，除了第一个模板参数外其他的模板参数都有缺省值，所以可以只传入第一个参数。 signal::connect()的第一个参数为一个插槽，第二个参数为插入的位置，插入位置决定了插槽的调用顺序，默认值为at_back往后插入，at_front为往前插入，返回值是一个connection对象，可以这个对象来管理连接，如断开连接(disconnect)、测试连接(connected)等。 其它成员函数： num_slots()用来获得连接的插槽的个数，empty()用来判断连接的插槽数量是否为0。 combiner()用来获取合并器，set_combiner()用来设置合并器，不过一般是在signal构造函数中直接设置合并器。 disconnect()用来断开连接，disconnect_all_slots()用来断开所有连接的插槽，signal对象析构时会自动调用disconnect_all_slots()。  #include &amp;#34;boost/signals2.hpp&amp;#34; int slots1(int n) { int iRet = n * n; cout &amp;lt;&amp;lt; &amp;#34;slot1 called, return value: &amp;#34; &amp;lt;&amp;lt; iRet &amp;lt;&amp;lt; endl; return iRet; } int slots2(int n, int x) { int iRet = n * n * x; cout &amp;lt;&amp;lt; &amp;#34;slot2 called, return value: &amp;#34; &amp;lt;&amp;lt; iRet &amp;lt;&amp;lt; endl; return iRet; } int slots3(int n) { int iRet = n * n; cout &amp;lt;&amp;lt; &amp;#34;slot3 called, return value: &amp;#34; &amp;lt;&amp;lt; iRet &amp;lt;&amp;lt; endl; return iRet; } int slots4(int n) { int iRet = n * n; cout &amp;lt;&amp;lt; &amp;#34;slot4 called, return value: &amp;#34; &amp;lt;&amp;lt; iRet &amp;lt;&amp;lt; endl; return iRet; } int main() { boost::signals2::signal&amp;lt;int(int)&amp;gt; sig; //sig.</description>
    </item>
    
    <item>
      <title>Boost - function</title>
      <link>https://jfy0o0.github.io/2020/boost-function/</link>
      <pubDate>Tue, 15 Dec 2020 19:34:56 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-function/</guid>
      <description>function 概念  function是一个模板类，它就像一个包装了函数指针或函数对象的容器（只有一个元素）。 可以把它想象成一个泛化的函数指针，而且他非常适合代替函数指针，存储用于回调的函数。 如下定义了一个能够容纳void(int)类型的function对象： 使用function需要包含头文件&amp;quot;boost/function.hpp&amp;quot;，C++11已经支持function。  function&amp;lt;void(int)&amp;gt; funo; 一些成员函数：
 target()：返回对象内部的可调用物Functor的指针，对象为空则返回NULL contains()：检测是否持有一个Functor。 clear()：将对象清空，与&amp;quot;= 0&amp;quot;效果相同。 empty()：测试对象是否为空，也可以在一个bool上下文中直接测试它是否为空。 operator==、operator!=：与一个函数或函数对象进行比较。 operator()：调用内部的可调用物，它也会将参数传给可调用物。  使用 int FuncName(int a, int b) { return a + b; } int main() { function&amp;lt;int(int, int)&amp;gt; funo; funo = FuncName; if (funo) { cout &amp;lt;&amp;lt; funo(3, 4) &amp;lt;&amp;lt; endl; } return 0; } 回调 void call_back_func(int i) { cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; endl; } class CTestClass { public: CTestClass(int i) :m_iNum(i) {} public: template&amp;lt;typename CallBack&amp;gt; void SetCallBack(CallBack f) { m_fFun = f; } void run() { if(m_fFun) m_fFun(m_iNum); } private: function&amp;lt;void(int)&amp;gt; m_fFun; int m_iNum; }; int main() { CTestClass dc(10); dc.</description>
    </item>
    
    <item>
      <title>Boost - bind</title>
      <link>https://jfy0o0.github.io/2020/boost-bind/</link>
      <pubDate>Tue, 15 Dec 2020 19:21:49 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-bind/</guid>
      <description>bind 概念  boost中的bind是bind1st/bind2nd的增强版，它也会返回一个函数对象，可以通过function来保存和调用。 bind()的第一个参数必须是一个可调用对象，比如函数、函数指针、函数对象，之后它最多接受九个参数。 占位符用来表示使用哪一个参数。boost中的bind位于头文件&amp;quot;boost/bind.hpp&amp;quot;中， c++11中已经增加了bind，头文件为，使用占位符的话需要其所在的命名空间：using namespace std::placeholders;  使用 绑定普通函数 #include &amp;lt;iostream&amp;gt;using namespace std; #include &amp;#34;boost/bind.hpp&amp;#34;#include &amp;#34;boost\function.hpp&amp;#34; void func1p(int num) { cout &amp;lt;&amp;lt; num &amp;lt;&amp;lt; endl; } void func3p(int a, int b, int c) { cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; b &amp;lt;&amp;lt; endl &amp;lt;&amp;lt; c &amp;lt;&amp;lt; endl; } int main() { int n = -1; //绑定变量n到func1p的参数：不用再传参；  boost::function&amp;lt;void()&amp;gt; fun = boost::bind(func1p, n); fun(); //输出-1  int x = 0, y = 5, z = 10; //绑定变量x到func3p的第一个参数：第一个参数直接使用x，不用传参；第二个参数使用实参列表的第一个参数；第三个参数使用实参列表的第二个参数  boost::function&amp;lt;void(int, int)&amp;gt; func = boost::bind(func3p, x, _1, _2); func(y, z); //输出0, 5, 10  //绑定变量y到func3p的第二个参数：第二个参数直接使用y，不用传参；第一个参数使用实参列表的第一个参数；第三个参数使用实参列表的第二个参数  func = boost::bind(func3p, _1, y, _2); func(x, z); //输出0, 5, 10  //绑定变量z到func3p的第三个参数：第三个参数直接使用z，不用传参；第一个参数使用实参列表的第一个参数；第二个参数使用实参列表的第二个参数  func = boost::bind(func3p, _1, _2, z); func(x, y); //输出0, 5, 10  return 0; } #include &amp;#34;boost/bind.</description>
    </item>
    
    <item>
      <title>Boost - ref</title>
      <link>https://jfy0o0.github.io/2020/boost-ref/</link>
      <pubDate>Tue, 15 Dec 2020 19:14:21 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-ref/</guid>
      <description>reference_wrapper 简介  reference_wrapper包含在ref库中，它是引用包装器类型，即其内部包装了引用。 成员函数get()、get_pointer()分别可以获得被包装的引用和其指针。使用需要包含头文件&amp;quot;boost/ref.hpp&amp;quot;。  eg #include &amp;#34;boost/ref.hpp&amp;#34;#include &amp;lt;cassert&amp;gt;int main() { int x = 5; boost::reference_wrapper&amp;lt;int&amp;gt; rw(x); rw.get() = 10; //获得引用  *rw.get_pointer() = 15; //获得指针  int n = rw; //隐式转换为int  assert(x == rw); //隐式转换为int  rw = 20; //错误！引用包装器不能作为左值  (int&amp;amp;)rw = 20; //显示转换为int&amp;amp;，这样可以作为左值  assert(x == 20); boost::reference_wrapper&amp;lt;int&amp;gt; rw2(rw); //拷贝构造  rw.get() = 25; assert(rw2.get() == 25);//rw2也是x的一个引用对象 	//在确实需要持有或者修改字符串的时候可以调用成员函数 to_string() 获得一个拷贝来保证安全  return 0; } ref 使用函数ref()和cref()可以很方便的构造reference_wrapper和const reference_wrapper对象，它们可以根据参数的类型推导出引用的类型。</description>
    </item>
    
    <item>
      <title>Boost - 实用工具</title>
      <link>https://jfy0o0.github.io/2020/boost-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Tue, 15 Dec 2020 18:58:30 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7/</guid>
      <description>noncopyable 概念  让一个类从noncopyable继承可以实现禁止对象的复制，使用需要包含头文件&amp;quot;boost/noncopyable.hpp&amp;quot;或&amp;quot;boost/utility.hpp&amp;quot;。 noncopyable实际上是将类的拷贝构造函数和赋值操作符声明为了private来实现禁止对象的赋值。  optional 概念  optional类可以表示一个无意义的值， 比如以下代码，我们使用get_optional()查找xml上的一个节点，如果该节点不存在的话就会返回一个无效的optional对象，此时对象就是空的。  ptree pt; read_xml(&amp;#34;conf.xml&amp;#34;, pt); boost::optional&amp;lt;int&amp;gt; op = pt.get_optional&amp;lt;int&amp;gt;(&amp;#34;conf.gui&amp;#34;); if (op)//节点不存在则op为空  { int i = op.get(); } auto x = make_optional(5); auto y = make_optional&amp;lt;double&amp;gt;((*x &amp;gt; 10),1.0); 成员函数：
  无参数或参数为boost::none的构造函数用来构造一个无效的对象。
  如果构造函数中的参数是一个值的引用的话，那么optional中元素其实也是这个值的引用。
  get()可以获得元素的引用，get_value_or()也可以获得元素的引用，如果对象是无效的话get_value_or()还可以设置一个默认的返回值，get_ptr()可以获得元素的指针。
  提供了隐式bool类型转换以判断对象的有效性。
  重载了operator*和operator-&amp;gt;，*运算可以获得元素的值，-&amp;gt;操作可以获得元素的指针。
  支持==、!=、&amp;gt;等比较运算。
  使用make_optional()来创建optional对象的话可以不用指定参数的类型，它可以根据参数来自动推导optional的类型。
  BOOST_AUTO(x, boost::make_optional(5)); assert(*x == 5); in_place() 概念  optional要求参数具有拷贝语义， 因为它会使用参数值的临时拷贝， 如果参数是一个复杂的对象的话这种拷贝方式效率就会很慢， 我们可以使用boost库in_place_factory中的in_place()函数来就地创建对象，避免对参数值的临时拷贝，  使用 #include &amp;#34;boost/optional.</description>
    </item>
    
    <item>
      <title>Boost - 智能指针</title>
      <link>https://jfy0o0.github.io/2020/boost-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</link>
      <pubDate>Tue, 15 Dec 2020 18:44:53 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/</guid>
      <description>智能指针 auto_ptr 概念  auto_ptr是C++标准中的智能指针，在指针退出作用域的时候自动释放指针指向的内存，即使是异常退出的时候。 auto_ptr实际上是一个对象，重载了operator*和operator-&amp;gt;，且提供了一些成员函数，比如使用成员get()可以获得对应类型的原始指针。 auto_pt的特点是可以对其进行复制和赋值，但同一时刻只能有一个auto_ptr管理指针。  使用 std::auto_ptr&amp;lt;int&amp;gt; ap1(new int(5)); cout &amp;lt;&amp;lt; *ap1 &amp;lt;&amp;lt; endl; int* p = ap1.get(); cout &amp;lt;&amp;lt; *p &amp;lt;&amp;lt; endl; std::auto_ptr&amp;lt;int&amp;gt; ap2(ap1);//ap1失去管理权，不再拥有指针，ap2得到管理权  assert(ap1.get() == 0);//get()获得的指针为空 scoped_ptr 概念  boost的scoped_ptr用法类似于auto_ptr，都不能用作容器的元素，不支持++、&amp;ndash;等指针算数操作。 scoped_ptr的特点是拷贝构造函数和赋值操作符都是私有的，所以scoped_ptr不能进行复制和赋值操作，保证了对对象的唯一管理权。  使用 boost::scoped_ptr&amp;lt;int&amp;gt; sp1(new int(10)); boost::scoped_ptr&amp;lt;int&amp;gt; sp2(sp1);//编译无法通过：不能转让sp1的管理权到sp2  boost::scoped_ptr&amp;lt;int&amp;gt; sp3(new int(30)); sp3 = sp1;//编译无法通过：不能转让sp1的管理权到sp3 scoped_array 使用 #include &amp;lt;boost/scoped_array.hpp&amp;gt;  int main() { boost::scoped_array&amp;lt;int&amp;gt; i(new int[2]); *i.get() = 1; i[1] = 2; i.reset(new int[3]); boost::scoped_array&amp;lt;Book&amp;gt; myBook(new Book[2]); myBook.</description>
    </item>
    
    <item>
      <title>Boost - 字符串转换</title>
      <link>https://jfy0o0.github.io/2020/boost-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Tue, 15 Dec 2020 15:17:09 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2/</guid>
      <description>format  在字符串处理中少不了格式化字符串，C++中传统的格式化函数是C语言的sprintf，但它一个很大的问题就是不安全。 因此，在stl中引入了stringstream来实现安全格式化，但是stringstream却远不如sprintf来得直观。  eg //C风格的格式化字符串 	boost::format fmt = boost::format(&amp;#34;&amp;lt;%s&amp;gt; %s in the lower case&amp;#34;) % text % (is_all_lower? &amp;#34;is&amp;#34;: &amp;#34;is not&amp;#34;); string output = fmt.str(); //.net风格的格式化字符串 	boost::format fmt = boost::format(&amp;#34;&amp;lt;%1%&amp;gt; %2% in the lower case&amp;#34;) % text % (is_all_lower? &amp;#34;is&amp;#34;: &amp;#34;is not&amp;#34;); cout &amp;lt;&amp;lt; fmt &amp;lt;&amp;lt; endl; 格式化控制 //传统c语言风格  cout &amp;lt;&amp;lt; boost::format(&amp;#34;\n\n%s&amp;#34; &amp;#34;%1t 十进制 = [%d]\n&amp;#34; &amp;#34;%1t 格式化的十进制 = [%5d]\n&amp;#34; &amp;#34;%1t 格式化十进制，前补&amp;#39;0&amp;#39; = [%05d]\n&amp;#34; &amp;#34;%1t 十六进制 = [%x]\n&amp;#34; &amp;#34;%1t 八进制 = [%o]\n&amp;#34; &amp;#34;%1t 浮点 = [%f]\n&amp;#34; &amp;#34;%1t 格式化的浮点 = [%3.</description>
    </item>
    
    <item>
      <title>Boost - property_tree</title>
      <link>https://jfy0o0.github.io/2020/boost-property_tree/</link>
      <pubDate>Tue, 15 Dec 2020 15:07:28 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-property_tree/</guid>
      <description>property_tree   property_tree是一个保存了多个属性值的树形数据结构，可以用来解析xml、json、ini、info文件。
  要使用property_tree和xml解析组件的话需要包含&amp;quot;boost/property_tree/ptree.hpp&amp;quot;和&amp;quot;boost/property_tree/xml_parser.hpp&amp;quot;。
  我们一般使用property_tree中预定义好的typedef: ptree来处理数据。
  xml 格式 &amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt; &amp;lt;conf&amp;gt; &amp;lt;gui&amp;gt;0&amp;lt;/gui&amp;gt; &amp;lt;theme&amp;gt;matrix&amp;lt;/theme&amp;gt; &amp;lt;urls&amp;gt; &amp;lt;url&amp;gt;http:://www.url1.com&amp;lt;/url&amp;gt; &amp;lt;url&amp;gt;http:://www.url2.com&amp;lt;/url&amp;gt; &amp;lt;url&amp;gt;http:://www.url3.com&amp;lt;/url&amp;gt; &amp;lt;url&amp;gt;&amp;lt;/url&amp;gt; &amp;lt;/urls&amp;gt; &amp;lt;clock_style&amp;gt;24.35&amp;lt;/clock_style&amp;gt; &amp;lt;/conf&amp;gt; 解析 #include &amp;lt;cstdio&amp;gt;#include &amp;lt;string&amp;gt;#include &amp;lt;iostream&amp;gt;using std::string; #include &amp;#34;boost/property_tree/ptree.hpp&amp;#34;#include &amp;#34;boost/property_tree/xml_parser.hpp&amp;#34;#include &amp;#34;boost/typeof/typeof.hpp&amp;#34;#include &amp;#34;boost/optional.hpp&amp;#34;using namespace boost::property_tree; int main() { ptree pt; read_xml(&amp;#34;conf.xml&amp;#34;, pt); boost::optional&amp;lt;int&amp;gt; op = pt.get_optional&amp;lt;int&amp;gt;(&amp;#34;conf.gui&amp;#34;); //使用get_optional()获得节点，不存在则op为空  if (op) { int i = op.get(); } string str1 = pt.get&amp;lt;string&amp;gt;(&amp;#34;conf.theme&amp;#34;, &amp;#34;&amp;#34;); //使用get()获得节点，不存在则返回&amp;#34;&amp;#34;  boost::optional&amp;lt;ptree&amp;amp;&amp;gt; child_null_test = pt.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - STL Algorithm</title>
      <link>https://jfy0o0.github.io/2020/cpp_stl_algorithm/</link>
      <pubDate>Sat, 12 Dec 2020 08:47:21 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_stl_algorithm/</guid>
      <description>非修改性序列操作（12个） 循环          对序列中的每个元素执行某操作 for_each()    查找          在序列中找出某个值的第一次出现的位置 find()   在序列中找出符合某谓词的第一个元素 find_if()   在序列中找出一子序列的最后一次出现的位置 find_end()   在序列中找出第一次出现指定值集中之值的位置 find_first_of()   在序列中找出相邻的一对值 adjacent_find()    计数          在序列中统计某个值出现的次数 count()   在序列中统计与某谓词匹配的次数 count_if()    比较          找出两个序列相异的第一个元素 mismatch()   两个序列中的对应元素都相同时为真 equal()    搜索          在序列中找出一子序列的第一次出现的位置 search()   在序列中找出一值的连续n次出现的位置 search_n()    修改性序列操作（27个） 复制          从序列的第一个元素起进行复制 copy()   从序列的最后一个元素起进行复制 copy_backward()    交换          交换两个元素 swap()   交换指定范围的元素 swap_ranges()   交换由迭代器所指的两个元素 iter_swap()    变换          将某操作应用于指定范围的每个元素 transform()    替换          用一个给定值替换一些值 replace()   替换满足谓词的一些元素 replace_if()   复制序列时用一给定值替换元素 replace_copy()   复制序列时替换满足谓词的元素 replace_copy_if()    填充          用一给定值取代所有元素 fill()   用一给定值取代前n个元素 fill_n()    生成          用一操作的结果取代所有元素 generate()   用一操作的结果取代前n个元素 generate_n()    删除          删除具有给定值的元素 remove()   删除满足谓词的元素 remove_if()   复制序列时删除具有给定值的元素 remove_copy()   复制序列时删除满足谓词的元素 remove_copy_if()    唯一          删除相邻的重复元素 unique()   复制序列时删除相邻的重复元素 unique_copy()    反转          反转元素的次序 reverse()   复制序列时反转元素的次序 reverse_copy()    环移          循环移动元素 rotate()   复制序列时循环移动元素 rotate_copy()    随机          采用均匀分布来随机移动元素 random_shuffle()    划分          将满足某谓词的元素都放到前面 partition()   将满足某谓词的元素都放到前面并维持原顺序 stable_partition()    序列排序及相关操作（27个） 排序          以很好的平均效率排序 sort()   排序，并维持相同元素的原有顺序 stable_sort()   将序列的前一部分排好序 partial_sort()   复制的同时将序列的前一部分排好序 partial_sort_copy()    第n个元素          将第n各元素放到它的正确位置 nth_element()    二分检索          找到大于等于某值的第一次出现 lower_bound()   找到大于某值的第一次出现 upper_bound()   找到（在不破坏顺序的前提下）可插入给定值的最大范围 equal_range()   在有序序列中确定给定元素是否存在 binary_search()    归并          归并两个有序序列 merge()   归并两个接续的有序序列 inplace_merge()    有序结构上的集合操作          一序列为另一序列的子序列时为真 includes()   构造两个集合的有序并集 set_union()   构造两个集合的有序交集 set_intersection()   构造两个集合的有序差集 set_difference()   构造两个集合的有序对称差集（并-交） set_symmetric_difference()    堆操作          向堆中加入元素 push_heap()   从堆中弹出元素 pop_heap()   从序列构造堆 make_heap()   给堆排序 sort_heap()    最大和最小          两个值中较小的 min()   两个值中较大的 max()   序列中的最小元素 min_element()   序列中的最大元素 max_element()    词典比较          两个序列按字典序的第一个在前 lexicographical_compare()    排列生成器          按字典序的下一个排列 next_permutation()   按字典序的前一个排列 prev_permutation()    函数对象类模板    函数对象类模板 成员函数 T operator ( const T &amp;amp; x, const T &amp;amp; y) 的功能     plus  return x + y;   minus &amp;lt; &amp;gt; return x - y;   multiplies  return x * y;   divides  return x / y;   modulus  return x % y;        成员函数 bool operator( const T &amp;amp; x, const T &amp;amp; y) 的功能   equal_to  return x == y;   not_equal_to  return x!</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - lambda表达式</title>
      <link>https://jfy0o0.github.io/2020/cpp_lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</link>
      <pubDate>Fri, 11 Dec 2020 16:54:59 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/</guid>
      <description>lambda 说明  lambda表达式 就是一个函数（匿名函数），也就是没有函数名的函数。 为什么不需要函数名呢，因为我们直接（一次性的）用它，嵌入式用的它，不需要其他地方调用它。 lambda表达式也叫闭包，闭就是封闭的意思，就是其他地方都不用他，包就是函数。 lambda表达式其实就是一个函数对象，他内部创建了一个重载()操作符的类。  简易入门 //最简单的一个lambda表达式。 int main() { [] { }();//[]代表lambda表达式的开始，{}代表函数体，什么都没有，()代表调用函数. } // []() {}(); // 加了一个()代表函数参数。什么参数都没有，就可以省略。 输出 int main() { [] { cout &amp;lt;&amp;lt; &amp;#34;Hello, World!&amp;#34;; }(); auto lam = [] { cout &amp;lt;&amp;lt; &amp;#34;Hello, World!&amp;#34;; }; lam(); } 返回值 // -&amp;gt; int ：代表返回int。  int main() { auto lam =[]() -&amp;gt; int { cout &amp;lt;&amp;lt; &amp;#34;Hello, World!&amp;#34;; return 1; }; auto ret = lam(); auto lam2 =[]() -&amp;gt; string { cout &amp;lt;&amp;lt; &amp;#34;Hello, World!</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - cast用法</title>
      <link>https://jfy0o0.github.io/2020/cpp_cast%E7%94%A8%E6%B3%95/</link>
      <pubDate>Thu, 10 Dec 2020 11:34:01 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_cast%E7%94%A8%E6%B3%95/</guid>
      <description>static_cast static_cast&amp;lt; new_type &amp;gt;(expression)  相当于传统的C语言里的强制转换 把expression转换为new_type类型 编译时检查，用于非多态的转换，可以转换指针及其他 没有运行时类型检查来保证转换的安全性  用法  用于类层次结构中基类（父类）和派生类（子类）之间指针或引用的转换。  进行上行转换（把派生类的指针或引用转换成基类表示）是安全的； 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。   用于基本数据类型之间的转换，如把int转换成char，把int转换成enum。 把空指针转换成目标类型的空指针。 把任何类型的表达式转换成void类型。 static_cast不能转换掉expression的const、volatile、或者__unaligned属性  例子 char a = &amp;#39;a&amp;#39;; int b = static_cast&amp;lt;int&amp;gt;(a);//正确，将char型数据转换成int型数据  double *c = new double; void *d = static_cast&amp;lt;void*&amp;gt;(c);//正确，将double指针转换成void指针  int e = 10; const int f = static_cast&amp;lt;const int&amp;gt;(e);//正确，将int型数据转换成const int型数据  const int g = 20; int *h = static_cast&amp;lt;int*&amp;gt;(&amp;amp;g);//编译错误，static_cast不能转换掉g的const属性  class Base {}; class Derived : public Base {} Base* pB = new Base(); if(Derived* pD = static_cast&amp;lt;Derived*&amp;gt;(pB)) {}//下行转换是不安全的(坚决抵制这种方法)  Derived* pD = new Derived(); if(Base* pB = static_cast&amp;lt;Base*&amp;gt;(pD)) {}//上行转换是安全的 dynamic_cast dynamic_cast&amp;lt; type* &amp;gt;(e) //type必须是一个类类型且必须是一个有效的指针 dynamic_cast&amp;lt; type&amp;amp; &amp;gt;(e) //type必须是一个类类型且必须是一个左值 dynamic_cast&amp;lt; type&amp;amp;&amp;amp; &amp;gt;(e) //type必须是一个类类型且必须是一个右值 e的类型必须符合以下三个条件中的任何一个：</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - new的三种用法</title>
      <link>https://jfy0o0.github.io/2020/cpp_new%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95/</link>
      <pubDate>Fri, 04 Dec 2020 10:19:49 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_new%E7%9A%84%E4%B8%89%E7%A7%8D%E7%94%A8%E6%B3%95/</guid>
      <description>new用法总结 new可以说是个
 一个关键字， 一个运算符 可以被重载。  new operator 这个就是平时最经常用的new，用法如下程序所示：
class A { public: A(int i) :a(i){} private: int a; }; int main() { A* example = new A(1); } 说明 new operator实际上执行了以下三个步骤：
 调用operator new分配内存（后面要说的第二种new），  如果类本身定义了operator new，那么会调用类自己的operator new，而不是全局的； 如果未定义，则是全局的   调用A的构造函数A::A(int)； 返回相应的指针  operator new operator new不调用构造函数，而仅仅分配内存，
有两个版本，
 前者抛出异常 后者当失败时不抛出异常，而是直接返回：  void* operator new (std::size_t size); void* operator new (std::size_t size, const std::nothrow_t&amp;amp; nothrow_value) noexcept; class A { public: A(int i) :a(i){} void* operator new(size_t size) { cout &amp;lt;&amp;lt; &amp;#34;call A::operator new&amp;#34; &amp;lt;&amp;lt; endl; return malloc(size); } void operator delete(void* p) { cout &amp;lt;&amp;lt; &amp;#34;call A::operator delete&amp;#34; &amp;lt;&amp;lt; endl; return free(p); } void* operator new(size_t size, const nothrow_t&amp;amp; nothrow_value) noexcept { cout &amp;lt;&amp;lt; &amp;#34;call A::operator new (noexcept)&amp;#34; &amp;lt;&amp;lt; endl; return malloc(size); } void operator delete(void* p, const nothrow_t&amp;amp; nothrow_value) noexcept { cout &amp;lt;&amp;lt; &amp;#34;call A::operator delete (noexcept)&amp;#34; &amp;lt;&amp;lt; endl; free(p); } private: int a; }; int main() { A* example1 = new A(1); delete example1; A* example2 = new(nothrow) A(2); delete example2; } placement new placement new仅在一个已经分配好的内存指针上调用构造函数，基本形式如下：</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - 使用技巧</title>
      <link>https://jfy0o0.github.io/2020/cpp_%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Thu, 03 Dec 2020 18:44:42 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</guid>
      <description>变长数组 特点：
 变长 空间合理  eg: struct MutableLenArray { int count; char p[0]; }; 宏的妙用 1. “#”符号把一个符号直接转换为字符串，例如：
#define TO_STRING(x) #x const char *str = TO_STRING( test ); ##符号会连接两个符号，从而产生新的符号(词法层次)，例如：
#define SIGN( x ) INT_##x int SIGN( 1 ); //宏被展开后将成为：int INT_1; 2. 变参宏 #define LOG( format, ... ) printf( format, __VA_ARGS__ ) LOG( &amp;#34;%s %d&amp;#34;, str, count );  VA_ARGS是系统预定义宏，被自动替换为参数列表。 经常需要进行输出格式化，重定义时，可以用到以上技巧。  不定参 模板实现： template&amp;lt;typename... T&amp;gt; void func(T... args) { for (auto x : {args.</description>
    </item>
    
    <item>
      <title>C&#43;&#43; - 运算符重载小技巧</title>
      <link>https://jfy0o0.github.io/2020/cpp_%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%B0%8F%E6%8A%80%E5%B7%A7/</link>
      <pubDate>Thu, 12 Nov 2020 15:54:13 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid>
      <description>c++ - 运算符重载小技巧 重载 () ： 多次调用(),然后再调用print()
class A{ public: A operator()(int a) { cout &amp;lt;&amp;lt; a &amp;lt;&amp;lt;endl; return *this; } void print() { cout &amp;lt;&amp;lt; &amp;#34;hello&amp;#34;&amp;lt;&amp;lt;endl; } }; int main() { A a; a(54)(434).print(); //54 	//434 	//hello } 重载 ++ ： ++ 运算符，还可分为前缀 ++ 和后缀 ++ 运算符。
class Length { private: int len_inches; public: //前缀++的声明  Length operator++ (); //后缀++的声明  Length operator++ (int); }; 重载前缀++运算符: C++允许重载前缀运算符，以使表达式 ++b 能递增 b 的长度值，并返回结果对象。该运算符可以作为成员函数来重载，这使得它的单个形参是隐含的， 所以重载运算符不需要形参。</description>
    </item>
    
    <item>
      <title>Boost - 容器</title>
      <link>https://jfy0o0.github.io/2020/boost-%E5%AE%B9%E5%99%A8/</link>
      <pubDate>Thu, 12 Nov 2020 10:23:27 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E5%AE%B9%E5%99%A8/</guid>
      <description>boost-容器  array unordered_map、unordered_set bimap circular_buffer dynamic_bitset multi_array  array: array相当于是一个增加了STL容器接口的数组，但它不像vector等容器一样可以动态增长，如果需要动态变动array的容量可以使用boost::scoped_array。array适用与对运行速度要求很高的场合。C++11中已支持array。
用法： #include &amp;lt;boost/array.hpp&amp;gt;#include &amp;lt;boost/typeof/typeof.hpp&amp;gt;int main() { array&amp;lt;int, 5&amp;gt; ary; array&amp;lt;int, 5&amp;gt; ary2 = { 1, 2, 3, 4, 5 };//可以使用{}初始化array  ary = ary2;//赋值  swap(ary, ary2)//互换  ary.assign(0);//所有元素赋值为0  ary[0] = 1;//头元素  ary.back() = 10;//尾元素  ary.at(5);//使用at访问元素  int*p = ary.c_array();//获得原始数组指针  int s = ary.size();//获得数组中元素个数  sort(ary.begin(), ary.end());//使用STL排序函数对其排序  for (BOOST_AUTO(pos, ary.begin()); pos != ary.end(); ++pos) //遍历数组，使用BOOST_AUTO需要包含&amp;#34;boost/typeof/typeof.</description>
    </item>
    
    <item>
      <title>Boost - 时间与日期</title>
      <link>https://jfy0o0.github.io/2020/boost-%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F/</link>
      <pubDate>Tue, 10 Nov 2020 19:38:42 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E6%97%B6%E9%97%B4%E4%B8%8E%E6%97%A5%E6%9C%9F/</guid>
      <description>boost - 时间与日期 boost-timer： timer类可以测量时间的流逝，是一个小型计时器。
使用： #include &amp;lt;boost/timer.hpp&amp;gt;int main() { boost::timer t; //声明时即计时  cout &amp;lt;&amp;lt; t.elapsed_max() &amp;lt;&amp;lt; endl; //可度量最大时间 ，小时单位  cout &amp;lt;&amp;lt; t.elapsed_min() &amp;lt;&amp;lt; endl; //可度量最小时间 ，秒单位  for(int i = 0;i&amp;lt;1000000000;i++); cout &amp;lt;&amp;lt; t.elapsed() &amp;lt;&amp;lt; endl; //输出流逝的时间 （cpu占用的时间） } boost-progress_timer: 继承自timer析构时自动输出时间，省去手动调elapsed()，
使用： #include &amp;lt;boost/progress.hpp&amp;gt;int main() { boost::progress_timer t; cout &amp;lt;&amp;lt; t.elapsed_max() &amp;lt;&amp;lt; endl; cout &amp;lt;&amp;lt; t.elapsed_min() &amp;lt;&amp;lt; endl; } boost-progress_display: 表示进度
使用： boost::progress_display pd(10000000); for(int i = 0;i&amp;lt;10000000;i++) { ++pd; } 时间长度类time_duration 说明  类似日期长度类date_duration有days、weeks、months、years这些常用类， time_duration也有几个子类：hours、minutes、seconds、millisec、microsec、nanosec，他们都支持流输入输出、比较操作、加减乘除运算。  使用 //对象的定义  boost::posix_time::time_duration td(1, 10, 30, 1000); //1小时10分钟30秒1毫秒  boost::posix_time::time_duration td1(1, 60, 60, 1000); //2小时1分钟1毫秒，超出的时间会自动进位  boost::posix_time::time_duration td2 = boost::posix_time::duration_from_string(&amp;#34;1:10:30:001&amp;#34;); //1小时10分钟30秒1毫秒  //成员函数  assert(td.</description>
    </item>
    
    <item>
      <title>Boost - 数据类型</title>
      <link>https://jfy0o0.github.io/2020/boost-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</link>
      <pubDate>Tue, 10 Nov 2020 19:03:32 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</guid>
      <description>Boost - 数据类型   auto
  decltype
  any
  tuple
  variant
  auto： auto是C++11中的关键字，它可以通过类型推导自动得到变量或对象的类型，需要注意的是auto会忽略引用，因为引用其实就代表原对象：
用法1： auto x = 1; 用法2： for(auto &amp;amp;x : arr) decltype: 如果我们希望从表达式中推断出要定义变量的类型，但却不想用表达式的值去初始化变量，那么可以使用decltype，需要注意的是如果decltype使用的变量加上一个括号的话那么decltype会返回对应的引用类型：
用法： int func(int i) { return i; } decltype(func(0)) num = 100; //num是int类型，不会调用func()  int i = 100; decltype((i)) d = num; //d是int引用类型，其指向num any： any功能与auto类似，二者不同之处在于：
  auto是一个类似int、double、string的C++关键字，它不是一个类，所以没有成员函数可调用，直接把他当做int、double、string这种关键字来使用。
  any是一个类，只能通过any_cast&amp;lt;&amp;gt;获得any的实际内部值，而不能像auto定义的对象那样直接使用它。
  any也可以用来存储任意类型元素，如int、double、string、vector或自定义类型。它能够存储任意类型的原因是其构造函数和赋值函数opeartor=是模板函数，可以接收任意类型。
  any不是一个模板类，所以定义元素的时候不必使用&amp;lt;&amp;gt;，如any a = 10;</description>
    </item>
    
    <item>
      <title>Boost - 断言</title>
      <link>https://jfy0o0.github.io/2020/boost-%E6%96%AD%E8%A8%80/</link>
      <pubDate>Tue, 10 Nov 2020 18:47:52 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/boost-%E6%96%AD%E8%A8%80/</guid>
      <description>boost - 断言   标准assert宏的原型声明在&amp;lt;assert.h&amp;gt;中，其作用是如果它的测试条件为假，则调用abort()终止程序执行，程序退出的时候会弹出一个错误提示框，并向控制台输出所在文件及行号。
  assert()只针对debug版本，在Release版本中assert()是无效的。
  使用建议：  每个assert只检验一个条件,因为同时检验多个条件时,如果断言失败,无法直观的判断是哪个条件失败。 比如Object* p = new Object，返回空指针 所以，大的原则可以是这样：内部函数尽量简化容错机制，稍微苛刻一些，而对外接口则尽量容忍，出错处理也要温柔。 断言不应该以任何方式改变程序的状态。简单的说，如果希望在不满足某些条件时阻止代码的执行，就可以考虑用断言来阻止它。  简易使用： BOOST_ASSERT_MSG(false,&amp;#34;assert msg&amp;#34;); boost - 扩展： boost中的BOOST_ASSERT有两点扩展功能:
 可以通过定义BOOST_DISABLE_ASSERTS使在debug版本中也能停用BOOST_ASSERT()。 可以通过定义BOOST_ENABLE_ASSERT_HANDLER使断言出错的时候调用自定义的函数：  如果定义了 BOOST_ENABLE_ASSERT_HANDLER，  BOOST_ASSERT失败则会调用::boost::assertion_failed()， boost / assert.hpp中只声明了assertion_failed(), 可以自己定义它， 它有4个参数, 分别是出错表达式串, 函数名, 文件名, 行号。   如果未定义BOOST_ENABLE_ASSERT_HANDLER，则会调用标准的assert().    eg： #define BOOST_ENABLE_ASSERT_HANDLER #include &amp;#34;boost/assert.hpp&amp;#34; namespace boost { void assertion_failed(char const * expr, char const * function, char const * file, long line) { //todo  } } int main() { BOOST_ASSERT(false); return 0; } </description>
    </item>
    
    <item>
      <title>C&#43;&#43; - cmake</title>
      <link>https://jfy0o0.github.io/2020/cpp_cmake/</link>
      <pubDate>Mon, 09 Nov 2020 13:47:22 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/cpp_cmake/</guid>
      <description>cmake 1.指定 cmake 的最小版本 cmake_minimum_required(VERSION 3.4.1)这行命令是可选的，我们可以不写这句话，但在有些情况下，如果 CMakeLists.txt 文件中使用了一些高版本 cmake 特有的一些命令的时候，就需要加上这样一行，提醒用户升级到该版本之后再执行 cmake。
2.设置项目名称 project(demo)这个命令不是强制性的，但最好都加上。它会引入两个变量 demo_BINARY_DIR 和 demo_SOURCE_DIR，同时，cmake 自动定义了两个等价的变量 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR。
3.设置编译类型 add_executable(demo demo.cpp) # 生成可执行文件 add_library(common STATIC util.cpp) # 生成静态库 add_library(common SHARED util.cpp) # 生成动态库或共享库 #add_library 默认生成是静态库，通过以上命令生成文件名字， 4.指定编译包含的源文件 4.1 明确指定包含哪些源文件 add_library(demo demo.cpp test.cpp util.cpp)4.2 搜索所有的 cpp 文件 aux_source_directory(dir VAR) 发现一个目录下所有的源代码文件并将列表存储在一个变量中。 aux_source_directory(. SRC_LIST) # 搜索当前目录下的所有.cpp文件 add_library(demo ${SRC_LIST})4.3 自定义搜索规则 file(GLOB SRC_LIST &amp;#34;*.cpp&amp;#34; &amp;#34;protocol/*.cpp&amp;#34;)add_library(demo ${SRC_LIST})#或者 file(GLOB SRC_LIST &amp;#34;*.cpp&amp;#34;)file(GLOB SRC_PROTOCOL_LIST &amp;#34;protocol/*.cpp&amp;#34;)add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})#或者 aux_source_directory(. SRC_LIST)aux_source_directory(protocol SRC_PROTOCOL_LIST)add_library(demo ${SRC_LIST} ${SRC_PROTOCOL_LIST})5.</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 访问者模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 09 Nov 2020 10:31:19 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>访问者模式： 　访问者模式的官方定义是这样的：
 表示一个作用于某对象结构中的各元素的操作，它使你可以在不改变各元素类的前提下定义作用于这些元素的新操作。 官方的东西总是晦涩难懂的，那么我们现在就来拆解一下：  首先&amp;quot;一个作用于某对象结构中的各元素的操作&amp;quot;，提到了三个东西：对象结构、元素、操作。 我们都学习过数据结构，数据结构中大家对数据的访问一般都是直接访问其地址。 在面向对象的设计中，我们一般也是将数据的访问操作放在类的内部，便于访问。 这种设计看似没有什么问题，但当我们想要采用不同方式访问数据或对象结构时就必须要对类进行修改，这样就违反了OCP原则。于是大家会想到将数据结构与操作分离开来，当问们需要添加访问操作的时候直接添加新的类，原来的代码不需要做任何改变，这也是后半句提到的&amp;quot;可以在不改变各元素类的前提下定义作用于这些元素的新操作&amp;quot;。    访问者模式的角色：  Visitor：接口或抽象类，定义了对每个Element访问的行为，它的参数就是被访问的元素，它的方法个数理论上与元素的个数是一样的，因此，访问者模式要求元素的类型要稳定，如果经常添加、移除元素类，必然会导致频繁地修改visitor接口，如果出现这种情况，则说明不适合使用该模式。 ConcreteVisitor：具体的访问者，它需要给出对每一个元素类访问时所产生的具体行为。 Element：元素接口或抽象类，它定义了一个接受访问者的方法（accept），其意思就是说每一个元素都可以被访问者访问。 ConcreteElement：具体的元素类，它提供接受访问的具体实现，而这个具体实现通常情况下是使用访问者提供的访问该元素类的方法。 ObjectStructure：定义当中所提到的对象结构，对象结构是一个抽象表述，它内部管理了元素集合，并且可以迭代这些元素提供访问者访问。  优点：  各角色职责分离，符合单一职责原则。 具有优秀的扩展性，使得数据结构和作用于结构上的操作解耦，使得操作集合可以独立变化。 灵活性  缺点：  具体元素对访问者公布细节，违反了迪米特原则。 具体元素变更比较困难。 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。  访问者模式的使用场景：  对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作&amp;quot;污染&amp;quot;这些对象的类，也不希望在增加新操作时修改这些类。　  eg: class Visitor { public: virtual void Visit( Element *element ){}; }; class Element { public: // Methods  virtual void Accept( Visitor *visitor ){}; }; //------------------------------------------------------- class Employee : public Element { public: string name; double income; int vacationDays; public : Employee( string name, double income, int vacationDays ) { this-&amp;gt;name = name; this-&amp;gt;income = income; this-&amp;gt;vacationDays = vacationDays; } void Accept( Visitor *visitor ) { visitor-&amp;gt;Visit( this ); } }; class IncomeVisitor : public Visitor { public: void Visit( Element *element ) { Employee *employee = ((Employee*)element); employee-&amp;gt;income *= 1.</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 迭代器模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Mon, 09 Nov 2020 09:18:29 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>迭代器模式: 　迭代器模式允许你访问一个数据项序列中的所有元素，而无须关心序列是什么类型（数组、链表、列表或任何其他类型）。它能有效地构建一个数据管道，经过一系列不同的转换或过滤后再从管道的另一端出来。迭代器模式就是提供一种遍历集合元素的统一接口，用一致的方法遍历集合元素，不需要知道集合对象的底层表示。
迭代器模式的角色：  抽象迭代器（Iterator）：接口声明了遍历集合所需的操作（获取下一个元素、获取当前位置和重新开始迭代等）。 具体迭代器（ConcreteIterator）：实现遍历集合的一种特定算法。迭代器对象必须跟踪自身遍历的进度。这使得多个迭代器可以相互独立地遍历同一个集合。 抽象聚合（Aggregate）：接口声明一个或多个方法来获取与集合兼容的迭代器。返回方法的类型必须被声明为迭代器接口。 具体聚合（ConcreteAggregate）：会在客户端请求迭代器时返回一个特定的具体迭代器类实体。 客户端（Client）：通过集合和迭代器的接口与两者进行交互。 这样一来客户端无需与具体类进行耦合， 允许同一客户端代码使用各种不同的集合和迭代器。  迭代器模式适用性：  当集合背后为复杂的数据结构，且你希望对客户端隐藏其复杂性时（出于使用便利性或安全性的考虑），可以使用迭代器。 可以减少程序中重复的遍历代码。 如果你希望代码能够遍历不同的甚至是无法预知的数据结构，可以使用迭代器。  优点：  它支持以不同的方式遍历一个聚合对象。 迭代器简化了聚合类。 在同一个聚合上可以有多个遍历。 在迭代器模式中，增加新的聚合类和迭代器类都很方便，无须修改原有代码。符合OCP原则。  缺点： 由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
eg: class Iterator { public: Iterator(){} virtual ~Iterator(){}; virtual string First() = 0; virtual string Next() = 0; virtual string GetCur() = 0; virtual bool IsEnd() = 0; }; class Aggregate { public: virtual int Count() = 0; virtual void Push(const string &amp;amp;strValue) = 0; virtual string POp(const int cnt) = 0; virtual Iterator* CreateIterator() = 0; }; //----------------------------------------------------- class ConcreteIterator : public Iterator { public: ConcreteIterator(Aggregate *p_aggregate):m_aggregate(p_aggregate),m_cnt(0){} string First() { return m_aggregate-&amp;gt;POp(0); } string Next() { string str; m_cnt++; if (m_cnt &amp;lt; m_aggregate-&amp;gt;Count()) { str = m_aggregate-&amp;gt;POp(m_cnt); } return str; } string GetCur() { return m_aggregate-&amp;gt;POp(m_cnt); } bool IsEnd() { return m_cnt &amp;gt;= m_aggregate-&amp;gt;Count() ?</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 中介者模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:54:05 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>中介者模式： 　在现实生活中，有很多中介者模式的身影，例如QQ游戏平台，聊天室、QQ群、短信平台和房产中介。不论是QQ游戏还是QQ群，它们都是充当一个中间平台，QQ用户可以登录这个中间平台与其他QQ用户进行交流，如果没有这些中间平台，我们如果想与朋友进行聊天的话，可能就需要当面才可以了。电话、短信也同样是一个中间平台，有了这个中间平台，每个用户都不要直接依赖与其他用户，只需要依赖这个中间平台就可以了，一切操作都由中间平台去分发。中介者模式，定义了一个中介对象来封装一系列对象之间的交互关系。中介者使各个对象之间不需要显式地相互引用，从而使耦合性降低，而且可以独立地改变它们之间的交互行为。
中介者模式的角色：  抽象中介者（Mediator）：定义了同事对象到中介者对象的接口。 具体中介者（ConcreteMediator）：实现抽象类的方法，它需要知道具体的同事类并从具体同事类接受消息，向具体同事对象发出命令。 抽象同事类（Colleague）：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。 具体同事类（ConcreteColleague）：每个具体同事类只知道自己的行为，而不了解其他同事类的情况，但它们认识中介者对象。  优点：  简化了对象之间的关系，将系统的各个对象之间的相互关系进行封装，将各个同事类解耦，使得系统变为松耦合。 提供系统的灵活性，使得各个同事对象独立而易于复用。  缺点：  中介者模式中，中介者角色承担了较多的责任，所以一旦这个中介者对象出现了问题，整个系统将会受到重大的影响。 新增加一个同事类时，不得不去修改抽象中介者类和具体中介者类，此时可以使用观察者模式和状态模式来解决这个问题。  中介者使用的场景：  一组定义良好的对象，现在要进行复杂的相互通信。 想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。  区别： 与观察者模式区别： 中介者模式主要是起到一个协调的作用，它知道所有的同事类且同事类含有中介者对象，即我有事通知你，你帮我协调一下。而观察者模式侧重在当一个对象的状态发生变化时，能够自动通知其他关联对象，自动刷新对象状态。
eg: //抽象同事类 class Colleague { protected : Mediator *mediator; public: Colleague(Mediator* m) { mediator = m; } virtual void Sent(string message) = 0; }; //具体同事类 class ConcreteColleague1 :public Colleague { public: ConcreteColleague1(Mediator* m) : Colleague(m) {} void Sent(string message) { mediator-&amp;gt;Send(message, this); } void Notify(string message) { cout &amp;lt;&amp;lt; &amp;#34;同事1得到消息：&amp;#34; &amp;lt;&amp;lt; message &amp;lt;&amp;lt; endl; } }; class ConcreteColleague2 :public Colleague { public: ConcreteColleague2(Mediator* m) : Colleague(m) {} void Sent(string message) { mediator-&amp;gt;Send(message, this); } void Notify(string message) { cout &amp;lt;&amp;lt; &amp;#34;同事2得到消息：&amp;#34; &amp;lt;&amp;lt; message &amp;lt;&amp;lt; endl; } }; //----------------------------------------------------- //抽象中介者类 class Mediator { public: virtual void Send(string message, Colleague *colleague) = 0; }; //具体中介者类 class Concretemediator :public Mediator { private: ConcreteColleague1* colleague1; ConcreteColleague2* colleague2; public: void SetColleague1(Colleague* pColleague){ colleague1 = dynamic_cast&amp;lt;ConcreteColleague1*&amp;gt;(pColleague); } void SetColleague2(Colleague * pColleague){ colleague2 = dynamic_cast&amp;lt;ConcreteColleague2*&amp;gt;(pColleague); } void Send(string message, Colleague* colleague){ if (colleague == colleague1) colleague2-&amp;gt;Notify(message); else if (colleague == colleague2) colleague1-&amp;gt;Notify(message); } }; //----------------------------------------------------- //use 	Concretemediator* mediator = new Concretemediator(); ConcreteColleague1* colleague1 = new ConcreteColleague1(mediator);	//让他俩认识一下中介 	ConcreteColleague2* colleague2 = new ConcreteColleague2(mediator); mediator-&amp;gt;SetColleague1(colleague1);	//让中介认识一下他俩 	mediator-&amp;gt;SetColleague2(colleague2); colleague1-&amp;gt;Sent(&amp;#34;有男朋友没？&amp;#34;); colleague2-&amp;gt;Sent(&amp;#34;有了&amp;#34;); </description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 备忘录模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:47:53 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F/</guid>
      <description>备忘录模式： 　后悔药来啦！！！备忘录模式在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便在需要时能将该对象恢复到原先保存的状态。
备忘录模式的角色：  发起人（Originator）：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。 备忘录（Memento）：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。 管理者（CareTaker）：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。  优点：  给用户提供了一种可以恢复状态的机制，可以使用户能够比较方便地回到某个历史的状态。 实现了信息的封装，使得用户不需要关心状态的保存细节。  缺点： 消耗资源。如果类的成员变量过多，势必会占用比较大的资源，而且每一次保存都会消耗一定的内存。
备忘录模式的应用场景：  　需要保存/恢复数据的相关状态场景。 　提供一个可回滚的操作。  class STMemento { private: int iVitality; public: STMemento(){} STMemento(int iVitality) { this-&amp;gt;iVitality = iVitality; } int GetVitality() const { return this-&amp;gt;iVitality; } }; //------------------------------------------------------- class STOriginator { private: int iVitality; string name; public: STOriginator(string strName, int iVit): iVitality(iVit), name(strName) { } STMemento* SaveState() { return new STMemento(iVitality); } void RecoverState(const STMemento* stMemento) { this-&amp;gt;iVitality = stMemento-&amp;gt;GetVitality(); } void SetVitality(int iVit) { this-&amp;gt;iVitality = iVit; } void Show() { cout&amp;lt;&amp;lt; &amp;#34;Name: &amp;#34;&amp;lt;&amp;lt; name&amp;lt;&amp;lt; endl; cout&amp;lt;&amp;lt; &amp;#34;Live: &amp;#34;&amp;lt;&amp;lt; iVitality&amp;lt;&amp;lt; endl; } }; //------------------------------------------------------- class STCareTaker { private: vector&amp;lt;STMemento*&amp;gt; vecStMemento; public: void AddMemento(STMemento* stMemento) { vecStMemento.</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 解释器模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:43:06 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>解释器模式： 　从名称上来看看这个模式，个人的最初理解“解释器”和Google的中英翻译功能类似。如果有一天你去国外旅游去了，比如去美国吧，美国人是讲英语的，我们是讲汉语的，如果英语听不懂，讲不好，估计沟通就完蛋了，不能沟通，估计玩的就很难尽兴了，因为有很多景点的解说你可能不明白（没有中文翻译的情况下，一般情况会有的）。所以我们需要一个软件，可以把中英文互译，那彼此就可以更好的理解对方的意思，我感觉翻译软件也可以称得上是解释器，把你不懂的解释成你能理解的。我们写代码，需要编译器把我们写的代码编译成机器可以理解的机器语言，从这方面来讲，C#的编译器也是一种解释器。
解释器模式的角色：  抽象解释器（AbstractExpression）：定义解释器的接口，约定解释器的解释操作。其中的Interpret接口，正如其名字那样，它是专门用来解释该解释器所要实现的功能。 终结符表达式（TermialExpression）：实现了抽象表达式角色所要求的接口，主要是一个interpret()方法；文法中的每一个终结符都有一个具体终结表达式与之相对应。比如有一个简单的公式R=R1+R2，在里面R1和R2就是终结符，对应的解析R1和R2的解释器就是终结符表达式。 非终结符表达式（NonterminalExpression）：文法中的每一条规则都需要一个具体的非终结符表达式，非终结符表达式一般是文法中的运算符或者其他关键字，比如公式R=R1+R2中，“+”就是非终结符，解析“+”的解释器就是一个非终结符表达式。 环境角色（Context）：这个角色的任务一般是用来存放文法中各个终结符所对应的具体值，比如R=R1+R2，我们给R1赋值100，给R2赋值200。这些信息需要存放到环境角色中，很多情况下我们使用Map来充当环境角色就足够了。  优点：  易于改变和扩展文法。 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。  缺点：  对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。  解释器模式的应用场景：  当一个语言需要解释执行，并可以将该语言中的句子表示为一个抽象语法树的时候，可以考虑使用解释器模式（如XML文档解释、正则表达式等领域）。 一些重复出现的问题可以用一种简单的语言来进行表达。 一个语言的文法较为简单. 当执行效率不是关键和主要关心的问题时可考虑解释器模式（注：高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。）  eg: class Context { private: map&amp;lt;string,int&amp;gt; valueMap; public: void addValue(string key,int value) { valueMap.insert(std::pair&amp;lt;string,int&amp;gt;(key,value)); } int getValue(string key) { return valueMap[key]; } }; //-------------------------------------------------- class AbstractExpression { public : virtual int interpreter(Context context) = 0; }; class AddNonterminalExpression:public AbstractExpression { private : AbstractExpression *left; AbstractExpression *right; public: AddNonterminalExpression(AbstractExpression *left, AbstractExpression *right) { this-&amp;gt;left = left; this-&amp;gt;right = right; } int interpreter(Context context) { return this-&amp;gt;left-&amp;gt;interpreter(context) + this-&amp;gt;right-&amp;gt;interpreter(context); } }; class SubtractNonterminalExpression:public AbstractExpression { private : AbstractExpression *left; AbstractExpression *right; public: SubtractNonterminalExpression(AbstractExpression *left, AbstractExpression *right) { this-&amp;gt;left = left; this-&amp;gt;right = right; } int interpreter(Context context) { return this-&amp;gt;left-&amp;gt;interpreter(context) - this-&amp;gt;right-&amp;gt;interpreter(context); } }; class TerminalExpression :public AbstractExpression { private: int i; public: TerminalExpression(int i) { this-&amp;gt;i = i; } int interpreter(Context context) { return this-&amp;gt;i; } }; //-------------------------------------------------- //use  //a-b+c  cout&amp;lt;&amp;lt;&amp;#34;解释器模式:a-b+c&amp;#34;&amp;lt;&amp;lt;endl; Context context; context.</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 命令模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:36:09 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F/</guid>
      <description>命令模式： 　将请求封装成对象，以便使用不同的请求、日志、队列等来参数化其他对象。命令模式也支持撤销操作。
命令模式的角色：  传递命令对象（Invoker）：是请求的发送者，它通常拥有很多的命令对象，并通过访问命令对象来执行相关请求，它不直接访问接收者。 抽象命令接口（Command）：声明执行命令的接口，拥有执行命令的抽象方法execute()。 具体的命令对象（ConcreteCommand）：是抽象命令类的具体实现类，它拥有接收者对象，并通过调用接收者的功能来完成命令要执行的操作。 接受者对象（Receiver）：执行命令功能的相关操作，是具体命令对象业务的真正实现者。 客户端对象（Client）：创建具体命令的对象并且设置命令对象的接受者。  优点：  　降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。 　增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足OCP原则，对扩展比较灵活。 　可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。 　方便实现 Undo 和 Redo 操作。命令模式可以与备忘录模式结合，实现命令的撤销与恢复。  缺点： 可能产生大量的具体命令类。
适用环境：  使用命令模式作为“CallBack”在面向对象系统中的替代。“CallBack”讲的便是先将一个函数登记上，然后在以后调用此函数。 需要在不同的时间指定请求、将请求排队。一个命令对象和原先的请求发出者可以有不同的生命期。换言之，原先的请求发出者可能已经不在了，而命令对象本身仍然是活动的。这时命令的接收者可以是在本地，也可以在网络的另外一个地址。命令对象可以在串形化之后传送到另外一台机器上去。 系统需要支持命令的撤消(undo)。命令对象可以把状态存储起来，等到客户端需要撤销命令所产生的效果时，可以调用undo()方法，把命令所产生的效果撤销掉。命令对象还可以提供redo()方法，以供客户端在需要时，再重新实施命令效果。 如果一个系统要将系统中所有的数据更新到日志里，以便在系统崩溃时，可以根据日志里读回所有的数据更新命令，重新调用Execute()方法一条一条执行这些命令，从而恢复系统在崩溃前所做的数据更新。  区别： 命令模式与策略模式的区别：  命令模式与策略模式都封装了变化，但命令模式封装的是请求的变化，而策略模式封装的是算法的变化。 命令模式可以抽象化成策略模式。策略模式较简单，而命令模式比较复杂。策略模式聚焦的是对相同请求更换解决方案的灵活性；而命令模式聚焦的是对多请求变化的封装以及对相同请求不同的请求形式解决方法的可复用性。  eg： class Barbecuer { public: void BakeMutton(){cout&amp;lt;&amp;lt;&amp;#34;Bake mutton&amp;#34;&amp;lt;&amp;lt;endl;} void BakeChickenWing(){cout&amp;lt;&amp;lt;&amp;#34;Bake ChickenWing&amp;#34;&amp;lt;&amp;lt;endl;} }; //----------------------------------------------  /*抽象命令类：是执行具体操作的接口*/ class Command { public: Command(){} Command(Barbecuer *receiver):p_receiver(receiver){} virtual void ExecuteCommand() = 0; //执行命令  protected: Barbecuer *p_receiver; }; /*具体命令类:烤羊肉串命令*/ class BakeMuttonCommand:public Command { public: BakeMuttonCommand(Barbecuer *receiver){p_receiver = receiver;} void ExecuteCommand(){p_receiver-&amp;gt;BakeMutton();} }; /*具体命令类:烤鸡翅串命令*/ class BakeChickenWingCommand:public Command { public: BakeChickenWingCommand(Barbecuer *receiver){p_receiver = receiver;} void ExecuteCommand() {p_receiver-&amp;gt;BakeChickenWing();} }; //----------------------------------------------  /*服务员类*/ class Waiter { public: void SetOrder(Command *command) { p_commandList.</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 状态模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:30:26 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</guid>
      <description>状态模式： 　在软件开发过程中，应用程序可能会根据不同的情况作出不同的处理。最直接的解决方案是将这些所有可能发生的情况全都考虑到，然后使用if else语句来做状态判断来进行不同情况的处理。但对复杂状态的判断就显得&amp;quot;力不从心了&amp;quot;，随着增加新的状态或者修改一个状体if else(或switch case)语句的增多或者修改）可能会引起很大的修改，违反OCP原则。状态模式就是在当控制一个对象状态转换的条件表达式过于复杂时，把相关&amp;quot;判断逻辑&amp;quot;提取出来，放到一系列的状态类当中，这样可以把原来复杂的逻辑判断简单化。
状态模式的角色：　  环境类（Context）：也称为上下文，它定义了客户感兴趣的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。 抽象状态类（AbstractState）：定义一个接口以封装与Context的一个特定状态相关的行为。 具体状态类（ConcreteState）：实现抽象状态所对应的行为。  优点：  状态模式将与特定状态相关的行为局部化到一个状态中，并且将不同状态的行为分割开来，满足”单一职责原则”。 减少对象间的相互依赖。将不同的状态引入独立的对象中会使得状态转换变得更加明确，且减少对象间的相互依赖。 有利于程序的扩展。通过定义新的子类很容易地增加新的状态和转换。  缺点：  状态模式的使用必然会增加系统的类与对象的个数。 状态模式的结构与实现都较为复杂，如果使用不当会导致程序结构和代码的混乱。  状态模式的应用场景：  当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为。 一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态。  区别： 状态模式与策略模式的区别： 　从UML图上我们会发现这两种设计模式几乎一摸一样，都是利用多态把一些操作分配到一组相关的简单的类中。然而在显示世界中，策略模式和状态模式是两种完全不同的思想。对状态进行建模时，状态迁移是一个核心问题；但策略模式与迁移毫无关系，策略模式允许一个客户选择或提供一种策略。
状态模式与责任链模式的区别： 　职责链模式和状态模式都可以解决if分支过多的问题，从定义来看，状态模式是一个对象内在状态发生改变（一个对象，相对稳定，处理完一个对象下一个对象一般已确定），而职责链模式是多个对象之间的改变（多个对象之间的话，就会出现某个对象不存在的问题，且该模式由客户端指定，不稳定），这也说明了这两个模式处理的情况不同。
eg： class State { public: virtual void Handle(Context *pContext) = 0; }; //------------------------------------------- class ConcreteStateA : public State { public: virtual void Handle(Context *pContext) { cout&amp;lt;&amp;lt;&amp;#34;I am concretestateA.&amp;#34;&amp;lt;&amp;lt;endl; } }; class ConcreteStateB : public State { public: virtual void Handle(Context *pContext) { cout&amp;lt;&amp;lt;&amp;#34;I am concretestateB.</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 观察者模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:22:11 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>观察者模式： 　指多个对象间存在一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
观察者模式的角色：  抽象目标（Subject）：也叫抽象目标类，它提供了一个用于保存观察者对象的聚集类和增加、删除观察者对象的方法，以及通知所有观察者的抽象方法。 具体目标（ConcreteSubject）：也叫具体目标类，它实现抽象目标中的通知方法，当具体主题的内部状态发生改变时，通知所有注册过的观察者对象。 抽象观察者（Observer）：它是一个抽象类或接口，它包含了一个更新自己的抽象方法，当接到具体主题的更改通知时被调用。 具体观察者（ConcreteObserver）：实现抽象观察者中定义的抽象方法，以便在得到目标的更改通知时更新自身的状态。  观察者模式的应用场景：  对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。 当一个抽象模型有两个方面，其中一个方面依赖于另一方面时，可将这二者封装在独立的对象中以使它们可以各自独立地改变和复用。  优点： 观察者和被观察者是抽象耦合的；建立的一套触发机制。
缺点：  如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。  eg： class Observer { public: Observer(); virtual ~Observer(); virtual void Update()=0; }; //--------------------------------------------- class ConcreteObserver :public Observer{ public: ConcreteObserver(ConcreteSubject *sub,string name){ pSubject = sub; mName = name; } void Update(){ mObserverState = pSubject-&amp;gt;mSubjectState; cout &amp;lt;&amp;lt; &amp;#34;观察者&amp;#34; &amp;lt;&amp;lt; mName &amp;lt;&amp;lt; &amp;#34; 状态&amp;#34; &amp;lt;&amp;lt;mObserverState&amp;lt;&amp;lt;endl; } virtual ~ConcreteObserver(); ConcreteSubject* getSubject() { return pSubject; } void setSubject( ConcreteSubject* subject) { pSubject = subject; } private: string mName; string mObserverState; ConcreteSubject *pSubject; }; //--------------------------------------------- class Subject { public: Subject(); virtual ~Subject(); void Attach(Observer* p){ observers.</description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 职责链模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:17:54 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F/</guid>
      <description>职责链模式： 　在现实生活中，常常会出现这样的事例：一个请求需要多个对象处理，但每个对象的处理条件或权限不同。如公司员工报销差旅费，可审批的领导有部分负责人、副总经理、总经理等，但每个领导能审批的金额是不同的，不同的金额需要找相应的领导审批，也就是说要报销必须先搞清楚需要谁来审批。职责链模式就是为了解决这样的问题产生的。
　职责链模式，又叫责任链模式。是为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一个对象记住其下一个对象的引用而连成一条链。当发生请求时，可将请求沿着这条链传递，直到有对象处理它为止。
职责链模式的角色：  抽象处理者（Handler）：声明了所有具体处理者的通用接口。 该接口通常仅包含单个方法用于请求处理， 但有时其还会包含一个设置链上下个处理者的方法 具体处理者（ConcreteHandler）：包含处理请求的实际代码。 每个处理者接收到请求后， 都必须决定是否进行处理， 以及是否沿着链传递请求。处理者通常是独立且不可变的， 需要通过构造函数一次性地获得所有必要地数据。 请求信息（Request）：定义请求的信息。 客户端（Client）：可根据程序逻辑一次性或者动态地生成链。值得注意的是，请求可发送给链上的任意一个处理者，而非必须是第一个处理者。  优点：  请求者和接收者松耦合。在职责链模式中，请求者并不知道接收者是谁，也不知道具体如何处理，请求者只是负责向职责链发送请求就可以了。而每个职责对象也不用管请求者或者是其他的职责对象，只负责处理自己的部分，其他的就交给其他的职责对象去处理。也就是说，请求者和接受者是完全解耦的。 动态组合职责。职责链模式会把功能处理分散到单独的职责对象中，然后再使用的时候，可以动态组合职责形成职责链，从而可以灵活地给对象分配职责，也可以灵活地实现和改变对象的职责。 减少代码中的if..else..判断，优化代码。  缺点：  产生很多细粒度对象。职责链模式会把功能处理分散到单独的职责对象中，也就是每个职责对象只处理一个方面的功能，要把整个业务处理完，需要很多职责对象的组合，这样会产生大量的细粒度职责对象。 不一定能被处理。职责链模式的每个职责对象只负责自己处理的那一部分，因此可能会出现某个请求把整个链传递完了都没有职责对象处理它。这就需要使用职责链模式的时候，需要提供默认的处理，并且注意构造的链的有效性。 职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能由于职责链的错误设置而导致系统出错，如可能会造成循环调用。  职责链的应用场景：  有多个对象可以处理一个请求，哪个对象处理该请求由运行时刻自动确定。 可动态指定一组对象处理请求，或添加新的处理者 在不明确指定请求处理者的情况下，向多个处理者中的一个提交请求。  eg： class Manager { protected: Manager *m_manager; string m_name; public: Manager(Manager* manager,string name):m_manager(manager),m_name(name){} virtual void DealWithRequest(string name, int num) {} }; //-------------------------------------------------- class CommonManager : public Manager { public: CommonManager(Manager* manager,string name):Manager(manager,name){} void DealWithRequest(string name,int num) { if(num &amp;lt; 500) { cout &amp;lt;&amp;lt; &amp;#34;经理&amp;#34; &amp;lt;&amp;lt;m_name &amp;lt;&amp;lt; &amp;#34;批准&amp;#34; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34;加薪&amp;#34; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;#34;元&amp;#34; &amp;lt;&amp;lt;endl; } else { cout &amp;lt;&amp;lt; &amp;#34;经理&amp;#34; &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;#34;无法处理,交由总监处理&amp;#34; &amp;lt;&amp;lt;endl; m_manager-&amp;gt;DealWithRequest(name,num); } } }; class Majordomo:public Manager { public: Majordomo(Manager *manager,string name):Manager(manager,name){} virtual void DealWithRequest(string name,int num) { if(num &amp;lt; 1000) { cout &amp;lt;&amp;lt; &amp;#34;总监&amp;#34; &amp;lt;&amp;lt;m_name &amp;lt;&amp;lt; &amp;#34;批准&amp;#34; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34;加薪&amp;#34; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;#34;元&amp;#34; &amp;lt;&amp;lt;endl; } else { cout &amp;lt;&amp;lt; &amp;#34;总监&amp;#34; &amp;lt;&amp;lt; m_name &amp;lt;&amp;lt; &amp;#34;无法处理,交由总经理处理&amp;#34; &amp;lt;&amp;lt;endl; m_manager-&amp;gt;DealWithRequest(name,num); } } }; class GeneralManager : public Manager { public: GeneralManager(Manager *manager,string name):Manager(manager,name){} void DealWithRequest(string name,int num) { cout &amp;lt;&amp;lt; &amp;#34;总经理&amp;#34; &amp;lt;&amp;lt;m_name &amp;lt;&amp;lt; &amp;#34;批准&amp;#34; &amp;lt;&amp;lt; name &amp;lt;&amp;lt; &amp;#34;加薪&amp;#34; &amp;lt;&amp;lt; num &amp;lt;&amp;lt; &amp;#34;元&amp;#34; &amp;lt;&amp;lt;endl; } }; //-------------------------------------------------- //use  Manager *general = new GeneralManager(NULL,&amp;#34;a&amp;#34;); Manager *majordomo = new Majordomo(general,&amp;#34;b&amp;#34;); Manager *common = new CommonManager(majordomo,&amp;#34;c&amp;#34;); common-&amp;gt;DealWithRequest(&amp;#34;d&amp;#34;,400); common-&amp;gt;DealWithRequest(&amp;#34;d&amp;#34;,700); common-&amp;gt;DealWithRequest(&amp;#34;d&amp;#34;,1200); </description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 模板模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:13:59 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</guid>
      <description>模板模式: 　提到模板，可能大多数人想到的是&amp;quot;简历模板&amp;quot;、&amp;ldquo;论文模板&amp;quot;等，比如我们要写简历时，会从网上下载一份漂亮的简历模板，其格式是固定的，我们根据自己的情况填充不同的内容。模板模式定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
模板模式的角色：  模板方法（AbstractClass）：定义了一个或多个抽象操作，以便让子类实现，这些抽象操作称为基本操作； 模板方法的具体实现（ConcreteClass）：实现父类所定义的一个或多个抽象方法。  优点：  封装不变部分，扩展可变部分，符合OCP原则； 提取公共代码，便于维护； 行为由父类控制，子类实现。  缺点： 每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。
eg： class AbstractClass { public: AbstractClass(); virtual ~AbstractClass(); virtual void PrimitiveOperation1() = 0; virtual void PrimitiveOperation2() = 0; void TemplateMethod(){ PrimitiveOperation1(); PrimitiveOperation2(); } }; //------------------------------------- class ConcreteClassA : public AbstractClass{ public: ConcreteClassA(); virtual ~ConcreteClassA(); void PrimitiveOperation1(){ cout&amp;lt;&amp;lt;&amp;#34;ConcreteClassA PrimitiveOperation1&amp;#34;&amp;lt;&amp;lt;endl; } void PrimitiveOperation2(){ cout&amp;lt;&amp;lt;&amp;#34;ConcreteClassA PrimitiveOperation2&amp;#34;&amp;lt;&amp;lt;endl; } }; class ConcreteClassB : public AbstractClass{ public: ConcreteClassB(); virtual ~ConcreteClassB(); void PrimitiveOperation1(){ cout&amp;lt;&amp;lt;&amp;#34;ConcreteClassB PrimitiveOperation1&amp;#34;&amp;lt;&amp;lt;endl; } void PrimitiveOperation2(){ cout&amp;lt;&amp;lt;&amp;#34;ConcreteClassB PrimitiveOperation2&amp;#34;&amp;lt;&amp;lt;endl; } }; //------------------------------------- //use 	AbstractClass * p = new ConcreteClassA(); p-&amp;gt;TemplateMethod(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 行为型模式 - 策略模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:06:29 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E8%A1%8C%E4%B8%BA%E5%9E%8B-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>策略模式： 　策略模式是对算法的包装，是把使用算法的责任和算法本身分割开来，委派给不同的对象管理。策略模式通常把一个系列的算法包装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是：“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。
策略模式的角色：　  环境类（Context）：采用组合或聚合的方式维护一个对Strategy对象的引用。 抽象策略类（Strategy）：定义所有支持的算法的公共接口。Context使用这个接口来调用某ConcreteStrategy定义的算法。 具体策略类（ConcreteStrategy）：实现Strategy接口。  优点：  策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。 策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。继承使得动态改变算法或行为变得不可能。 使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。  缺点：  客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。 策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。  策略模式的应用场景：  一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。 一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。 系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。 系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。 多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。  区别： 策略模式与工厂模式的区别？ 　从结构上看，策略模式和工厂模式都是子类继承抽象父类，通过传入参数到容器类（工厂模式的factory类，策略模式的Content类），选择对应的类进行行为操作。但是我们都知道工厂模式是创建型设计模式，而策略模式则是行为型设计模式。那两者到底有什么区别呢？
 工厂模式是用来创建对象，策略模式是让一个对象在许多行为中选择一种行为。 关注点不一样，一个关注对象的创建，一个关注的是行为封装。 解决不同的问题：工厂模式是创建型的设计模式，它接受指令，创建出符合要求的实例；它主要解决的是资源的统一分发，将对象的创建完全独立出来，让对象的创建和具体的使用客户无关。主要应用在多数据库选择，类库文件加载等。策略模式是为了解决的是策略的切换与扩展，更简洁的说是定义策略族，分别封装起来，让他们之间可以相互替换，策略模式让策略的变化独立于使用策略的客户。 工厂相当于黑盒子，策略相当于白盒子。  策略模式与桥接模式的区别？ 　在桥接模式中，Abstraction通过聚合的方式引用Implementor。策略模式中，Context也使用聚合的方式引用Strategy抽象接口。从两者的结构图可以看出，在这两种模式中，都存在一个对象使用聚合的方式引用另一个对象的抽象接口的情况，而且该抽象接口的实现可以有多种并且可以替换。可以说两者在表象上都是调用者与被调用者之间的解耦，以及抽象接口与实现的分离。但两者存在一定的区别：
 在形式上，在桥接模式中不仅Implementor具有变化（ConcreateImplementior），而且Abstraction也可以发生变化（RefinedAbstraction），而且两者的变化是完全独立的，RefinedAbstraction与ConcreateImplementior之间松散耦合，它们仅仅通过Abstraction与Implementor之间的关系联系起来。而在策略模式中，并不考虑Context的变化，只有算法的可替代性。 在语意上，桥接模式强调Implementor接口仅提供基本操作，而Abstraction则基于这些基本操作定义更高层次的操作。而策略模式强调Strategy抽象接口的提供的是一种算法，一般是无状态、无数据的，而Context则简单调用这些算法完成其操作。 桥接模式中不仅定义Implementor的接口而且定义Abstraction的接口，Abstraction的接口不仅仅是为了与Implementor通信而存在的，这也反映了结构型模式的特点：通过继承、聚合的方式组合类和对象以形成更大的结构。在策略模式中，Startegy和Context的接口都是两者之间的协作接口，并不涉及到其它的功能接口，所以它是行为模式的一种。行为模式的主要特点就是处理的是对象之间的通信方式，往往是通过引入中介者对象将通信双方解耦，在这里实际上就是将Context与实际的算法提供者解耦。 所以相对策略模式，桥接模式要表达的内容要更多，结构也更加复杂。桥接模式表达的主要意义其实是接口隔离的原则，即把本质上并不内聚的两种体系区别开来，使得它们可以松散的组合，而策略在解耦上还仅仅是某一个算法的层次，没有到体系这一层次。从结构图中可以看到，策略的结构是包容在桥接结构中的，桥接中必然存在着策略模式，Abstraction与Implementor之间就可以认为是策略模式，但是桥接模式一般Implementor将提供一系列的成体系的操作，而且Implementor是具有状态和数据的静态结构。而且桥接模式Abstraction也可以独立变化。  eg： class AbstractPay { public: virtual void pay() = 0; }; class CashPay :public AbstractPay { public: void pay() { cout &amp;lt;&amp;lt; &amp;#34;现金支付&amp;#34; &amp;lt;&amp;lt; endl; } }; class CreditcardPay :public AbstractPay { public: void pay() { cout &amp;lt;&amp;lt; &amp;#34;信用卡支付&amp;#34; &amp;lt;&amp;lt; endl; } }; //---------------------------------- class Context { private: AbstractPay* strategyPay; public: Context(AbstractPay* strategy){ this-&amp;gt;strategyPay = strategy; } void ContextPay(){ strategy-&amp;gt;Pay(); } }; //---------------------------------- //use  Context* context1; AbstractPay *basePay1 = new CashPay(); context1 = new Context(basePay1); context1-&amp;gt;ContextInterface(); Context* context2; AbstractPay *basePay2 = new CreditcardPay(); context2 = new Context(basePay2); context2-&amp;gt;ContextInterface(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 结构型模式 - 组合模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 15:01:11 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F/</guid>
      <description>组合模式： 定义： 　组合模式又叫部分整体模式，它是一种将对象组合成树状的层次结构模式，用来表示&amp;quot;部分-整体&amp;quot;的关系，使用户对单个对象和组合对象具有一致的访问性。
组合模式的角色：  抽象构建（Component）：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。 树叶构件（Leaf）：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。 树枝构件（Composite）：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。  优点：  组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的单个对象还是组合对象，这简化了客户端代码； 更容易在组合体内加入新的对象，客户端不会因为加入新的对象而更改源代码，满足OCP原则。  缺点：  设计较复杂，客户端需要花更多的时间理清类之间的层次关系； 不容易限制容器中的构件； 不容易用继承的方法来增加构件的新功能。  eg: class ComponentPtr { protected: std::string m_strName; public: ComponentPtr(std::string str) { m_strName = str; } virtual void add(ComponentPtr * p) = 0; virtual void remove(ComponentPtr * p) = 0; virtual void display() = 0; }; //----------------------------------------------- class LeafPtr : public ComponentPtr { public: LeafPtr(std::string str) : ComponentPtr(str) {} void add(ComponentPtr * p) { std::cout &amp;lt;&amp;lt; &amp;#34;Leaf cannot add&amp;#34; &amp;lt;&amp;lt; std::endl; } void remove(ComponentPtr * p) { std::cout &amp;lt;&amp;lt; &amp;#34;Leaf cannot remove&amp;#34; &amp;lt;&amp;lt; std::endl; } void display() { std::cout &amp;lt;&amp;lt; m_strName &amp;lt;&amp;lt; std::endl; } }; class CompositePtr : public ComponentPtr { private: // 这里使用智能指针不用自己释放new的内存 	std::vector&amp;lt;std::shared_ptr&amp;lt;ComponentPtr&amp;gt;&amp;gt; m_vec; public: CompositePtr(std::string str) : ComponentPtr(str) {}; ~CompositePtr() { if (!</description>
    </item>
    
    <item>
      <title>Design Patterns - 结构型模式 - 享元模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:52:09 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</guid>
      <description>享元模式： 定义： 　运用共享技术有效地支持大量细粒度对象的复用。享元模式可以避免大量相似类的开销，在软件开发中如果需要生成大量细粒度的类实例，而这些类实例除了几个参数外基本上相同，那么这时就可以使用享元模式大幅度减少实例化类的数量。如果能把这些参数移动到实例外，在方法调用时将他们传递进去，这样就可以通过共享大幅度减少单个实例的数目。这里我们把移动到类实例外部的参数称为享元对象的外部状态，把在享元对象内部定义称为内部状态。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式，他是一种结构型设计模式。
状态： 享元模式结构较为复杂，一般结合工厂模式一起使用。
 外部状态：随环境改变而改变的，不可以共享的状态。 内部状态：在享元对象内部并且不会随着环境的变化而改变的共享部分。  享元模式的角色：  抽象享元类（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。 具体享元类（ConcreteFlyweight）：它实现了抽象享元类，其实例称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。 非共享具体享元类（UnsharedConcreteFlyweight）：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。 享元工厂类（FlyweightFactory）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计；当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在的话），返回新创建的实例并将其存储在享元池中。  优点： 降低系统中的对象的数量，从而降低了系统中细粒度对象给内存带来的压力。
缺点：  为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑更复杂，使系统复杂化。 享元模式将享元对象的状态外部化，而读取外部状态使得运行时间稍微变长。  区别： 享元模式与原型模式的区别：  享元模式是结构型设计模式，而原型模式是创建型设计模式。 原型模式关注的是类的重复创建问题，而享元模式关注的是对象的创建问题。 原型模式创建的对象属性完全一样，而享元模式会根据不同的外部状态创建不一样的对象实例。  享元模式与单例模式的区别： 通过搜索我发现有许多关于享元模式与单例模式的区别，现总结如下：
 享元设计模式是一个类有很多对象，而单例是一个类仅一个对象。 享元模式是为了节约内存空间，提升程序性能（避免大量的new操作），而单例模式则主要是出于共享状态的目的。  eg: class Flyweight { public: virtual void Operation(int n) = 0; }; class ConcreteFlyweight_0 : public Flyweight { public: void Operation(int n) { std::cout &amp;lt;&amp;lt; &amp;#34;ConcreteFlyweight_0:&amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl; } }; class ConcreteFlyweight_1 : public Flyweight { public: void Operation(int n) { std::cout &amp;lt;&amp;lt; &amp;#34;ConcreteFlyweight_1:&amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl; } }; class ConcreteFlyweight_2 : public Flyweight { public: void Operation(int n) { std::cout &amp;lt;&amp;lt; &amp;#34;ConcreteFlyweight_2:&amp;#34; &amp;lt;&amp;lt; n &amp;lt;&amp;lt; std::endl; } }; //---------------------------------------------- // 享元工厂 class FlyweightFactory { private: std::map&amp;lt;int, Flyweight *&amp;gt; m_map; public: FlyweightFactory() { m_map.</description>
    </item>
    
    <item>
      <title>Design Patterns - 结构型模式 - 桥接模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:46:17 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</guid>
      <description>桥接模式： 　桥接是用于把抽象化与实现化解耦，使得两者可以独立变化。
桥接模式的角色：  抽象化角色（Abstraction）：它是用于定义抽象接口，通常是抽象类而不是接口，其中定义了一个Implementor(实现接口)类型的对象并可以维护该对象，它与Implementor之间具有关联关系。 改善后的抽象化角色（RefinedAbstraction）：通常是具体类，实现了Abstraction中的抽象方法，在RefinedAbstraction中可以调用Implementor中定义的方法。 实现者角色（Implementor）：通常情况下提供一些基本操作的声明，将具体实现交给其子类。 具体的实现者角色（ConcreteImplementorA、ConcreteImplementorB）：实现了Implementor种定义的方法，运行时根据里氏替换原则，ConcreteImplementor对象将替换其父类对象，提供给抽象对象类具体的业务操作方法。  为什么使用桥接模式？ 　我们都知道遥控器的通用功能是开机、关机，早先我们的做法应该是这样的：创建一个抽象遥控器类，里面定义开机、关机的一组方法，然后创建具体的遥控器类去继承或实现这个接口，这样就可以满足每个电视机的需求。但突然有一天，客户觉得这个遥控器的功能太少了，需要增加一个返回按钮，这个时候你傻眼了，你给抽象类添加了一个新方法，突然发现程序大面积报错，原因是子类未实现父类方法，于是霹雳巴拉一通改。好不容易改好了，客户又说了：想要一个菜单功能，于是&amp;hellip;.
　从上面的例子看出，这种设计违背了OCP原则，原因是类与类之间的耦合性过高，那怎样降低耦合呢？桥接模式是用于把抽象化和实现化解耦，使得两者可以独立变化。
优点： 抽象接口与其实现解耦，其中的抽象和实现可以独立的进行扩展，不会影响对方。
缺点： 增加了系统的复杂度。
使用场景：  如果一个系统需要在构件的抽象化角色和具体化角色之间添加更多的灵活性，避免在两个层次之间建立静态的联系； 设计要求实现化角色的任何改变不应当影响客户端，或者实现化角色的改变对客户端是完全透明的； 需要跨越多个平台的图形和窗口系统上； 一个类存在两个独立变化的维度，且两个维度都需要进行扩展。  区别： 桥接模式和适配器模式、代理模式的区别：
 桥接模式提出是为了使用变化的，即需求发生多维度变化怎么办？而适配器模式的提出是为了解决兼容性问题，即由不兼容到兼容；代理模式提出主要是为了接口隔离。  eg： class COS { public: virtual void Run(){} }; class CLinuxOS : public COS { public: void Run(){cout &amp;lt;&amp;lt; &amp;#34;LinuxOS run()&amp;#34; &amp;lt;&amp;lt; endl;} }; class CUnixOS : public COS { public: void Run(){cout &amp;lt;&amp;lt; &amp;#34;CUnixOS run()&amp;#34; &amp;lt;&amp;lt; endl;} }; //------------------------------------ class CComputer { public: virtual void InstallOS(COS *os){} }; class CIBMComputer : public CComputer { public: void InstallOS(COS *os){ os-&amp;gt;Run();} }; class CHPComputer : public CComputer { public: void InstallOS(COS *os){ os-&amp;gt;Run();} }; //------------------------------------ //use  COS *os = new CLinuxOS(); CComputer *cmptr = new CIBMComputer(); cmptr-&amp;gt;InstallOS(os); </description>
    </item>
    
    <item>
      <title>Design Patterns - 结构型模式 - 适配器模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:40:50 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</guid>
      <description>适配器模式： 　将某个类的接口转换成客户端期望的另一个接口表示，主要的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。如读卡器是作为内存卡和笔记本之间的适配器，需要将内存卡插入读卡器，再将读卡器插入笔记本，这样笔记本就可以读取内存卡了。
适配器模式的主要角色：  目标接口（Target）：当前系统业务所期待的接口，它可以是抽象类或接口。 适配者类（Adaptee）：被访问和适配的现存组件库中的组件接口。 适配器类（Adapter）：转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。  分类： 适配器模式主要分三类：
 类适配器模式、 对象适配器模式、 接口适配器模式。  优点： 　1、客户端通过适配器可以透明地调用目标接口。
　2、复用了现存的类，开发人员不需要修改原有代码而重用现有的适配者类。
　3、将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。
缺点： 　1、对类适配器来说，更换适配器的实现过程比较复杂。
　2、过多的适配器，会让系统零乱，不易整体进行把握。
类适配器模式 　当前去外地出差，工作繁忙，回到宾馆也不得不工作。当你拿出电脑，准备接电源，卧槽&amp;hellip;不支持！！！电源是两孔的，而插座是三孔的，怎么办呢？你会想到去楼下小商店买个转换插座，将三孔插座转成两孔的来用，简直太聪明了。
class ThreePhaseOutlet { public: void doThreePhasePlugin() { cout&amp;lt;&amp;lt;&amp;#34;三相插头强势插入！&amp;#34;&amp;lt;&amp;lt;endl; } }; class TwoPhaseOutlet { public: virtual void doPlugin() = 0; }; class OutletConvertor: public TwoPhaseOutlet,public ThreePhaseOutlet { public: void doPlugin() { doConvertor(); doThreePhasePlugin(); }	void doConvertor() { cout&amp;lt;&amp;lt;&amp;#34;三相插头转为两厢插头！&amp;#34;&amp;lt;&amp;lt;endl; } }; 对象适配器模式 　当手机没电需要充电，你不可能直接使用220V的电压，如果你真这么做了，请注意人身安全及购买一台新机。此时，充电器就起到了转换器的作用，将220V电压转换成手机可使用的5V电压。</description>
    </item>
    
    <item>
      <title>Design Patterns - 结构型模式 - 外观模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:35:57 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>外观模式： 　外部通过一个统一的接口，访问子系统中的一群接口。外观模式定义了一个高层接口，为子系统中的一组接口提供一个一致的入口，使得子系统更容易使用。外观模式相对比较简单，可以理解为中介，原先租房需要自己一个个筛选，联系房东，谈好价格，签合同等等，现在不需要这些了，只要你说出要求中介就会将房子找好，你只需要掏钱签合同就可以了，不需要关系其他琐碎的事情。
外观模式的角色：  外观角色：为多个子系统对外提供一个共同的接口； 子系统角色：实现系统的部分功能，客户可以通过外观角色访问它； 客户角色：通过一个外观角色访问各个子系统的功能。  优点： 外观模式是迪米特法则的典型应用。
 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类； 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易； 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。  缺点：  不能很好的限制客户使用子系统； 违背了开闭原则  eg： class SysOne { public: SysOne(); virtual ~SysOne(); void FuncOne(){ cout&amp;lt;&amp;lt;&amp;#34;FuncOne&amp;#34;&amp;lt;&amp;lt;endl; } }; class SysTwo { public: SysTwo (); virtual ~SysTwo (); void FuncTwo(){ cout&amp;lt;&amp;lt;&amp;#34;FuncTwo&amp;#34;&amp;lt;&amp;lt;endl; } }; class SysThree { public: SysThree (); virtual ~SysThree (); void FuncThree(){ cout&amp;lt;&amp;lt;&amp;#34;FuncThree&amp;#34;&amp;lt;&amp;lt;endl; } }; //------------------------ class Facade { public: Facade(){ p1 = new SysOne(); p2 = new SysTwo(); p3 = new SysThree(); } void FuncA(){ p1-&amp;gt;FuncOne(); p2-&amp;gt;FuncTwo(); } void FuncB(){ p1-&amp;gt;FuncOne(); p3-&amp;gt;FuncThree(); } virtual ~Facade(); private: SysOne *p1; SysTwo *p2; SysThree *p3; }; Facade * p =new Facade(); p-&amp;gt;FuncA(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 结构型模式 - 装饰模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:29:09 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F/</guid>
      <description>装饰者模式： 　允许向一个现有的对象添加新的功能，同时又不改变其结构。装饰器模式是一种用于代替继承的技术，无需通过继承增加子类就能扩展对象的新功能。使用对象的关联关系代替继承关系，更加灵活，同时避免类型体系的快速膨胀。
装饰者模式有四个角色： 　1）抽象构建（Component ）：给出一个抽象接口，来规范被添加职责的对象；
　2）具体构件（ConcreteComponent）：定义一个将要接收附加责任的具体对象；
　3）装饰抽象类（Decorator）：持有一个构件（Component）对象的实例，并定义一个与抽象构件接口一致的接口；
　4）具体装饰对象（ConreteDecorator）：负责给构件对象 ”贴上“附加的责任。起到给Component添加职责的功能。
要点： 　1）装饰者和被装饰对象有相同的超类型。
　2）可以用一个或多个装饰者包装一个对象。
　3）装饰者可以在所委托被装饰者的行为之前或之后，加上自己的行为，以达到特定的目的。
　4）对象可以在任何时候被装饰，所以可以在运行时动态的，不限量的用你喜欢的装饰者来装饰对象。
　5）装饰模式中使用继承的关键是想达到装饰者和被装饰对象的类型匹配，而不是获得其行为。
　6）装饰者一般对组件的客户是透明的，除非客户程序依赖于组件的具体类型。在实际项目中可以根据需要为装饰者添加新的行为，做到“半透明”装饰者。
优点：  装饰这模式和继承的目的都是扩展对象的功能，但装饰者模式比继承更灵活； 通过使用不同的具体装饰类以及这些类的排列组合，设计师可以创造出很多不同行为的组合； 装饰者模式有很好地可扩展性  缺点： 装饰者模式会导致设计中出现许多小对象，如果过度使用，会让程序变的更复杂。并且更多的对象会是的差错变得困难，特别是这些对象看上去都很像。
区别： 装饰者模式与代理模式的区别：  两种模式的关注点不同，装饰者模式关注的是在一个对象上动态的添加方法，而代理模式关注的是控制对象的访问。 装饰者模式可以让使用者直观的看到增强了哪些功能，而代理模式完全限制了使用者，只去调用代理，至于代理里面增加了什么功能，使用者是不知道，隐藏了一个对象的具体信息，这正是为什么代理模式在初始化时不能像装饰模式一样传入一个原始对象的参数的原因。 代理和真实对象之间的的关系通常在编译时就已经确定了，而装饰者能够在运行时递归地被构造。  //公共抽象类 class Phone { public: Phone() {} virtual ~Phone() {} virtual void ShowDecorate() {} }; //-------------------------------- //具体的手机类 class iPhone : public Phone { private: string m_name; //手机名称 public: iPhone(string name): m_name(name){} ~iPhone() {} void ShowDecorate() { cout&amp;lt;&amp;lt;m_name&amp;lt;&amp;lt;&amp;#34;的装饰&amp;#34;&amp;lt;&amp;lt;endl;} }; class NokiaPhone : public Phone { private: string m_name; public: NokiaPhone(string name): m_name(name){} ~NokiaPhone() {} void ShowDecorate() { cout&amp;lt;&amp;lt;m_name&amp;lt;&amp;lt;&amp;#34;的装饰&amp;#34;&amp;lt;&amp;lt;endl;} }; //-------------------------------- //装饰类 class DecoratorPhone : public Phone { private: Phone *m_phone; //要装饰的手机 public: DecoratorPhone(Phone *phone): m_phone(phone) {} virtual void ShowDecorate() { m_phone-&amp;gt;ShowDecorate(); } }; class DecoratorPhoneA : public DecoratorPhone { public: DecoratorPhoneA(Phone *phone) : DecoratorPhone(phone) {} void ShowDecorate() { DecoratorPhone::ShowDecorate(); cout&amp;lt;&amp;lt;&amp;#34;增加挂件&amp;#34;&amp;lt;&amp;lt;endl; } //增加的装饰 }; class DecoratorPhoneB : public DecoratorPhone { public: DecoratorPhoneB(Phone *phone) : DecoratorPhone(phone) {} void ShowDecorate() { DecoratorPhone::ShowDecorate(); cout&amp;lt;&amp;lt;&amp;#34;屏幕贴膜&amp;#34;&amp;lt;&amp;lt;endl; } }; //-------------------------------- //use 	Phone *iphone = new NokiaPhone(&amp;#34;6300&amp;#34;); Phone *dpa = new DecoratorPhoneA(iphone); //装饰，增加挂件 	Phone *dpb = new DecoratorPhoneB(dpa); //装饰，屏幕贴膜 	dpb-&amp;gt;ShowDecorate(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 结构型模式 - 代理模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:21:20 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%BB%93%E6%9E%84%E5%9E%8B-%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</guid>
      <description>代理模式： 　代理模式就是给某一个对象提供一个代理，并由代理对象控制对原有对象的引用。在一些情况下，一个客户不想或者不能直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。例如windows桌面端的快捷方式就是一个代理。
代理模式按照使用目的可以分为：
 远程代理：为一个位于不同的地址空间的对象提供一个局域代表对象。这个不同的地址空间可以是本电脑中，也可以在另一台电脑中。如客户端调用web服务或wcf服务。 虚拟代理：根据需要创建一个资源消耗较大的对象，使得对象只在需要时才会被真正创建。 Copy-on-Write代理：虚拟代理的一种，把复制（或克隆）拖延到只有在客户端需要时，才真正采取行动。 保护（Protected or Access）代理：控制一个对象的访问，可以给不同的用户提供不同级别的使用权限。 Cache代理：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以操作这些结果。 防火墙（FireWall）代理：保护目标不让恶意用户接近。 同步化（Synchronization）代理 智能引用（Smart Reference）代理：当一个对象被引用时，提供一些额外的操作，比如将对此对象调用的次数记录下来。  代理模式角色分四种： 　1）主题接口（Searcher）：定义代理类和真实主题的公共对外方法，也是代理类代理真实主题的方法；
　2）真实主题（RealSeracher）：真正实现业务逻辑的类；
　3）代理类（ProxySeracher）：用来代理和封装真实主题；
　4）客户端：使用代理类和主题完成工作。
优点： 　1）代理模式能够将调用用于真正被调用的对象隔离，在一定程度上降低了系统的耦合度；
　2）代理对象在客户端和目标对象之间起到一个中介的作用，这样可以起到对目标对象的保护。代理对象可以在对目标对象发出请求之前进行一个额外的操作，例如权限检查等。
缺点： 　1）由于在客户端和真实主题之间增加了一个代理对象，所以会造成请求的处理速度变慢；
　2）实现代理类也需要额外的工作，从而增加了系统的实现复杂度。
区别： 代理模式与适配器模式的区别？ 　学习完适配器模式和代理模式之后，会产生这样的疑问：貌似两种模式差不多？两者都是定义了一个目标对象（抽象对象），客户端依赖该抽象对象完成相应功能，这么一解释好像是一样的，那为什么大牛们会分成两种模式呢？适配器模式是因为新旧接口不一致导致出现了客户端无法得到满足的问题，但由于旧的接口是不能被完全重构掉的，因为我们还想使用实现了这个接口的一些服务。那么为了使用以前实现旧接口的服务，我们就应该把新的接口转换成旧接口；实现这个转换的类就是抽象意义的转换器。相比于适配器的应用场景，代理就不一样了，虽然代理也同样是增加了一层，但是，代理提供的接口和原本的接口是一样的，代理模式的作用是不把实现直接暴露给客户端，而是通过代理这个层，代理能够做一些处理。
代理模式与委托的区别？  代理是模式提供一种&amp;quot;一个类对另外一个类的控制权&amp;quot;是类与类之间关系；委托提供了&amp;quot;一种方法的执行会同时执行加载在上面的方法&amp;quot;是方法与方法之间的关系。 委托可以代替代理，但是代理不能代替委托。 委托可以动态加载方法，代理不能实现。 委托对象所加载的方法不一定要属于同一个类。但是代理的类必须属于同一个类。   eg: class SchoolGirl { public: SchoolGirl(string name):mName(name){}; virtual ~SchoolGirl(); string getName(){ return mName; } private: string mName; }; //-------------------------------- class GiveGift { public: GiveGift(); virtual ~GiveGift(); virtual void GiveDolls() = 0; virtual void GiveFlowers() = 0; virtual void GiveChocolate() = 0; }; class Pursuit : GiveGift{ public: Pursuit(SchoolGirl *p): pSchoolGirl(p){}; virtual ~Pursuit(); SchoolGirl *pSchoolGirl; virtual void GiveDolls() { cout&amp;lt;&amp;lt;pSchoolGirl-&amp;gt;getName()&amp;lt;&amp;lt;&amp;#34;GiveDolls&amp;#34;&amp;lt;&amp;lt;endl; } virtual void GiveFlowers() { cout&amp;lt;&amp;lt;pSchoolGirl-&amp;gt;getName()&amp;lt;&amp;lt;&amp;#34;GiveFlowers&amp;#34;&amp;lt;&amp;lt;endl; } virtual void GiveChocolate() { cout&amp;lt;&amp;lt;pSchoolGirl-&amp;gt;getName()&amp;lt;&amp;lt;&amp;#34;GiveChocolate&amp;#34;&amp;lt;&amp;lt;endl; } }; class Proxy : GiveGift{ public: Proxy(SchoolGirl *p){ pPursuit = new Pursuit(p); }; virtual ~Proxy(); Pursuit *pPursuit; virtual void GiveDolls() { pPursuit-&amp;gt;GiveDolls(); } virtual void GiveFlowers() { pPursuit-&amp;gt;GiveFlowers(); } virtual void GiveChocolate() { pPursuit-&amp;gt;GiveChocolate(); } }; //-------------------------------- //use  SchoolGirl *p =new SchoolGirl(&amp;#34;girl&amp;#34;); Proxy *daili =new Proxy(p); daili-&amp;gt;GiveDolls(); daili-&amp;gt;GiveFlowers(); daili-&amp;gt;GiveChocolate(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 创建型模式 - 建造者模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:14:54 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</guid>
      <description>建造者模式 引言： 　无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、底盘、发动机、方向盘等各种部件。而对于大部分用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车。有的人说：抽象工厂模式不是用来生产产品的吗，我们使用它来解决不是可以了吗？貌似有一定的道理，但是你有没有考虑到了安装细节，每辆汽车的零部件安装细节可能是不同的。抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。那怎么办呢？于是，建造者模式应运而生。
介绍： 　建造者模式又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。
　建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构造细节。
建造者模式有四个角色：  Product（产品）：一个具体的产品对象。（也可以使用抽象工厂模式来进行细分） Builder（抽象建造者）：创建一个Product对象的各个部件指定的接口。 ConcreteBuilder（具体建造者）：实现接口，构建和装配各个部件。 Diretor（指挥者）：构建一个使用Builder接口的对象。它主要是用于创建一个复杂的对象。它主要有两个作用，一是：隔离客户与对象的生产过程，二是：负责控制产品对象的生产过程。  建造者模式的优点：  客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象 。 可以更加精细地控制产品的创建过程。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合OCP原则。  建造模式的缺点：  产品之间差异性很大的情况： 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。 产品内部变化很复杂的情况： 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。  eg： class Product { public: Product(); virtual ~Product(); void Add(string part){ mParts.push_back(part); } void Show(){ list &amp;lt;string&amp;gt;::iterator iter; for(iter = mParts.begin();iter!= mParts.end();iter++){ cout &amp;lt;&amp;lt; *iter &amp;lt;&amp;lt;&amp;#34; &amp;#34;&amp;lt;&amp;lt;endl; } } list &amp;lt;string&amp;gt; mParts ; }; //-------------------------------------- class Builder { public: Builder(); virtual ~Builder(); virtual void BuildPartA() = 0; virtual void BuildPartB() = 0; virtual Product* GetResult() = 0; }; class ConcreteBuilder1 :public Builder{ public: ConcreteBuilder1(){ pPro = new Product; }; virtual ~ConcreteBuilder1(); void BuildPartA(){ pPro-&amp;gt;Add(&amp;#34;Part A&amp;#34;); } void BuildPartB(){ pPro-&amp;gt;Add(&amp;#34;Part B&amp;#34;); } Product* GetResult(){ return pPro; } private: Product *pPro; }; class ConcreteBuilder2 :public Builder{ public: ConcreteBuilder2(){ pPro =new Product(); } virtual ~ConcreteBuilder2(); void BuildPartA(){ pPro-&amp;gt;Add(&amp;#34;Part X&amp;#34;); } void BuildPartB(){ pPro-&amp;gt;Add(&amp;#34;Part Y&amp;#34;); } Product* GetResult(){ return pPro; } private: Product *pPro; }; //-------------------------------------- class Director { public: Director(); virtual ~Director(); void Construct(Builder *build){ //告诉指挥者，需要什么样的小人 	build-&amp;gt;BuildPartA();//根据用户的选择建造小人 	build-&amp;gt;BuildPartB(); } }; //use 	Director * d= new Director(); Builder* b1 =new ConcreteBuilder1(); Builder* b2 =new ConcreteBuilder2(); d-&amp;gt;Construct(b1); b1-&amp;gt;GetResult()-&amp;gt;show(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 创建型模式 - 单例模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:09:02 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>单例模式 前言： 　单例模式，顾名思义，只存在一个实例。官方定义：对于类的单例模式设计，就是采取一定的方法保证在整个软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法（静态方法）。
　单例模式在写法上有很多种，
有饿汉式（类加载的时候实例化），
懒汉式（类在使用的时候实例化），
保证线程安全的写法等。具体如下：(删除线表示不推荐使用)
　① 饿汉式（静态常量）
　② 饿汉式（静态代码块）
　③ 懒汉式（线程不安全）
　④ 懒汉式（线程安全，同步方法）
　⑤ 懒汉式（线程安全，同步方法）
　⑥ 双重检查double check
　⑦ 静态内部类
　⑧ 枚举
　在IOC模式中，通常使用生命周期来实现单例，如services.AddSingleton();
懒汉式 懒汉式(Lazy-Initialization)的方法是直到使用时才实例化对象，
也就说直到调用get_instance() 方法的时候才 new 一个单例的对象。
好处是如果被调用就不会占用内存。
class Singleton{ private: Singleton(){ std::cout&amp;lt;&amp;lt;&amp;#34;constructor called!&amp;#34;&amp;lt;&amp;lt;std::endl; } Singleton(Singleton&amp;amp;)=delete; Singleton&amp;amp; operator=(const Singleton&amp;amp;)=delete; static Singleton* m_instance_ptr; public: ~Singleton(){ std::cout&amp;lt;&amp;lt;&amp;#34;destructor called!&amp;#34;&amp;lt;&amp;lt;std::endl; } static Singleton* get_instance(){ if(m_instance_ptr==nullptr){ m_instance_ptr = new Singleton; } return m_instance_ptr; } void use() const { std::cout &amp;lt;&amp;lt; &amp;#34;in use&amp;#34; &amp;lt;&amp;lt; std::endl; } }; Singleton* Singleton::m_instance_ptr = nullptr; Singleton* instance = Singleton::get_instance(); Singleton* instance_2 = Singleton::get_instance(); return 0;  线程安全的问题,当多线程获取单例时有可能引发竞态条件：第一个线程在if中判断 m_instance_ptr是空的，于是开始实例化单例;同时第2个线程也尝试获取单例，这个时候判断m_instance_ptr还是空的，于是也开始实例化单例;这样就会实例化出两个对象,这就是线程安全问题的由来; 解决办法:加锁 内存泄漏.</description>
    </item>
    
    <item>
      <title>Design Patterns - 创建型模式 - 原型模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Fri, 06 Nov 2020 14:02:53 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</guid>
      <description>原型模式 引言： 　原型模式是什么？它是在什么场景下被提出的呢？本章节，我们将详细了解下原型模式。
　在软件系统中，当创建一个类的实例过程过于昂贵或复杂，并且我们需要创建多个这样类的实例时，
 如果我们通过new来创建类实例，这就会增加创建类的复杂度和创建过程与客户代码复杂的耦合度。 如果采用工厂模式来创建这样的实例对象的话，随着产品类的不断增加，导致子类的数量不断增多，也导致了相应工厂类的增加，维护的代码维度增加了，因为有产品和工厂两个维度了，反而增加了系统复杂程度，所以在这里使用工厂模式来封装类创建过程并不合适。 由于每个类实例都是相同的（类型相同），但是每个实例的状态参数会有不同，如果状态数值也相同就没意义了，有一个这样的对象就可以了。 当我们需要多个相同的类实例时，可以通过对原来对象拷贝一份来完成创建，这个思路正是原型模式的实现方式。  定义： 　原型模式就是通过给出一个原型对象来指明所要创建的对象类型，然后用复制这个对象的方法来创建更多的同类型对象。
原型模式的两种类型： 　object类的clone方法只会拷贝对象中基本的数据类型，对于数组、容器对象、引用对象等都不会拷贝，这就是浅拷贝。如果要实现深拷贝，必须将原型模式中的数组、容器对象、引用对象等另行拷贝。
深拷贝： 　1、复制对象的基本数据类型的成员变量值。
　2、为所有引用类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行拷贝。
　3、深拷贝实现方式1：重写clone方法。
　4、深拷贝实现方式2：通过对象序列化。
原型模式的注意事项和细节： 　1、创建新的对象比较复杂时，可以利用原型模式简化对象的创建过程，同时也能够提高效率。
　2、不用重新初始化对象，而是动态地获取对象运行时的状态。
　3、如果原始对象发生变化（增加或减少属性），其它克隆对象也会发生相应的变化，无需修改代码。
　4、在实现深克隆的时候可能需要比较复杂的代码。　　5、使用原型模式复制不会调用类的构造方法。因为对象的复制是通过调用clone方法完成的，它直接在内存种复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。单例模式中，我们通过私有化构造函数来实现单例模式，但clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的。
原型模式的优点： 　1、原型模式向客户隐藏了创建新实例的复杂性。
　2、原型模式允许动态增加或较少产品类。
　3、原型模式简化了实例的创建结构，工厂方法模式需要有一个与产品类等级结构相同的等级结构，而原型模式不需要这样。
　4、产品类不需要事先确定产品的等级结构，因为原型模式适用于任何的等级结构。
缺点： 　1、需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但对已有的类进行改造时，需要修改源码，即违反了OCP原则。
eg： class Prototype { private: string str; public: Prototype(string s) { str = s; } void show() { cout &amp;lt;&amp;lt; str &amp;lt;&amp;lt; endl; } virtual Prototype *clone() = 0; }; class ConcretePrototype1 :public Prototype { public: ConcretePrototype1(string s) :Prototype(s) {} ConcretePrototype1(){} virtual Prototype *clone() { ConcretePrototype1 *p = new ConcretePrototype1(); *p = *this; return p; } }; class ConcretePrototype2 :public Prototype { public: ConcretePrototype2(string s) :Prototype(s) {} ConcretePrototype2(){} virtual Prototype *clone() { ConcretePrototype2 *p = new ConcretePrototype2(); *p = *this; return p; } }; //use  ConcretePrototype1 *test = new ConcretePrototype1(&amp;#34;小李&amp;#34;); ConcretePrototype2 *test2 = (ConcretePrototype2 *)test-&amp;gt;clone(); test-&amp;gt;show(); test2-&amp;gt;show(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 创建型模式 - 抽象工厂模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 05 Nov 2020 20:19:07 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>抽象工厂模式 前一章节，我们介绍了简单工厂模式以及工厂方法模式，但是这两种模式都存在一定的局限性，只能生产某一类型下的某一种产品，如果需求变更，同类型下出现了不同的产品，比如芝士披萨不仅有口味上的不同，同时存在外观上的不同。这种时候，工厂模式显然不再满足要求，该怎么办呢？于是我们想到DIP原则，它不正是为了解决这种情况而存在的吗？接下来我们来介绍下抽象工厂模式：
  抽象工厂模式定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类。
  抽象工厂模式可以将简单工厂模式和工厂方法模式进行整合。
  从设计层面来说，抽象工厂模式就是对简单工厂模式的改进（即进一步抽象化）
  将工厂抽象成两层，抽象工厂和具体的实现工厂。
  理解： 读过一些博主的博文以及评论，有一些理解还是蛮到位的：
 抽象工厂比工厂方法复杂的多，它们的目的不同。工厂方法意在延迟加载，而抽象方法意在高内聚低耦合。 工厂方法模式的具体工厂类只能创建一个具体产品类的实例，而抽象工厂可以创建多个。  // 键盘 class KeyBoard { public: virtual void show() = 0; }; // 微软的键盘 class KeyBoardMicro : public KeyBoard { public: void show() { std::cout &amp;lt;&amp;lt; &amp;#34;微软的键盘&amp;#34; &amp;lt;&amp;lt; std::endl; } }; // 联想的键盘 class KeyBoardLenovo : public KeyBoard { public: void show() { std::cout &amp;lt;&amp;lt; &amp;#34;联想的键盘&amp;#34; &amp;lt;&amp;lt; std::endl; } }; class Mouse { public: virtual void show() = 0; }; // 微软的鼠标 class MouseMicro : public Mouse { public: void show() { std::cout &amp;lt;&amp;lt; &amp;#34;微软的鼠标&amp;#34; &amp;lt;&amp;lt; std::endl; } }; // 联想的鼠标 class MouseLenovo : public Mouse { public: void show() { std::cout &amp;lt;&amp;lt; &amp;#34;联想的鼠标&amp;#34; &amp;lt;&amp;lt; std::endl; } }; //----------------------------------------- class Factory { public: virtual KeyBoard * createKeyBoard() = 0; virtual Mouse * createMouse() = 0; }; // 微软的工厂 class FactoryMicro : public Factory { public: KeyBoard * createKeyBoard() { return new KeyBoardMicro(); } Mouse * createMouse() { return new MouseMicro(); } }; // 联想的工厂 class FactoryLenovo : public Factory { public: KeyBoard * createKeyBoard() { return new KeyBoardLenovo(); } Mouse * createMouse() { return MouseLenovo(); } }; //----------------------------------------- //use 	// 抽象工厂模式 	Factory * p = new FactoryMicro(); KeyBoard * pKeyBoard = p-&amp;gt;createKeyBoard(); pKeyBoard-&amp;gt;show(); auto pMouse = p-&amp;gt;createMouse(); pMouse-&amp;gt;show(); </description>
    </item>
    
    <item>
      <title>Design Patterns - 创建型模式 - 工厂模式</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</link>
      <pubDate>Thu, 05 Nov 2020 20:07:15 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%88%9B%E5%BB%BA%E5%9E%8B-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</guid>
      <description>工厂设计模式： 　顾名思义，该模式是用来生产对象的。在面向对象的设计模式中，万物皆对象，若使用new来创建对象，就会对该对象产生强耦合，假如我们需要更换该对象，那么使用该对象的对象都需要进行修改，这显然违背了开闭原则（OCP）。如果我们使用工厂来产生对象，我们只需要与这个工厂打交道就可以了，无需关心具体的对象，达到解耦的目的。
　接下来我们从实际的案例出发，从无工厂到有工厂的区别。
eg 有一个销售管理系统支持多种支付方式，如现金支付，信用卡支付，代金券支付等。
在设计过如果不使用简单工厂模式，可能会存在如下的支付方式。
void pay(string pay_type) { if(pay_type==现金) { 现金支付处理手段 } else if(pay_type==信用卡) { 信用卡支付处理 } else if(pay_type==代金券) { 代金券处理 } ........ } 简单工厂模式包含三个角色：   工厂角色（Factory）
  抽象产品角色(Product)
  具体产品角色(ConcreteProduct)
  简单工厂模式优缺点：  由代码可以看出，虽然简单工厂模式一定程度上减少了因需求变更而导致的代码更改，但是实际仍违背了OCP原则。 所以简单工厂模式只适合产品对象相对较少，且产品固定的需求，对产品变化无常的需求来说显然不适合。  使用： //	将各种支付方式写成统一的抽象方法，为各种支付方式提供统一的接口 class AbstractPay { public: virtual void pay() = 0; }; //	将每种支付方式封装在一个独立的类中，各个支付方式类相对独立修改其一对于其他类没有任何影响， //	这些独立的支付方式类充当具体的产品类角色。是抽象类的派生类 class CashPay :public AbstractPay { public: void pay() { cout &amp;lt;&amp;lt; &amp;#34;现金支付&amp;#34; &amp;lt;&amp;lt; endl; } }; class CreditcardPay :public AbstractPay { public: void pay() { cout &amp;lt;&amp;lt; &amp;#34;信用卡支付&amp;#34; &amp;lt;&amp;lt; endl; } }; //	将针对于个种支付方式的对象的创建封装成一个统一的方法中，即：工厂化。 class PayMethodFactory { public: AbstractPay* getPayMethod(string type) { if (type == &amp;#34;cash&amp;#34;) { return new CashPay(); } else { return new CreditcardPay(); } } }; int main() { PayMethodFactory *pmf = new PayMethodFactory(); //基类指针指向带有虚函数的派生类对象形成多态 	AbstractPay* p = pmf-&amp;gt;getPayMethod(&amp;#34;cash&amp;#34;); //假定现在是现金支付 	p-&amp;gt;pay(); system(&amp;#34;pause&amp;#34;); return 0; } 工厂方法设计模式： 披萨项目需求变更，客户点披萨时可以点不同口味的披萨。</description>
    </item>
    
    <item>
      <title>Design Patterns - 开闭原则</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 05 Nov 2020 19:54:08 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E5%BC%80%E9%97%AD%E5%8E%9F%E5%88%99/</guid>
      <description>开闭原则： ​	软件对象（类、模块、方法等）应该对于扩展是开放的，对修改是关闭的。比如：一个网络模块，原来只有服务端功能，而现在要加入客户端功能，那么应当在不用修改服务端功能代码的前提下，就能够增加客户端功能的实现代码，这要求在设计之初，就应当将客户端和服务端分开。公共部分抽象出来。
问题由来：
　在软件的生命周期内，因为变化、升级和维护等原因需要对软件原有代码进行修改时，可能会给旧代码中引入错误，也可能会使我们不得不对整个功能进行重构，并且需要原有代码经过重新测试。
解决办法：
　当软件需要变化时，尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来实现变化。
　开闭原则是面向对象设计中最基础的设计原则，它指导我们如何建立稳定灵活的系统。开闭原则可能是设计模式六项原则中定义最模糊的一个了，它只告诉我们对扩展开放，对修改关闭，可是到底如何才能做到对扩展开放，对修改关闭，并没有明确的告诉我们。以前，如果有人告诉我&amp;quot;你进行设计的时候一定要遵守开闭原则&amp;quot;，我会觉的他什么都没说，但貌似又什么都说了。因为开闭原则真的太虚了。
　在仔细思考以及仔细阅读很多设计模式的文章后，终于对开闭原则有了一点认识。其实，我们遵循设计模式前面5大原则，以及使用23种设计模式的目的就是遵循开闭原则。也就是说，只要我们对前面5项原则遵守的好了，设计出的软件自然是符合开闭原则的，这个开闭原则更像是前面五项原则遵守程度的&amp;quot;平均得分&amp;quot;，前面5项原则遵守的好，平均分自然就高，说明软件设计开闭原则遵守的好；如果前面5项原则遵守的不好，则说明开闭原则遵守的不好。
　其实笔者认为，开闭原则无非就是想表达这样一层意思：用抽象构建框架，用实现扩展细节。因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节，我们用从抽象派生的实现类来进行扩展，当软件需要发生变化时，我们只需要根据需求重新派生一个实现类来扩展就可以了。当然前提是我们的抽象要合理，要对需求的变更有前瞻性和预见性才行。
　说到这里，再回想一下前面说的5项原则，恰恰是告诉我们用抽象构建框架，用实现扩展细节的注意事项而已：
 单一职责原则告诉我们实现类要职责单一； 里氏替换原则告诉我们不要破坏继承体系； 依赖倒置原则告诉我们要面向接口编程； 接口隔离原则告诉我们在设计接口的时候要精简单一； 迪米特法则告诉我们要降低耦合。 而开闭原则是总纲，他告诉我们要对扩展开放，对修改关闭。  为什么使用开闭原则？ 　1、只要是面向对象的编程，在开发过程中都会强调开闭原则
　2、是最基础的设计原则，其他五个设计原则都是开闭原则的具体形态
　3、可以提高代码的复用性
　4、可以提高代码的可维护性
如何使用开闭原则？ 　1、抽象约束
　抽象对一组事物的通用描述，没有具体的实现，也就表示它可以有非常多的可能性，可以跟随需求的变化而变化。因此，通过接口或抽象类可以约束一组可能变化的行为，并且能够实现对扩展开放。
　2、元数据控件模块行为　　3、制定项目章程
　4、封装变化
　将相同的变化封装到一个接口或抽象类中，将不同的变化封装到不同的接口或抽象类中，不应该有两个不同变化出现在同一个接口或抽象类中。</description>
    </item>
    
    <item>
      <title>Design Patterns - 迪米特法则</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</link>
      <pubDate>Thu, 05 Nov 2020 19:51:41 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99/</guid>
      <description>迪米特法则： 　也叫最少知识原则。迪米特法则的定义是只与你的直接朋友交谈，不与&amp;quot;陌生人&amp;quot;说话。如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该应用。其目的是降低类之间的耦合度，提高模块的相对独立性。
　迪米特法则中的朋友是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。
优点： 　1、降低类之间的耦合度，提高模块的相对独立性。
　2、由于亲和度降低，从而提高了类的可复用率和系统的扩展性。
缺点： 　过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。所以，在釆用迪米特法则时需要反复权衡，确保高内聚和低耦合的同时，保证系统的结构清晰。
注意： 使用迪米特法则需要注意：
　1、在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。
　2、在类的结构设计上，尽量降低类成员的访问权限。
　3、在类的设计上，优先考虑将一个类设置成不变类。
　4、在对其他类的引用上，将引用其他对象的次数降到最低。
　5、不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。
　6、谨慎使用序列化（Serializable）功能。</description>
    </item>
    
    <item>
      <title>Design Patterns - 里氏替换原则</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 05 Nov 2020 19:48:54 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99/</guid>
      <description>里氏替换原则： 　子类应当可以替换父类并出现在父类能够出现的地方。比如：公司搞年度派对，都有员工都可以抽奖，那么不管是新员工还是老员工，也不管是总部员工还是外派员工，都应当可以参加抽奖。
　里氏替换至少包含一下两个含义：
 里氏替换原则是针对继承而言的，如果继承是为了实现代码重用，也就是为了共享方法，那么共享的父类方法就应该保持不变，不能被子类重新定义。子类只能通过新添加方法来扩展功能，父类和子类都可以实例化，而子类继承的方法和父类是一样的，父类调用方法的地方，子类也可以调用同一个继承得来的，逻辑和父类一致的方法，这时用子类对象将父类对象替换掉时，当然逻辑一致，相安无事。 如果继承的目的是为了多态，而多态的前提就是子类覆盖并重新定义父类的方法，为了符合LSP，我们应该将父类定义为抽象类，并定义抽象方法，让子类重新定义这些方法，当父类是抽象类时，父类就是不能实例化，所以也不存在可实例化的父类对象在程序里。也就不存在子类替换父类实例（根本不存在父类实例了）时逻辑不一致的可能。  要求： 里氏转换原则应满足以下要求：
　1、子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法
　2、子类可以增加自己特有的方法
　3、当子类的方法重载父类的方法时，方法的形参要比父类方法的输入参数更宽松
　4、当子类的方法实现父类的抽象方法时，方法的返回值应比父类更严格
优点： 　可以大大减少程序的bug以及增强代码的可读性</description>
    </item>
    
    <item>
      <title>Design Patterns - 依赖倒置原则</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 05 Nov 2020 19:46:00 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99/</guid>
      <description>依赖倒置原则：　 　1、高层模块不应该依赖底层模块，二者都应该依赖抽象。
　2、抽象不应该依赖细节，细节应该依赖抽象。
　3、依赖倒置的中心思想是面向接口编程。
　4、依赖倒置原则是基于这样的设计理念：相对于细节的多变性，抽象的东西要稳定的多。以抽象为基础搭建的架构比以细节为基础搭建的架构要稳定的多。
　5、使用接口或抽象类的目的是指定好规范，而不涉及任何具体的操作，把展现细节的任务交给他们的实现类来完成。
本质： 依赖倒置原则的本质就是通过抽象(接口或抽象类)使各个类或模块的实现彼此独立，不互相影响，实现模块间的松耦合。我们在项目中使用这个原则要遵循下面的规则：
　1、每个类尽量都有接口或者抽象类，或者抽象类和接口两都具备
　2、变量的表面类型尽量是接口或者抽象类
　3、任何类都不应该从具体类派生
　4、尽量不要覆写基类的方法
　5、如果基类是一个抽象类，而这个方法已经实现了，子类尽量不要覆写。类间依赖的是抽象，覆写了抽象方法，对依赖的稳定性会有一定的影响
　6、结合里氏替换原则使用</description>
    </item>
    
    <item>
      <title>Design Patterns - 接口隔离原则</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 05 Nov 2020 19:40:00 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99/</guid>
      <description>接口隔离原则： 　1、客户端不应依赖它不需要的接口
　2、类间的依赖关系应该建立在最小的接口上
 其实通俗来理解就是，不要在一个接口里面放很多的方法，这样会显得这个类很臃肿。 接口应该尽量细化，一个接口对应一个功能模块，同时接口里面的方法应该尽可能的少，使接口更加灵活轻便。 或许有的人认为接口隔离原则和单一职责原则很像，但两个原则还是存在着明显的区别。 单一职责原则是在业务逻辑上的划分，注重的是职责。接口隔离原则是基于接口设计考虑。  例如一个接口的职责包含10个方法，这10个方法都放在同一接口中，并且提供给多个模块调用，但不同模块需要依赖的方法是不一样的，这时模块为了实现自己的功能就不得不实现一些对其没有意义的方法，这样的设计是不符合接口隔离原则的。   接口隔离原则要求&amp;quot;尽量使用多个专门的接口&amp;quot;专门提供给不同的模块。  </description>
    </item>
    
    <item>
      <title>Design Patterns - 单一职责原则</title>
      <link>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</link>
      <pubDate>Thu, 05 Nov 2020 19:30:09 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%88%99-%E5%8D%95%E4%B8%80%E8%81%8C%E8%B4%A3%E5%8E%9F%E5%88%99/</guid>
      <description>单一职责原则： 　对象不应承担太多功能，正如一心不能而用，比如太多的工作(种类)会使人崩溃。唯有专注才能保证对象的高内聚；唯有唯一，才能保证对象的细粒度。
解决问题： 　假如有A和B两个类，当A需求发生改变需要修改时，不能导致B类出问题。
现状： 　在实际情况很难去做到单一职责原则，因为随着业务的不断变更，类的职责也在发生着变化，即职责扩散。
  如类A完成职责P的功能，但是随着后期业务细化，职责P分解成更小粒度的P1与P2，这时根据单一职责原则则需要拆分类A以分别满足细分后的职责P1和P2。
  但是实际开发环节，若类的逻辑足够简单，可以在代码上级别上违背单一职责原则；
  若类的方法足够少，可以在方法级别上违背单一职责原则。
  优点： 　1、降低类的功能复杂度
　2、提高系统的可维护性
　3、变更风险低</description>
    </item>
    
  </channel>
</rss>
