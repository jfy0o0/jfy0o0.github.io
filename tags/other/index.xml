<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Other on Jiang . &#39;s blog</title>
    <link>https://jfy0o0.github.io/tags/other/</link>
    <description>Recent content in Other on Jiang . &#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 04 Dec 2020 09:27:19 +0800</lastBuildDate><atom:link href="https://jfy0o0.github.io/tags/other/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Other - 对象池</title>
      <link>https://jfy0o0.github.io/2020/other-%E5%AF%B9%E8%B1%A1%E6%B1%A0/</link>
      <pubDate>Fri, 04 Dec 2020 09:27:19 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/other-%E5%AF%B9%E8%B1%A1%E6%B1%A0/</guid>
      <description>对象池  对象池是一种空间换时间的技术，  对象被预先创建并初始化后放入对象池中， 对象提供者就能利用已有的对象来处理请求，并在不需要时归还给池子而非直接销毁   它减少对象频繁创建所占用的内存 空间和初始化时间  原理 描述一个对象池有两个很重要的参数，
  对象池的类型，
  对象池可以获得对象的数量
   对象池的实现和内存池的实现原理很像：  都是一开始申请大内存空间， 然后把大内存分配成小内存空间，当需要使用的时候直接分配使用，不在向系统申请内存空间，也不直接释放内存空间。 使用完之后都是放回池子里   不同的地方在内存池有一个映射数组，在使用时负责快速定位合适的内存池（一个内存池可以有很多内存块大小不同的池子） 但是每一个类型的对象只对应一个对象池，并自己管理自己的对象池。不同类型的对象池是相互独立的存在  优点  减少频繁创建和销毁对象带来的成本，实现对象的缓存和复用 提高了获取对象的响应速度，对实时性要求较高的程序有很大帮助 一定程度上减少了垃圾回收机制（GC）的压力  缺点  1、很难设定对象池的大小，如果太小则不起作用，过大又会占用内存资源过高 2、并发环境中, 多个线程可能(同时)需要获取池中对象, 进而需要在堆数据结构上进行同步或者因为锁竞争而产生阻塞, 这种开销要比创建销毁对象的开销高数百倍; 3、由于池中对象的数量有限, 势必成为一个可伸缩性瓶颈; 4、所谓的脏对象就是指的是当对象被放回对象池后，还保留着刚刚被客户端调用时生成的数据。  脏对象可能带来两个问题   脏对象持有上次使用的引用，导致内存泄漏等问题。
  脏对象如果下一次使用时没有做清理，可能影响程序的处理数据。
  什么条件下使用对象池  资源受限的, 不需要可伸缩性的环境: cpu性能不够强劲, 内存比较紧张, 垃圾收集, 内存抖动会造成比较大的影响, 需要提高内存管理效率,响应性比吞吐量更为重要; 数量受限的, 比如数据库连接; 创建对象的成本比较大，并且创建比较频繁。比如线程的创建代价比较大，于是就有了常用的线程池。  实现   在一部分内存空间（池子）中事先实例化好固定数量的对象，</description>
    </item>
    
    <item>
      <title>Other - 同步、异步、阻塞、非阻塞</title>
      <link>https://jfy0o0.github.io/2020/other-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/</link>
      <pubDate>Tue, 17 Nov 2020 13:54:52 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/other-%E5%90%8C%E6%AD%A5%E5%BC%82%E6%AD%A5%E9%98%BB%E5%A1%9E%E9%9D%9E%E9%98%BB%E5%A1%9E/</guid>
      <description>1.同步与异步 同步和异步关注的是消息通信机制
指被调用者
同步  就是在发出一个调用时，在没有得到结果之前，该调用就不返回。 但是一旦调用返回，就得到返回值了。 换句话说，就是由调用者主动等待这个调用的结果。  异步  调用在发出之后，这个调用就直接返回了，所以没有返回结果。 换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。 而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个调用。  例子： 你打电话问书店老板有没有《分布式系统》这本书，
 如果是同步通信机制，书店老板会说，你稍等，”我查一下&amp;quot;，然后开始查啊查，等查好了（可能是5秒，也可能是一天）告诉你结果（返回结果）。 而异步通信机制，书店老板直接告诉你我查一下啊，查好了打电话给你，然后直接挂电话了（不返回结果）。然后查好了，他会主动打电话给你。在这里老板通过“回电”这种方式来回调。  2. 阻塞与非阻塞 阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态.
指调用者
阻塞调用 是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
非阻塞调用 指在不能立刻得到结果之前，该调用不会阻塞当前线程。
例子： 你打电话问书店老板有没有《分布式系统》这本书，
  你如果是阻塞式调用，你会一直把自己“挂起”，直到得到这本书有没有的结果，
  如果是非阻塞式调用，你不管老板有没有告诉你，你自己先一边去玩了， 当然你也要偶尔过几分钟check一下老板有没有返回结果。
  在这里阻塞与非阻塞与是否同步异步无关。跟老板通过什么方式回答你结果无关。
  说明：  阻塞式发送：发送方进程会被一直阻塞， 直到消息被接受方进程收到。 非阻塞式发送： 发送方进程调用 send() 后， 立即就可以其他操作。 阻塞式接收：接收方调用 receive() 后一直阻塞， 直到消息到达可用。 非阻塞式接受：接收方调用 receive() 函数后， 要么得到一个有效的结果， 要么得到一个空值， 即不会被阻塞。  例子2： 老张爱喝茶，废话不说，煮开水。 出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。
 老张把水壶放到火上，立等水开。（同步阻塞） 老张觉得自己有点傻 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。（同步非阻塞） 老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。 老张把响水壶放到火上，立等水开。（异步阻塞） 老张觉得这样傻等意义不大 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。（异步非阻塞） 老张觉得自己聪明了。  所谓同步异步，只是对于水壶**（被调用者）**而言。 普通水壶，同步；响水壶，异步。 虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。 同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。</description>
    </item>
    
    <item>
      <title>Other - 大端、小端</title>
      <link>https://jfy0o0.github.io/2020/other-%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF/</link>
      <pubDate>Tue, 17 Nov 2020 13:54:52 +0800</pubDate>
      
      <guid>https://jfy0o0.github.io/2020/other-%E5%A4%A7%E7%AB%AF%E5%B0%8F%E7%AB%AF/</guid>
      <description>大端 概念 是指数据的高字节保存在内存的低地址中，而数据的低字节保存在内存的高地址中。
小端 概念 数据的高字节保存在内存的高地址中，而数据的低字节保存在内存的低地址中，
这种存储模式将地址的高低和数据位权有效地结合起来，高地址部分权值高，低地址部分权值低，和我们的逻辑方法一致。
简明区分 下面以unsigned int value = 0x12345678为例，
分别看看在两种字节序下其存储情况，我们可以用unsigned char buf[4]来表示value
 Big-Endian: 低地址存放高位，如下：
​	高地址
​	buf[3] (0x78) &amp;ndash; 低位
​	buf[2] (0x56)
​	buf[1] (0x34)
​	buf[0] (0x12) &amp;ndash; 高位
​	低地址
 Little-Endian: 低地址存放低位，如下：
​	高地址
​	buf[3] (0x12) &amp;ndash; 高位
​	buf[2] (0x34)
​	buf[1] (0x56)
​	buf[0] (0x78) &amp;ndash; 低位
​	低地址
    内存地址 小端模式存放内容 大端模式存放内容     0x4000 0x78 0x12   0x4001 0x56 0x34   0x4002 0x34 0x56   0x4003 0x12 0x78    </description>
    </item>
    
  </channel>
</rss>
