<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Jiang .">
  
  
  
  <link rel="prev" href="https://jfy0o0.github.io/2021/elementary-knowledge-p2p%E6%8A%80%E6%9C%AF%E4%B9%8Budp%E6%89%93%E6%B4%9E/" />
  <link rel="next" href="https://jfy0o0.github.io/2021/linux-%E8%BD%AF%E4%BB%B6-inotifywait/" />
  <link rel="canonical" href="https://jfy0o0.github.io/2021/cpp_%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           C&#43;&#43; - 并发详解 | Jiang . &#39;s blog
       
  </title>
  <meta name="title" content="C&#43;&#43; - 并发详解 | Jiang . &#39;s blog">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/jfy0o0.github.io"
    },
    "articleSection" : "posts",
    "name" : "C\u002b\u002b - 并发详解",
    "headline" : "C\u002b\u002b - 并发详解",
    "description" : "线程 创建线程 创建线程非常的简单的，下面就是一个使用了多线程的Hello World示例：\n\/\/ 01_hello_thread.cpp  #include \u0026lt;iostream\u0026gt;#include \u0026lt;thread\u0026gt; \/\/ ① using namespace std; \/\/ ②  void hello() { \/\/ ③  cout \u0026lt;\u0026lt; \u0026#34;Hello World from new thread.\u0026#34; \u0026lt;\u0026lt; endl; } int main() { thread t(hello); \/\/ ④  t.join(); \/\/ ⑤  return 0; } 对于这段代码说明如下：\n 为了使用多线程的接口，我们需要#include 头文件。 为了简化声明，本文中的代码都将using namespace std;。 新建线程的入口是一个普通的函数，它并没有什么特别的地方。 创建线程的方式就是构造一个thread对象，并指定入口函数。与普通对象不一样的是，此时编译器便会为我们创建一个新的操作系统线程，并在新的线程中执行我们的入口函数。 关于join函数在下文中讲解。  int main() { thread t([] { cout \u0026lt;\u0026lt; \u0026#34;Hello World from lambda thread.",
    "inLanguage" : "en-us",
    "author" : "Jiang",
    "creator" : "Jiang",
    "publisher": "Jiang",
    "accountablePerson" : "Jiang",
    "copyrightHolder" : "Jiang",
    "copyrightYear" : "2021",
    "datePublished": "2021-08-13 10:14:55 \u002b0800 CST",
    "dateModified" : "2021-08-13 10:14:55 \u002b0800 CST",
    "url" : "https:\/\/jfy0o0.github.io\/2021\/cpp_%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3\/",
    "wordCount" : "1052",
    "keywords" : [ "C\u002b\u002b", "Jiang . \u0027s blog"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://jfy0o0.github.io">Jiang . &#39;s blog</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://jfy0o0.github.io">Jiang . &#39;s blog</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">C&#43;&#43; - 并发详解</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://jfy0o0.github.io" rel="author">Jiang</a> with ♥ 
                <span class="post-time">
                on <time datetime=2021-08-13 itemprop="datePublished">August 13, 2021</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://jfy0o0.github.io/categories/c&#43;&#43;/"> C&#43;&#43; </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          <h1 id="线程">线程</h1>
<h2 id="创建线程"><strong>创建线程</strong></h2>
<p>创建线程非常的简单的，下面就是一个使用了多线程的Hello World示例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">// 01_hello_thread.cpp
</span><span style="color:#75715e"></span>
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt; // ①</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">using</span> <span style="color:#66d9ef">namespace</span> std; <span style="color:#75715e">// ②
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hello</span>() { <span style="color:#75715e">// ③
</span><span style="color:#75715e"></span>  cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello World from new thread.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">thread</span> t(hello); <span style="color:#75715e">// ④
</span><span style="color:#75715e"></span>  t.join(); <span style="color:#75715e">// ⑤
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>对于这段代码说明如下：</p>
<ol>
<li>为了使用多线程的接口，我们需要#include <!-- raw HTML omitted -->头文件。</li>
<li>为了简化声明，本文中的代码都将using namespace std;。</li>
<li>新建线程的入口是一个普通的函数，它并没有什么特别的地方。</li>
<li>创建线程的方式就是构造一个thread对象，并指定入口函数。与普通对象不一样的是，此时编译器便会为我们创建一个新的操作系统线程，并在新的线程中执行我们的入口函数。</li>
<li>关于join函数在下文中讲解。</li>
</ol>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">thread</span> t([] {
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Hello World from lambda thread.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  });

  t.join();

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>当然，你可以传递参数给入口函数，像下面这样：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">hello</span>(string name) {
  cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Welcome to &#34;</span> <span style="color:#f92672">&lt;&lt;</span> name <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">thread</span> t(hello, <span style="color:#e6db74">&#34;https://paul.pub&#34;</span>);
  t.join();

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><ul>
<li>不过需要注意的是，参数是以拷贝的形式进行传递的。</li>
<li>因此对于拷贝耗时的对象你可能需要传递指针或者引用类型作为参数。</li>
<li>但是，如果是传递指针或者引用，你还需要考虑参数对象的生命周期。因为线程的运行长度很可能会超过参数的生命周期（见下文detach），这个时候如果线程还在访问一个已经被销毁的对象就会出现问题。</li>
</ul>
<h2 id="join与detach"><strong>join与detach</strong></h2>
<ul>
<li>
<p>一旦启动线程之后，我们必须决定是要等待直接它结束（通过join），还是让它独立运行（通过detach），我们必须二者选其一。</p>
</li>
<li>
<p>如果在thread对象销毁的时候我们还没有做决定，则thread对象在析构函数出将调用std::terminate()从而导致我们的进程异常退出。</p>
</li>
<li>
<p>join：调用此接口时，当前线程会一直阻塞，直到目标线程执行完成（当然，很可能目标线程在此处调用之前就已经执行完成了，不过这不要紧）。因此，如果目标线程的任务非常耗时，你就要考虑好是否需要在主线程上等待它了，因此这很可能会导致主线程卡住。</p>
</li>
<li>
<p>detach：detach是让目标线程成为守护线程（daemon threads）。一旦detach之后，目标线程将独立执行，即便其对应的thread对象销毁也不影响线程的执行。并且，你无法再与之通信。</p>
</li>
</ul>
<h2 id="管理当前线程"><strong>管理当前线程</strong></h2>
<ul>
<li>yield 通常用在自己的主要任务已经完成的时候，此时希望让出处理器给其他任务使用。</li>
<li>get_id 返回当前线程的id，可以以此来标识不同的线程。</li>
<li>sleep_for 是让当前线程停止一段时间。</li>
<li>sleep_until 和sleep_for类似，但是是以具体的时间点为参数。这两个API都以chrono API（由于篇幅所限，这里不展开这方面内容）为基础。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print_time</span>() {
  <span style="color:#66d9ef">auto</span> now <span style="color:#f92672">=</span> chrono<span style="color:#f92672">::</span>system_clock<span style="color:#f92672">::</span>now();
  <span style="color:#66d9ef">auto</span> in_time_t <span style="color:#f92672">=</span> chrono<span style="color:#f92672">::</span>system_clock<span style="color:#f92672">::</span>to_time_t(now);

  std<span style="color:#f92672">::</span>stringstream ss;
  ss <span style="color:#f92672">&lt;&lt;</span> put_time(localtime(<span style="color:#f92672">&amp;</span>in_time_t), <span style="color:#e6db74">&#34;%Y-%m-%d %X&#34;</span>);
  cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;now is: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ss.str() <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">sleep_thread</span>() {
  this_thread<span style="color:#f92672">::</span>sleep_for(chrono<span style="color:#f92672">::</span>seconds(<span style="color:#ae81ff">3</span>));
  cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[thread-&#34;</span> <span style="color:#f92672">&lt;&lt;</span> this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;] is waking up&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">loop_thread</span>() {
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span>; i<span style="color:#f92672">++</span>) {
    cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;[thread-&#34;</span> <span style="color:#f92672">&lt;&lt;</span> this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;] print: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> i <span style="color:#f92672">&lt;&lt;</span> endl;
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  print_time();

  <span style="color:#66d9ef">thread</span> t1(sleep_thread);
  <span style="color:#66d9ef">thread</span> t2(loop_thread);

  t1.join();
  t2.detach();

  print_time();
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h2 id="一次调用"><strong>一次调用</strong></h2>
<p>在一些情况下，我们有些任务需要执行一次，并且我们只希望它执行一次，例如资源的初始化任务。这个时候就可以用到上面的接口。这个接口会保证，即便在多线程的环境下，相应的函数也只会调用一次。</p>
<p>下面就是一个示例：有三个线程都会使用init函数，但是只会有一个线程真正执行它。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">void</span> <span style="color:#a6e22e">init</span>() {
  cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Initialing...&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#75715e">// Do something...
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">worker</span>(once_flag<span style="color:#f92672">*</span> flag) {
  call_once(<span style="color:#f92672">*</span>flag, init);
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  once_flag flag;

  <span style="color:#66d9ef">thread</span> t1(worker, <span style="color:#f92672">&amp;</span>flag);
  <span style="color:#66d9ef">thread</span> t2(worker, <span style="color:#f92672">&amp;</span>flag);
  <span style="color:#66d9ef">thread</span> t3(worker, <span style="color:#f92672">&amp;</span>flag);

  t1.join();
  t2.join();
  t3.join();

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h1 id="并发任务"><strong>并发任务</strong></h1>
<ol>
<li>thread::hardware_concurrency()可以获取到当前硬件支持多少个线程并行执行。</li>
<li>根据处理器的情况决定线程的数量。</li>
<li>对于每一个线程都通过worker函数来完成任务，并划分一部分数据给它处理。</li>
<li>等待每一个线程执行结束。</li>
</ol>
<h1 id="互斥体与锁"><strong>互斥体与锁</strong></h1>
<h2 id="mutex"><strong>mutex</strong></h2>
<p>开发并发系统的目的主要是为了提升性能：将任务分散到多个线程，然后在不同的处理器上同时执行。这些分散开来的线程通常会包含两类任务：</p>
<ol>
<li>独立的对于划分给自己的数据的处理</li>
<li>对于处理结果的汇总</li>
</ol>
<p>其中第1项任务因为每个线程是独立的，不存在竞争条件的问题。而第2项任务，由于所有线程都可能往总结果（例如上面的sum变量）汇总，这就需要做保护了。在某一个具体的时刻，只应当有一个线程更新总结果，即：保证每个线程对于共享数据的访问是“互斥”的。</p>
<p>mutex是最基础的API。其他类都是在它的基础上的改进。所以这些类都提供了下面三个方法，并且它们的功能是一样的：</p>
<p>| 方法| 说明 |
| lock|锁定互斥体，如果不可用，则阻塞 |
| try_lock |尝试锁定互斥体，如果不可用，直接返回 |
|unlock | 解锁互斥体|</p>
<ul>
<li>
<p>超时：</p>
<p>timed_mutex，</p>
<p>recursive_timed_mutex，</p>
<p>shared_timed_mutex</p>
<p>名称都带有timed，这意味着它们都支持超时功能。它们都提供了try_lock_for和try_lock_until方法，这两个方法分别可以指定超时的时间长度和时间点。如果在超时的时间范围内没有能获取到锁，则直接返回，不再继续等待。</p>
</li>
<li>
<p>可重入：</p>
<p>recursive_mutex和recursive_timed_mutex的名称都带有recursive。可重入或者叫做可递归，是指在同一个线程中，同一把锁可以锁定多次。这就避免了一些不必要的死锁。</p>
</li>
<li>
<p>共享：（其实就是读写锁）</p>
<p>shared_timed_mutex和shared_mutex提供了共享功能。对于这类互斥体，实际上是提供了两把锁：一把是共享锁，一把是互斥锁。一旦某个线程获取了互斥锁，任何其他线程都无法再获取互斥锁和共享锁；但是如果有某个线程获取到了共享锁，其他线程无法再获取到互斥锁，但是还有获取到共享锁。这里互斥锁的使用和其他的互斥体接口和功能一样。而共享锁可以同时被多个线程同时获取到（使用共享锁的接口见下面的表格）。共享锁通常用在读者写者模型上。</p>
</li>
</ul>
<p>使用共享锁的接口如下：</p>
<p>| 方法| 说明 |
|lock_shared | 获取互斥体的共享锁，如果无法获取则阻塞 |
| try_lock_shared| 尝试获取共享锁，如果不可用，直接返回 |
| unlock_shared| 解锁共享锁 |</p>
<h2 id="通用互斥管理"><strong>通用互斥管理</strong></h2>
<p>标准库就提供了上面的这些API。它们都使用了叫做RAII的编程技巧，来简化我们手动加锁和解锁的“体力活”。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">
<span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;mutex&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">int</span> g_i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
std<span style="color:#f92672">::</span>mutex g_i_mutex;  <span style="color:#75715e">// ①
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">safe_increment</span>()
{
  std<span style="color:#f92672">::</span>lock_guard<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>mutex<span style="color:#f92672">&gt;</span> lock(g_i_mutex);  <span style="color:#75715e">// ②
</span><span style="color:#75715e"></span>  <span style="color:#f92672">++</span>g_i;

  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>get_id() <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> g_i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
  <span style="color:#75715e">// ③
</span><span style="color:#75715e"></span>}
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;main: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> g_i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
 
  std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t1(safe_increment); <span style="color:#75715e">// ④
</span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> t2(safe_increment);
 
  t1.join();
  t2.join();
 
  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;main: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> g_i <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#39;\n&#39;</span>;
}
</code></pre></div><p>这段代码中：</p>
<ol>
<li>全局的互斥体g_i_mutex用来保护全局变量g_i</li>
<li>这是一个设计为可以被多线程环境使用的方法。因此需要通过互斥体来进行保护。这里没有调用lock方法，而是直接使用lock_guard来锁定互斥体。</li>
<li>在方法结束的时候，局部变量std::lock_guard&lt; std::mutex &gt; lock会被销毁，它对互斥体的锁定也就解除了。</li>
<li>在多个线程中使用这个方法。</li>
</ol>
<h2 id="stdlock_guard">std::lock_guard</h2>
<ul>
<li>std::lock_guard 在构造函数中进行加锁，析构函数中进行解锁。</li>
<li>锁在多线程编程中，使用较多，因此c++11提供了lock_guard模板类；在实际编程中，我们也可以根据自己的场景编写<code>resource_guard</code> RAII类，避免忘掉释放资源。</li>
</ul>
<h2 id="stdunique_lock">std::unique_lock</h2>
<ul>
<li>类 unique_lock 是通用互斥包装器，允许<code>延迟锁定、锁定的有时限尝试、递归锁定、所有权转移和与条件变量一同使用</code>。</li>
<li>unique_lock比lock_guard使用更加灵活，功能更加强大。</li>
<li>使用unique_lock需要付出更多的时间、性能成本。</li>
</ul>
<h2 id="条件变量"><strong>条件变量</strong></h2>
<p>| API | C++标准 | 说明 |
| condition_variable | C++ 11 | 提供与 std::unique_lock 关联的条件变量 |
| condition_variable_any | C++ 11 |提供与任何锁类型关联的条件变量 |
| notify_all_at_thread_exit |C++ 11 | 安排到在此线程完全结束时对 notify_all 的调用 |
| cv_status | C++ 11 |列出条件变量上定时等待的可能结果 |</p>
<p>条件变量提供了一个可以让多个线程间同步协作的功能。这对于生产者-消费者模型很有意义。在这个模型下：</p>
<ul>
<li>生产者和消费者共享一个工作区。这个区间的大小是有限的。</li>
<li>生产者总是产生数据放入工作区中，当工作区满了。它就停下来等消费者消费一部分数据，然后继续工作。</li>
<li>消费者总是从工作区中拿出数据使用。当工作区中的数据全部被消费空了之后，它也会停下来等待生产者往工作区中放入新的数据。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Account</span> {
<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  Account(string name, <span style="color:#66d9ef">double</span> money)<span style="color:#f92672">:</span> mName(name), mMoney(money) {};

<span style="color:#66d9ef">public</span><span style="color:#f92672">:</span>
  <span style="color:#66d9ef">void</span> changeMoney(<span style="color:#66d9ef">double</span> amount) {
    unique_lock <span style="color:#a6e22e">lock</span>(mMoneyLock); <span style="color:#75715e">// ②
</span><span style="color:#75715e"></span>    mConditionVar.wait(lock, [<span style="color:#66d9ef">this</span>, amount] { <span style="color:#75715e">// ③
</span><span style="color:#75715e"></span>      <span style="color:#66d9ef">return</span> mMoney <span style="color:#f92672">+</span> amount <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// ④
</span><span style="color:#75715e"></span>    });
    mMoney <span style="color:#f92672">+=</span> amount;
    mConditionVar.notify_all(); <span style="color:#75715e">// ⑤
</span><span style="color:#75715e"></span>  }

  string <span style="color:#a6e22e">getName</span>() {
    <span style="color:#66d9ef">return</span> mName;
  }

  <span style="color:#66d9ef">double</span> <span style="color:#a6e22e">getMoney</span>() {
    <span style="color:#66d9ef">return</span> mMoney;
  }

<span style="color:#66d9ef">private</span><span style="color:#f92672">:</span>
  string mName;
  <span style="color:#66d9ef">double</span> mMoney;
  mutex mMoneyLock;
  condition_variable mConditionVar; <span style="color:#75715e">// ①
</span><span style="color:#75715e"></span>};
</code></pre></div><p>这几处改动说明如下：</p>
<ol>
<li>这里声明了一个条件变量，用来在多个线程之间协作。</li>
<li>这里使用的是unique_lock，这是为了与条件变量相配合。因为条件变量会解锁和重新锁定互斥体。</li>
<li>这里是比较重要的一个地方：通过条件变量进行等待。此时：会通过后面的lambda表达式判断条件是否满足。如果满足则继续；如果不满足，则此处会解锁互斥体，并让当前线程等待。解锁这一点非常重要，因为只有这样，才能让其他线程获取互斥体。</li>
<li>这里是条件变量等待的条件。如果你不熟悉lambda表达式，请自行网上学习，或者阅读我之前写的文章。</li>
<li>此处也很重要。当金额发生变动之后，我们需要通知所有在条件变量上等待的其他线程。此时所有调用wait线程都会再次唤醒，然后尝试获取锁（当然，只有一个能获取到）并再次判断条件是否满足。除了notify_all还有notify_one，它只通知一个等待的线程。wait和notify就构成了线程间互相协作的工具。</li>
</ol>
<h1 id="future"><strong>future</strong></h1>
<table>
<thead>
<tr>
<th>api</th>
<th>标准</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>async</td>
<td>11</td>
<td>异步运行一个函数，并返回保有结果的std::future</td>
</tr>
<tr>
<td>future</td>
<td>11</td>
<td>等待被异步设置的值</td>
</tr>
<tr>
<td>packaged_task</td>
<td>11</td>
<td>打包一个函数，存储其返回值进行异步获取</td>
</tr>
<tr>
<td>promise</td>
<td>11</td>
<td>存储一个值进行异步获取</td>
</tr>
<tr>
<td>shared_future</td>
<td>11</td>
<td>等待被异步设置的值</td>
</tr>
</tbody>
</table>
<h2 id="async"><strong>async</strong></h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> MAX <span style="color:#f92672">=</span> <span style="color:#ae81ff">10e8</span>;
<span style="color:#66d9ef">static</span> <span style="color:#66d9ef">double</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">worker</span>(<span style="color:#66d9ef">int</span> min, <span style="color:#66d9ef">int</span> max) {
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> min; i <span style="color:#f92672">&lt;=</span> max; i<span style="color:#f92672">++</span>) {
    sum <span style="color:#f92672">+=</span> sqrt(i);
  }
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">auto</span> f1 <span style="color:#f92672">=</span> async(worker, <span style="color:#ae81ff">0</span>, MAX);
  cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Async task triggered&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  f1.wait();
  cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Async task finish, result: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sum <span style="color:#f92672">&lt;&lt;</span> endl <span style="color:#f92672">&lt;&lt;</span> endl;
}
</code></pre></div><p>这仍然是我们之前熟悉的例子。这里有两个地方需要说明：</p>
<ol>
<li>这里以异步的方式启动了任务。它会返回一个future对象。future用来存储异步任务的执行结果，关于future我们在后面packaged_task的例子中再详细说明。在这个例子中我们仅仅用它来等待任务执行完成。</li>
<li>此处是等待异步任务执行完成。</li>
</ol>
<p>需要注意的是，默认情况下，async是启动一个新的线程，还是以同步的方式（不启动新的线程）运行任务，这一点标准是没有指定的，由具体的编译器决定。如果希望一定要以新的线程来异步执行任务，可以通过launch::async来明确说明。launch中有两个常量：</p>
<ul>
<li>async：运行新线程，以异步执行任务。</li>
<li>deferred：调用方线程上第一次请求其结果时才执行任务，即惰性求值。</li>
</ul>
<h2 id="packaged_task"><strong>packaged_task</strong></h2>
<p>在一些业务中，我们可能会有很多的任务需要调度。这时我们常常会设计出任务队列和线程池的结构。此时，就可以使用packaged_task来包装任务。</p>
<p>packaged_task绑定到一个函数或者可调用对象上。当它被调用时，它就会调用其绑定的函数或者可调用对象。并且，可以通过与之相关联的future来获取任务的结果。调度程序只需要处理packaged_task，而非各个函数。</p>
<p>packaged_task对象是一个可调用对象，它可以被封装成一个std::fucntion，或者作为线程函数传递给std::thread，或者直接调用。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">
<span style="color:#66d9ef">double</span> <span style="color:#a6e22e">concurrent_worker</span>(<span style="color:#66d9ef">int</span> min, <span style="color:#66d9ef">int</span> max) {
  <span style="color:#66d9ef">double</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> min; i <span style="color:#f92672">&lt;=</span> max; i<span style="color:#f92672">++</span>) {
    sum <span style="color:#f92672">+=</span> sqrt(i);
  }
  <span style="color:#66d9ef">return</span> sum;
}

<span style="color:#66d9ef">double</span> <span style="color:#a6e22e">concurrent_task</span>(<span style="color:#66d9ef">int</span> min, <span style="color:#66d9ef">int</span> max) {
  vector<span style="color:#f92672">&lt;</span>future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;&gt;</span> results; <span style="color:#75715e">// ①
</span><span style="color:#75715e"></span>
  <span style="color:#66d9ef">unsigned</span> concurrent_count <span style="color:#f92672">=</span> <span style="color:#66d9ef">thread</span><span style="color:#f92672">::</span>hardware_concurrency();
  min <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> concurrent_count; i<span style="color:#f92672">++</span>) { <span style="color:#75715e">// ②
</span><span style="color:#75715e"></span>    packaged_task<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>)<span style="color:#f92672">&gt;</span> task(concurrent_worker); <span style="color:#75715e">// ③
</span><span style="color:#75715e"></span>    results.push_back(task.get_future()); <span style="color:#75715e">// ④
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">int</span> range <span style="color:#f92672">=</span> max <span style="color:#f92672">/</span> concurrent_count <span style="color:#f92672">*</span> (i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">thread</span> t(std<span style="color:#f92672">::</span>move(task), min, range); <span style="color:#75715e">// ⑤
</span><span style="color:#75715e"></span>    t.detach();

    min <span style="color:#f92672">=</span> range <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
  }

  cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threads create finish&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">double</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> r : results) {
    sum <span style="color:#f92672">+=</span> r.get(); <span style="color:#960050;background-color:#1e0010">⑥</span>
  }
  <span style="color:#66d9ef">return</span> sum;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">auto</span> start_time <span style="color:#f92672">=</span> chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>now();

  <span style="color:#66d9ef">double</span> r <span style="color:#f92672">=</span> concurrent_task(<span style="color:#ae81ff">0</span>, MAX);

  <span style="color:#66d9ef">auto</span> end_time <span style="color:#f92672">=</span> chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>now();
  <span style="color:#66d9ef">auto</span> ms <span style="color:#f92672">=</span> chrono<span style="color:#f92672">::</span>duration_cast<span style="color:#f92672">&lt;</span>chrono<span style="color:#f92672">::</span>milliseconds<span style="color:#f92672">&gt;</span>(end_time <span style="color:#f92672">-</span> start_time).count();
  cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Concurrent task finish, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ms <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; ms consumed, Result: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> r <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>在这段代码中：</p>
<ol>
<li>首先创建一个集合来存储future对象。我们将用它来获取任务的结果。</li>
<li>同样的，根据CPU的情况来创建线程的数量。</li>
<li>将任务包装成packaged_task。请注意，由于concurrent_worker被包装成了任务，我们无法直接获取它的return值。而是要通过future对象来获取。</li>
<li>获取任务关联的future对象，并将其存入集合中。</li>
<li>通过一个新的线程来执行任务，并传入需要的参数。</li>
<li>通过future集合，逐个获取每个任务的计算结果，将其累加。这里r.get()获取到的就是每个任务中concurrent_worker的返回值。</li>
</ol>
<h3 id="简易package_task例子">简易package_task例子</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp">
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">p</span>(<span style="color:#66d9ef">int</span> pro)
{
    sleep(<span style="color:#ae81ff">5</span>);
    <span style="color:#66d9ef">return</span> pro <span style="color:#f92672">+</span> pro;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
    packaged_task<span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">int</span>(<span style="color:#66d9ef">int</span>) <span style="color:#f92672">&gt;</span> task(p);
    cout <span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl; <span style="color:#75715e">//hello
</span><span style="color:#75715e"></span>
    future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> ret <span style="color:#f92672">=</span> task.get_future();
    cout <span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;<span style="color:#75715e">//hello
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">thread</span> th(move(task), <span style="color:#ae81ff">10</span>);
    cout <span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;hello&#34;</span><span style="color:#f92672">&lt;&lt;</span>endl;<span style="color:#75715e">//hello
</span><span style="color:#75715e"></span>
    cout <span style="color:#f92672">&lt;&lt;</span> ret.get() <span style="color:#f92672">&lt;&lt;</span> endl;<span style="color:#75715e">//sleep(5) 20
</span><span style="color:#75715e"></span>
    th.join();
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

</code></pre></div><h2 id="promise与future"><strong>promise与future</strong></h2>
<p>在上面的例子中，concurrent_task的结果是通过return返回的。但在一些时候，我们可能不能这么做：在得到任务结果之后，可能还有一些事情需要继续处理，例如清理工作。</p>
<p>这个时候，就可以将promise与future配对使用。这样就可以将返回结果和任务结束两个事情分开。</p>
<p>下面是对上面代码示例的改写：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">double</span> <span style="color:#a6e22e">concurrent_worker</span>(<span style="color:#66d9ef">int</span> min, <span style="color:#66d9ef">int</span> max) {
  <span style="color:#66d9ef">double</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> min; i <span style="color:#f92672">&lt;=</span> max; i<span style="color:#f92672">++</span>) {
    sum <span style="color:#f92672">+=</span> sqrt(i);
  }
  <span style="color:#66d9ef">return</span> sum;
}

<span style="color:#66d9ef">void</span> <span style="color:#a6e22e">concurrent_task</span>(<span style="color:#66d9ef">int</span> min, <span style="color:#66d9ef">int</span> max, promise<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;*</span> result) { <span style="color:#75715e">// ①
</span><span style="color:#75715e"></span>  vector<span style="color:#f92672">&lt;</span>future<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;&gt;</span> results;

  <span style="color:#66d9ef">unsigned</span> concurrent_count <span style="color:#f92672">=</span> <span style="color:#66d9ef">thread</span><span style="color:#f92672">::</span>hardware_concurrency();
  min <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; i <span style="color:#f92672">&lt;</span> concurrent_count; i<span style="color:#f92672">++</span>) {
    packaged_task<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span>(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>)<span style="color:#f92672">&gt;</span> task(concurrent_worker);
    results.push_back(task.get_future()); 

    <span style="color:#66d9ef">int</span> range <span style="color:#f92672">=</span> max <span style="color:#f92672">/</span> concurrent_count <span style="color:#f92672">*</span> (i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
    <span style="color:#66d9ef">thread</span> t(std<span style="color:#f92672">::</span>move(task), min, range);
    t.detach();

    min <span style="color:#f92672">=</span> range <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>;
  }

  cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;threads create finish&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  <span style="color:#66d9ef">double</span> sum <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">auto</span><span style="color:#f92672">&amp;</span> r : results) {
    sum <span style="color:#f92672">+=</span> r.get();
  }
  result<span style="color:#f92672">-&gt;</span>set_value(sum); <span style="color:#75715e">// ②
</span><span style="color:#75715e"></span>  cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;concurrent_task finish&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
}

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  <span style="color:#66d9ef">auto</span> start_time <span style="color:#f92672">=</span> chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>now();

  promise<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;</span> sum; <span style="color:#75715e">// ③
</span><span style="color:#75715e"></span>  concurrent_task(<span style="color:#ae81ff">0</span>, MAX, <span style="color:#f92672">&amp;</span>sum);

  <span style="color:#66d9ef">auto</span> end_time <span style="color:#f92672">=</span> chrono<span style="color:#f92672">::</span>steady_clock<span style="color:#f92672">::</span>now();
  <span style="color:#66d9ef">auto</span> ms <span style="color:#f92672">=</span> chrono<span style="color:#f92672">::</span>duration_cast<span style="color:#f92672">&lt;</span>chrono<span style="color:#f92672">::</span>milliseconds<span style="color:#f92672">&gt;</span>(end_time <span style="color:#f92672">-</span> start_time).count();
  cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Concurrent task finish, &#34;</span> <span style="color:#f92672">&lt;&lt;</span> ms <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34; ms consumed.&#34;</span> <span style="color:#f92672">&lt;&lt;</span> endl;
  cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;Result: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> sum.get_future().get() <span style="color:#f92672">&lt;&lt;</span> endl; <span style="color:#75715e">// ④
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>这段代码和上面的示例在很大程度上是一样的。只有小部分内容做了改动：</p>
<ol>
<li>concurrent_task不再直接返回计算结果，而是增加了一个promise对象来存放结果。</li>
<li>在任务计算完成之后，将总结过设置到promise对象上。一旦这里调用了set_value，其相关联的future对象就会就绪。</li>
<li>这里是在main中创建一个promoise来存放结果，并以指针的形式传递进concurrent_task中。</li>
<li>通过sum.get_future().get()来获取结果。第2点中已经说了：一旦调用了set_value，其相关联的future对象就会就绪。</li>
</ol>
<p>需要注意的是，future对象只有被一个线程获取值。并且在调用get()之后，就没有可以获取的值了。如果从多个线程调用get()会出现数据竞争，其结果是未定义的。</p>
<p>如果真的需要在多个线程中获取future的结果，可以使用shared_future。</p>
<h3 id="简易promisefuture例子">简易promise、future例子</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;thread&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;future&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;chrono&gt;  </span><span style="color:#75715e">
</span><span style="color:#75715e"></span>  
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">_data</span>  
{  
    <span style="color:#66d9ef">int32_t</span> value;  
};  
  
_data data <span style="color:#f92672">=</span> { <span style="color:#ae81ff">0</span> };  
  
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()  
{  
    std<span style="color:#f92672">::</span>promise<span style="color:#f92672">&lt;</span>_data<span style="color:#f92672">&gt;</span> data_promise;      <span style="color:#75715e">//创建一个承诺  
</span><span style="color:#75715e"></span>    std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span>_data<span style="color:#f92672">&gt;</span> data_future <span style="color:#f92672">=</span> data_promise.get_future();     <span style="color:#75715e">//得到这个承诺封装好的期望  
</span><span style="color:#75715e"></span>  
    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> prepare_data_thread([](std<span style="color:#f92672">::</span>promise<span style="color:#f92672">&lt;</span>_data<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>data_promise){  
        std<span style="color:#f92672">::</span>this_thread<span style="color:#f92672">::</span>sleep_for(std<span style="color:#f92672">::</span>chrono<span style="color:#f92672">::</span>seconds(<span style="color:#ae81ff">2</span>));    <span style="color:#75715e">//模拟生产过程  
</span><span style="color:#75715e"></span>  
        data_promise.set_value({ <span style="color:#ae81ff">1</span> });       <span style="color:#75715e">//通过set_value()反馈结果  
</span><span style="color:#75715e"></span>    }, std<span style="color:#f92672">::</span>ref(data_promise));  
  
    std<span style="color:#f92672">::</span><span style="color:#66d9ef">thread</span> process_data_thread([](std<span style="color:#f92672">::</span>future<span style="color:#f92672">&lt;</span>_data<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>data_future){  
        std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> data_future.get().value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;    <span style="color:#75715e">//通过get()获取结果  
</span><span style="color:#75715e"></span>    }, std<span style="color:#f92672">::</span>ref(data_future));  
  
    prepare_data_thread.join();  
    process_data_thread.join();  
  
    system(<span style="color:#e6db74">&#34;pause&#34;</span>);  
    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;  
}  
</code></pre></div><table>
<thead>
<tr>
<th>thread ref (  [promise]  )</th>
<th></th>
<th>thread ref (  [future]   )</th>
</tr>
</thead>
<tbody>
<tr>
<td>|</td>
<td></td>
<td>|</td>
</tr>
<tr>
<td>|</td>
<td></td>
<td>|</td>
</tr>
<tr>
<td>set_value</td>
<td></td>
<td>get</td>
</tr>
</tbody>
</table>
<h2 id="注意">注意</h2>
<ul>
<li>不管是packaged_task.get_future() 还是 promise.get_future(）都是不会阻塞的</li>
<li>阻塞的点在get</li>
</ul>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Jiang . </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://jfy0o0.github.io/2021/cpp_%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/>https://jfy0o0.github.io/2021/cpp_%E5%B9%B6%E5%8F%91%E8%AF%A6%E8%A7%A3/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://jfy0o0.github.io/tags/c&#43;&#43;/">
                    #C&#43;&#43;</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://jfy0o0.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://jfy0o0.github.io/2021/elementary-knowledge-p2p%E6%8A%80%E6%9C%AF%E4%B9%8Budp%E6%89%93%E6%B4%9E/" class="prev" rel="prev" title="elementary knowledge - P2P技术之UDP打洞"><i class="iconfont icon-left"></i>&nbsp;elementary knowledge - P2P技术之UDP打洞</a>
         
        
        <a href="https://jfy0o0.github.io/2021/linux-%E8%BD%AF%E4%BB%B6-inotifywait/" class="next" rel="next" title="Linux Soft - inotifywait">Linux Soft - inotifywait&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2011 - 2021</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://jfy0o0.github.io">Jiang .</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
