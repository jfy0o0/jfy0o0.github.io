<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Jiang .">
  
  
  
  <link rel="prev" href="https://jfy0o0.github.io/2021/linux-io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" />
  <link rel="next" href="https://jfy0o0.github.io/2021/elementary-knowledge-p2p%E6%8A%80%E6%9C%AF%E4%B9%8Budp%E6%89%93%E6%B4%9E/" />
  <link rel="canonical" href="https://jfy0o0.github.io/2021/go-%E8%AF%A6%E8%A7%A3reflect/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Go - 详解reflect | Jiang . &#39;s blog
       
  </title>
  <meta name="title" content="Go - 详解reflect | Jiang . &#39;s blog">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/jfy0o0.github.io"
    },
    "articleSection" : "posts",
    "name" : "Go - 详解reflect",
    "headline" : "Go - 详解reflect",
    "description" : "reflect包实现了运行时反射，允许程序操作任意类型的对象。 典型用法是用静态类型interface{}保存一个值，通过调用TypeOf获取其动态类型信息，该函数返回一个Type类型值。 调用ValueOf函数返回一个Value类型值，该值代表运行时的数据。 Zero接受一个Type类型参数并返回一个代表该类型零值的Value类型值。  reflect.Type 在Go语言程序中，使用 reflect.TypeOf() 函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息，下面通过示例来理解获取类型对象的过程：\npackage main import ( \u0026#34;fmt\u0026#34; \u0026#34;reflect\u0026#34; ) func main() { var a int typeOfA := reflect.TypeOf(a) fmt.Println(typeOfA.Name(), typeOfA.Kind())\/\/int int } 反射的类型（Type）与种类（Kind）  在使用反射时，需要首先理解类型（Type）和种类（Kind）的区别。 编程中，使用最多的是类型，但在反射中，当需要区分一个大品种的类型时，就会用到种类（Kind）。 例如需要统一判断类型中的指针时，使用种类（Kind）信息就较为方便。  1) 反射种类（Kind）的定义  Go语言程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。 例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。  type Kind uint const ( Invalid Kind = iota \/\/ 非法类型  Bool \/\/ 布尔型  Int \/\/ 有符号整型  Int8 \/\/ 有符号8位整型  Int16 \/\/ 有符号16位整型  Int32 \/\/ 有符号32位整型  Int64 \/\/ 有符号64位整型  Uint \/\/ 无符号整型  Uint8 \/\/ 无符号8位整型  Uint16 \/\/ 无符号16位整型  Uint32 \/\/ 无符号32位整型  Uint64 \/\/ 无符号64位整型  Uintptr \/\/ 指针  Float32 \/\/ 单精度浮点数  Float64 \/\/ 双精度浮点数  Complex64 \/\/ 64位复数类型  Complex128 \/\/ 128位复数类型  Array \/\/ 数组  Chan \/\/ 通道  Func \/\/ 函数  Interface \/\/ 接口  Map \/\/ 映射  Ptr \/\/ 指针  Slice \/\/ 切片  String \/\/ 字符串  Struct \/\/ 结构体  UnsafePointer \/\/ 底层指针 ) Map、Slice、Chan 属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于独立的种类，不属于 Ptr。type A struct{} 定义的结构体属于 Struct 种类，*A 属于 Ptr。",
    "inLanguage" : "en-us",
    "author" : "Jiang .",
    "creator" : "Jiang .",
    "publisher": "Jiang .",
    "accountablePerson" : "Jiang .",
    "copyrightHolder" : "Jiang .",
    "copyrightYear" : "2021",
    "datePublished": "2021-07-31 09:42:56 \u002b0800 CST",
    "dateModified" : "2021-07-31 09:42:56 \u002b0800 CST",
    "url" : "https:\/\/jfy0o0.github.io\/2021\/go-%E8%AF%A6%E8%A7%A3reflect\/",
    "wordCount" : "1032",
    "keywords" : [ "Go", "Jiang . \u0027s blog"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://jfy0o0.github.io">Jiang . &#39;s blog</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://jfy0o0.github.io">Jiang . &#39;s blog</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Go - 详解reflect</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://jfy0o0.github.io" rel="author">Jiang .</a> with ♥ 
                <span class="post-time">
                on <time datetime=2021-07-31 itemprop="datePublished">July 31, 2021</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://jfy0o0.github.io/categories/go/"> Go </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          <ul>
<li>reflect包实现了运行时反射，允许程序操作任意类型的对象。</li>
<li>典型用法是用静态类型interface{}保存一个值，通过调用TypeOf获取其动态类型信息，该函数返回一个Type类型值。</li>
<li>调用ValueOf函数返回一个Value类型值，该值代表运行时的数据。</li>
<li>Zero接受一个Type类型参数并返回一个代表该类型零值的Value类型值。</li>
</ul>
<h1 id="reflecttype">reflect.Type</h1>
<p>在Go语言程序中，使用 reflect.TypeOf() 函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息，下面通过示例来理解获取类型对象的过程：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;reflect&#34;</span>
)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">typeOfA</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">TypeOf</span>(<span style="color:#a6e22e">a</span>)
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">typeOfA</span>.<span style="color:#a6e22e">Name</span>(), <span style="color:#a6e22e">typeOfA</span>.<span style="color:#a6e22e">Kind</span>())<span style="color:#75715e">//int  int
</span><span style="color:#75715e"></span>}
</code></pre></div><h1 id="反射的类型type与种类kind">反射的类型（Type）与种类（Kind）</h1>
<ul>
<li>在使用反射时，需要首先理解类型（Type）和种类（Kind）的区别。</li>
<li>编程中，使用最多的是类型，但在反射中，当需要区分一个大品种的类型时，就会用到种类（Kind）。</li>
<li>例如需要统一判断类型中的指针时，使用种类（Kind）信息就较为方便。</li>
</ul>
<h2 id="1-反射种类kind的定义">1) 反射种类（Kind）的定义</h2>
<ul>
<li>Go语言程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。</li>
<li>例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Kind</span> <span style="color:#66d9ef">uint</span>

<span style="color:#66d9ef">const</span> (
    <span style="color:#a6e22e">Invalid</span> <span style="color:#a6e22e">Kind</span> = <span style="color:#66d9ef">iota</span>  <span style="color:#75715e">// 非法类型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Bool</span>                 <span style="color:#75715e">// 布尔型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Int</span>                  <span style="color:#75715e">// 有符号整型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Int8</span>                 <span style="color:#75715e">// 有符号8位整型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Int16</span>                <span style="color:#75715e">// 有符号16位整型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Int32</span>                <span style="color:#75715e">// 有符号32位整型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Int64</span>                <span style="color:#75715e">// 有符号64位整型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Uint</span>                 <span style="color:#75715e">// 无符号整型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Uint8</span>                <span style="color:#75715e">// 无符号8位整型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Uint16</span>               <span style="color:#75715e">// 无符号16位整型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Uint32</span>               <span style="color:#75715e">// 无符号32位整型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Uint64</span>               <span style="color:#75715e">// 无符号64位整型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Uintptr</span>              <span style="color:#75715e">// 指针
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Float32</span>              <span style="color:#75715e">// 单精度浮点数
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Float64</span>              <span style="color:#75715e">// 双精度浮点数
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Complex64</span>            <span style="color:#75715e">// 64位复数类型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Complex128</span>           <span style="color:#75715e">// 128位复数类型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Array</span>                <span style="color:#75715e">// 数组
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Chan</span>                 <span style="color:#75715e">// 通道
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Func</span>                 <span style="color:#75715e">// 函数
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Interface</span>            <span style="color:#75715e">// 接口
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Map</span>                  <span style="color:#75715e">// 映射
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Ptr</span>                  <span style="color:#75715e">// 指针
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Slice</span>                <span style="color:#75715e">// 切片
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">String</span>               <span style="color:#75715e">// 字符串
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Struct</span>               <span style="color:#75715e">// 结构体
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">UnsafePointer</span>        <span style="color:#75715e">// 底层指针
</span><span style="color:#75715e"></span>)
</code></pre></div><p>Map、Slice、Chan 属于引用类型，使用起来类似于指针，但是在种类常量定义中仍然属于独立的种类，不属于 Ptr。type A struct{} 定义的结构体属于 Struct 种类，*A 属于 Ptr。</p>
<h2 id="2-从类型对象中获取类型名称和种类">2) 从类型对象中获取类型名称和种类</h2>
<ul>
<li>Go语言中的类型名称对应的反射获取方法是 reflect.Type 中的 Name() 方法，返回表示类型名称的字符串；类型归属的种类（Kind）使用的是 reflect.Type 中的 Kind() 方法，返回 reflect.Kind 类型的常量。</li>
<li>下面的代码中会对常量和结构体进行类型信息获取。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;reflect&#34;</span>
)
<span style="color:#75715e">// 定义一个Enum类型
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Enum</span> <span style="color:#66d9ef">int</span>
<span style="color:#66d9ef">const</span> (
    <span style="color:#a6e22e">Zero</span> <span style="color:#a6e22e">Enum</span> = <span style="color:#ae81ff">0</span>
)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 声明一个空结构体
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">cat</span> <span style="color:#66d9ef">struct</span> {
    }
    <span style="color:#75715e">// 获取结构体实例的反射类型对象
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">typeOfCat</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">TypeOf</span>(<span style="color:#a6e22e">cat</span>{})
    <span style="color:#75715e">// 显示反射类型对象的名称和种类
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">typeOfCat</span>.<span style="color:#a6e22e">Name</span>(), <span style="color:#a6e22e">typeOfCat</span>.<span style="color:#a6e22e">Kind</span>())<span style="color:#75715e">//cat struct
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 获取Zero常量的反射类型对象
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">typeOfA</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">TypeOf</span>(<span style="color:#a6e22e">Zero</span>)
    <span style="color:#75715e">// 显示反射类型对象的名称和种类
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">typeOfA</span>.<span style="color:#a6e22e">Name</span>(), <span style="color:#a6e22e">typeOfA</span>.<span style="color:#a6e22e">Kind</span>()) <span style="color:#75715e">//Enum int
</span><span style="color:#75715e"></span>
}
</code></pre></div><h1 id="指针与指针指向的元素">指针与指针指向的元素</h1>
<ul>
<li>Go语言程序中对指针获取反射对象时，可以通过 reflect.Elem() 方法获取这个指针指向的元素类型，这个获取过程被称为取元素，等效于对指针类型变量做了一个<code>*</code>操作，代码如下：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;reflect&#34;</span>
)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 声明一个空结构体
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">cat</span> <span style="color:#66d9ef">struct</span> {
    }
    <span style="color:#75715e">// 创建cat的实例
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ins</span> <span style="color:#f92672">:=</span> <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">cat</span>{}
    <span style="color:#75715e">// 获取结构体实例的反射类型对象
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">typeOfCat</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">TypeOf</span>(<span style="color:#a6e22e">ins</span>)
    <span style="color:#75715e">// 显示反射类型对象的名称和种类
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;name:&#39;%v&#39; kind:&#39;%v&#39;\n&#34;</span>, <span style="color:#a6e22e">typeOfCat</span>.<span style="color:#a6e22e">Name</span>(), <span style="color:#a6e22e">typeOfCat</span>.<span style="color:#a6e22e">Kind</span>())
    <span style="color:#75715e">//name:&#39;&#39; kind:&#39;ptr&#39;
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 取类型的元素
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">typeOfCat</span> = <span style="color:#a6e22e">typeOfCat</span>.<span style="color:#a6e22e">Elem</span>()
    <span style="color:#75715e">// 显示反射类型对象的名称和种类
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;element name: &#39;%v&#39;, element kind: &#39;%v&#39;\n&#34;</span>, <span style="color:#a6e22e">typeOfCat</span>.<span style="color:#a6e22e">Name</span>(), <span style="color:#a6e22e">typeOfCat</span>.<span style="color:#a6e22e">Kind</span>())
<span style="color:#75715e">//    element name: &#39;cat&#39;, element kind: &#39;struct&#39;
</span><span style="color:#75715e"></span>
}
</code></pre></div><h1 id="使用反射获取结构体的成员类型">使用反射获取结构体的成员类型</h1>
<ul>
<li>任意值通过 reflect.TypeOf() 获得反射对象信息后，如果它的类型是<strong>结构体</strong>，</li>
<li>可以通过反射值对象 reflect.Type 的 NumField() 和 Field() 方法获得结构体成员的详细信息。</li>
</ul>
<p>与成员获取相关的 reflect.Type 的方法如下表所示。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Field(i int) StructField</td>
<td>根据索引返回索引对应的结构体字段的信息，当值不是结构体或索引超界时发生宕机</td>
</tr>
<tr>
<td>NumField() int</td>
<td>返回结构体成员字段数量，当类型不是结构体或索引超界时发生宕机</td>
</tr>
<tr>
<td>FieldByName(name string) (StructField, bool)</td>
<td>根据给定字符串返回字符串对应的结构体字段的信息，没有找到时 bool 返回 false，当类型不是结构体或索引超界时发生宕机</td>
</tr>
<tr>
<td>FieldByIndex(index []int) StructField</td>
<td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的信息，没有找到时返回零值。当类型不是结构体或索引超界时发生宕机</td>
</tr>
<tr>
<td>FieldByNameFunc(match func(string) bool) (StructField,bool)</td>
<td>根据匹配函数匹配需要的字段，当值不是结构体或索引超界时发生宕机</td>
</tr>
</tbody>
</table>
<h2 id="1-结构体字段类型">1) 结构体字段类型</h2>
<ul>
<li>reflect.Type 的 Field() 方法返回 StructField 结构，这个结构描述结构体的成员信息，</li>
<li>通过这个信息可以获取成员与结构体的关系，如偏移、索引、是否为匿名字段、结构体标签（StructTag）等，而且还可以通过 StructField 的 Type 字段进一步获取结构体成员的类型信息。</li>
</ul>
<p>StructField 的结构如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">StructField</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>          <span style="color:#75715e">// 字段名
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">PkgPath</span> <span style="color:#66d9ef">string</span>       <span style="color:#75715e">// 字段路径
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Type</span>      <span style="color:#a6e22e">Type</span>       <span style="color:#75715e">// 字段反射类型对象
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Tag</span>       <span style="color:#a6e22e">StructTag</span>  <span style="color:#75715e">// 字段的结构体标签
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Offset</span>    <span style="color:#66d9ef">uintptr</span>    <span style="color:#75715e">// 字段在结构体中的相对偏移
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Index</span>     []<span style="color:#66d9ef">int</span>      <span style="color:#75715e">// Type.FieldByIndex中的返回的索引值
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">Anonymous</span> <span style="color:#66d9ef">bool</span>       <span style="color:#75715e">// 是否为匿名字段
</span><span style="color:#75715e"></span>}
</code></pre></div><h2 id="2-获取成员反射信息">2) 获取成员反射信息</h2>
<p>下面代码中，实例化一个结构体并遍历其结构体成员，再通过 reflect.Type 的 FieldByName() 方法查找结构体中指定名称的字段，直接获取其类型信息。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;reflect&#34;</span>
)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 声明一个空结构体
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">cat</span> <span style="color:#66d9ef">struct</span> {
        <span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
        <span style="color:#75715e">// 带有结构体tag的字段
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">Type</span> <span style="color:#66d9ef">int</span> <span style="color:#e6db74">`json:&#34;type&#34; id:&#34;100&#34;`</span>
    }
    <span style="color:#75715e">// 创建cat的实例
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">ins</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">cat</span>{<span style="color:#a6e22e">Name</span>: <span style="color:#e6db74">&#34;mimi&#34;</span>, <span style="color:#a6e22e">Type</span>: <span style="color:#ae81ff">1</span>}
    <span style="color:#75715e">// 获取结构体实例的反射类型对象
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">typeOfCat</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">TypeOf</span>(<span style="color:#a6e22e">ins</span>)
    <span style="color:#75715e">// 遍历结构体所有成员
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">for</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> &lt; <span style="color:#a6e22e">typeOfCat</span>.<span style="color:#a6e22e">NumField</span>(); <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span> {
        <span style="color:#75715e">// 获取每个成员的结构体字段类型
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">fieldType</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">typeOfCat</span>.<span style="color:#a6e22e">Field</span>(<span style="color:#a6e22e">i</span>)
        <span style="color:#75715e">// 输出成员名和tag
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Printf</span>(<span style="color:#e6db74">&#34;name: %v  tag: &#39;%v&#39;\n&#34;</span>, <span style="color:#a6e22e">fieldType</span>.<span style="color:#a6e22e">Name</span>, <span style="color:#a6e22e">fieldType</span>.<span style="color:#a6e22e">Tag</span>)
    }
    <span style="color:#75715e">//name: Name  tag: &#39;&#39;
</span><span style="color:#75715e"></span>	<span style="color:#75715e">//name: Type  tag: &#39;json:&#34;type&#34; id:&#34;100&#34;&#39;
</span><span style="color:#75715e"></span>    
    <span style="color:#75715e">// 通过字段名, 找到字段类型信息
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">catType</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">typeOfCat</span>.<span style="color:#a6e22e">FieldByName</span>(<span style="color:#e6db74">&#34;Type&#34;</span>); <span style="color:#a6e22e">ok</span> {
        <span style="color:#75715e">// 从tag中取出需要的tag
</span><span style="color:#75715e"></span>        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">catType</span>.<span style="color:#a6e22e">Tag</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;json&#34;</span>), <span style="color:#a6e22e">catType</span>.<span style="color:#a6e22e">Tag</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;id&#34;</span>))
    }
    <span style="color:#75715e">//type 100
</span><span style="color:#75715e"></span>}
</code></pre></div><h1 id="结构体标签struct-tag">结构体标签（Struct Tag）</h1>
<p>通过 reflect.Type 获取结构体成员信息 reflect.StructField 结构中的 Tag 被称为结构体标签（StructTag）。结构体标签是对结构体字段的额外信息标签。</p>
<p>JSON、BSON 等格式进行序列化及对象关系映射（Object Relational Mapping，简称 ORM）系统都会用到结构体标签，这些系统使用标签设定字段在处理时应该具备的特殊属性和可能发生的行为。这些信息都是静态的，无须实例化结构体，可以通过反射获取到。</p>
<h2 id="1-结构体标签的格式">1) 结构体标签的格式</h2>
<p>Tag 在结构体字段后方书写的格式如下：</p>
<pre><code>key1:&quot;value1&quot; key2:&quot;value2&quot;
</code></pre><p>结构体标签由一个或多个键值对组成；键与值使用冒号分隔，值用双引号括起来；键值对之间使用一个空格分隔。</p>
<h2 id="2-从结构体标签中获取值">2) 从结构体标签中获取值</h2>
<p>StructTag 拥有一些方法，可以进行 Tag 信息的解析和提取，如下所示：</p>
<ul>
<li><code>func (tag StructTag) Get(key string) string</code>：根据 Tag 中的键获取对应的值，例如<code>key1:&quot;value1&quot; key2:&quot;value2&quot;</code>的 Tag 中，可以传入“key1”获得“value1”。</li>
<li><code>func (tag StructTag) Lookup(key string) (value string, ok bool)</code>：根据 Tag 中的键，查询值是否存在。</li>
</ul>
<h2 id="3-结构体标签格式错误导致的问题">3) 结构体标签格式错误导致的问题</h2>
<p>编写 Tag 时，必须严格遵守键值对的规则。结构体标签的解析代码的容错能力很差，一旦格式写错，编译和运行时都不会提示任何错误，示例代码如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;reflect&#34;</span>
)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">cat</span> <span style="color:#66d9ef">struct</span> {
        <span style="color:#a6e22e">Name</span> <span style="color:#66d9ef">string</span>
        <span style="color:#a6e22e">Type</span> <span style="color:#66d9ef">int</span> <span style="color:#e6db74">`json: &#34;type&#34; id:&#34;100&#34;`</span>
    }
    <span style="color:#a6e22e">typeOfCat</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">TypeOf</span>(<span style="color:#a6e22e">cat</span>{})
    <span style="color:#66d9ef">if</span> <span style="color:#a6e22e">catType</span>, <span style="color:#a6e22e">ok</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">typeOfCat</span>.<span style="color:#a6e22e">FieldByName</span>(<span style="color:#e6db74">&#34;Type&#34;</span>); <span style="color:#a6e22e">ok</span> {
        <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">catType</span>.<span style="color:#a6e22e">Tag</span>.<span style="color:#a6e22e">Get</span>(<span style="color:#e6db74">&#34;json&#34;</span>))
    }
}
</code></pre></div><h1 id="reflectvalue">reflect.Value</h1>
<p>反射不仅可以获取值的类型信息，还可以动态地获取或者设置变量的值。Go语言中使用 reflect.Value 获取和设置变量的值。</p>
<h1 id="使用反射值对象包装任意值">使用反射值对象包装任意值</h1>
<p>Go语言中，使用 reflect.ValueOf() 函数获得值的反射值对象（reflect.Value）。书写格式如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">value</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">rawValue</span>)
</code></pre></div><p>reflect.ValueOf 返回 reflect.Value 类型，包含有 rawValue 的值信息。reflect.Value 与原值间可以通过值包装和值获取互相转化。reflect.Value 是一些反射操作的重要类型，如反射调用函数。</p>
<p>Go语言中可以通过 reflect.Value 重新获得原始值。</p>
<h2 id="1-从反射值对象reflectvalue中获取值的方法">1) 从反射值对象（reflect.Value）中获取值的方法</h2>
<p>可以通过下面几种方法从反射值对象 reflect.Value 中获取原值，如下表所示。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说  明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Interface() interface {}</td>
<td>将值以 interface{} 类型返回，可以通过类型断言转换为指定类型</td>
</tr>
<tr>
<td>Int() int64</td>
<td>将值以 int 类型返回，所有有符号整型均可以此方式返回</td>
</tr>
<tr>
<td>Uint() uint64</td>
<td>将值以 uint 类型返回，所有无符号整型均可以此方式返回</td>
</tr>
<tr>
<td>Float() float64</td>
<td>将值以双精度（float64）类型返回，所有浮点数（float32、float64）均可以此方式返回</td>
</tr>
<tr>
<td>Bool() bool</td>
<td>将值以 bool 类型返回</td>
</tr>
<tr>
<td>Bytes() []bytes</td>
<td>将值以字节数组 []bytes 类型返回</td>
</tr>
<tr>
<td>String() string</td>
<td>将值以字符串类型返回</td>
</tr>
</tbody>
</table>
<h2 id="2-从反射值对象reflectvalue中获取值的例子">2) 从反射值对象（reflect.Value）中获取值的例子</h2>
<p>下面代码中，将整型变量中的值使用 reflect.Value 获取反射值对象（reflect.Value）。再通过 reflect.Value 的 Interface() 方法获得 interface{} 类型的原值，通过 int 类型对应的 reflect.Value 的 Int() 方法获得整型值。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;reflect&#34;</span>
)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 声明整型变量a并赋初值
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span> = <span style="color:#ae81ff">1024</span>
    <span style="color:#75715e">// 获取变量a的反射值对象
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">valueOfA</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">a</span>)
    <span style="color:#75715e">// 获取interface{}类型的值, 通过类型断言转换
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">getA</span> <span style="color:#66d9ef">int</span> = <span style="color:#a6e22e">valueOfA</span>.<span style="color:#a6e22e">Interface</span>().(<span style="color:#66d9ef">int</span>)
    <span style="color:#75715e">// 获取64位的值, 强制类型转换为int类型
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">getA2</span> <span style="color:#66d9ef">int</span> = int(<span style="color:#a6e22e">valueOfA</span>.<span style="color:#a6e22e">Int</span>())
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">getA</span>, <span style="color:#a6e22e">getA2</span>)
}
</code></pre></div><p>反射值对象（reflect.Value）提供对结构体访问的方法，通过这些方法可以完成对结构体任意值的访问，如下表所示。</p>
<table>
<thead>
<tr>
<th>方  法</th>
<th>备  注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Field(i int) Value</td>
<td>根据索引，返回索引对应的结构体成员字段的反射值对象。当值不是结构体或索引超界时发生宕机</td>
</tr>
<tr>
<td>NumField() int</td>
<td>返回结构体成员字段数量。当值不是结构体或索引超界时发生宕机</td>
</tr>
<tr>
<td>FieldByName(name string) Value</td>
<td>根据给定字符串返回字符串对应的结构体字段。没有找到时返回零值，当值不是结构体或索引超界时发生宕机</td>
</tr>
<tr>
<td>FieldByIndex(index []int) Value</td>
<td>多层成员访问时，根据 []int 提供的每个结构体的字段索引，返回字段的值。 没有找到时返回零值，当值不是结构体或索引超界时发生宕机</td>
</tr>
<tr>
<td>FieldByNameFunc(match func(string) bool) Value</td>
<td>根据匹配函数匹配需要的字段。找到时返回零值，当值不是结构体或索引超界时发生宕机</td>
</tr>
</tbody>
</table>
<p>下面代码构造一个结构体包含不同类型的成员。通过 reflect.Value 提供的成员访问函数，可以获得结构体值的各种数据。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;reflect&#34;</span>
)
<span style="color:#75715e">// 定义结构体
</span><span style="color:#75715e"></span><span style="color:#66d9ef">type</span> <span style="color:#a6e22e">dummy</span> <span style="color:#66d9ef">struct</span> {
    <span style="color:#a6e22e">a</span> <span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">b</span> <span style="color:#66d9ef">string</span>
    <span style="color:#75715e">// 嵌入字段
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">float32</span>
    <span style="color:#66d9ef">bool</span>
    <span style="color:#a6e22e">next</span> <span style="color:#f92672">*</span><span style="color:#a6e22e">dummy</span>
}
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 值包装结构体
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">dummy</span>{
            <span style="color:#a6e22e">next</span>: <span style="color:#f92672">&amp;</span><span style="color:#a6e22e">dummy</span>{},
    })
    <span style="color:#75715e">// 获取字段数量
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;NumField&#34;</span>, <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">NumField</span>())
    <span style="color:#75715e">//NumField 5
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 获取索引为2的字段(float32字段)
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">floatField</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">Field</span>(<span style="color:#ae81ff">2</span>)

    <span style="color:#75715e">// 输出字段类型
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;Field&#34;</span>, <span style="color:#a6e22e">floatField</span>.<span style="color:#a6e22e">Type</span>())
    <span style="color:#75715e">//Field float32
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 根据名字查找字段
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;FieldByName(\&#34;b\&#34;).Type&#34;</span>, <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">FieldByName</span>(<span style="color:#e6db74">&#34;b&#34;</span>).<span style="color:#a6e22e">Type</span>())
        <span style="color:#75715e">//FieldByName(&#34;b&#34;).Type string
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 根据索引查找值中, next字段的int字段的值
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;FieldByIndex([]int{4, 0}).Type()&#34;</span>, <span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">FieldByIndex</span>([]<span style="color:#66d9ef">int</span>{<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">0</span>}).<span style="color:#a6e22e">Type</span>())
    
	<span style="color:#75715e">//FieldByIndex([]int{4, 0}).Type() int
</span><span style="color:#75715e"></span>}
</code></pre></div><h1 id="提供一系列方法进行零值和空判定">提供一系列方法进行零值和空判定</h1>
<p>反射值对象的零值和有效性判断方法</p>
<table>
<thead>
<tr>
<th>方 法</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>IsNil() bool</td>
<td>返回值是否为 nil。如果值类型不是通道（channel）、函数、接口、map、指针或 切片时发生 panic，类似于语言层的<code>v== nil</code>操作</td>
</tr>
<tr>
<td>IsValid() bool</td>
<td>判断值是否有效。 当值本身非法时，返回 false，例如 reflect Value不包含任何值，值为 nil 等。</td>
</tr>
</tbody>
</table>
<p>下面的例子将会对各种方式的空指针进行 IsNil() 和 IsValid() 的返回值判定检测。同时对结构体成员及方法查找 map 键值对的返回值进行 IsValid() 判定，参考下面的代码。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#f92672">package</span> <span style="color:#a6e22e">main</span>
<span style="color:#f92672">import</span> (
    <span style="color:#e6db74">&#34;fmt&#34;</span>
    <span style="color:#e6db74">&#34;reflect&#34;</span>
)
<span style="color:#66d9ef">func</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// *int的空指针
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">a</span> <span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>
    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;var a *int:&#34;</span>, <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">a</span>).<span style="color:#a6e22e">IsNil</span>())
    <span style="color:#75715e">// nil值
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;nil:&#34;</span>, <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#66d9ef">nil</span>).<span style="color:#a6e22e">IsValid</span>())
    <span style="color:#75715e">// *int类型的空指针
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;(*int)(nil):&#34;</span>, <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>((<span style="color:#f92672">*</span><span style="color:#66d9ef">int</span>)(<span style="color:#66d9ef">nil</span>)).<span style="color:#a6e22e">Elem</span>().<span style="color:#a6e22e">IsValid</span>())
    <span style="color:#75715e">// 实例化一个结构体
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">s</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">struct</span>{}{}
    <span style="color:#75715e">// 尝试从结构体中查找一个不存在的字段
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;不存在的结构体成员:&#34;</span>, <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">s</span>).<span style="color:#a6e22e">FieldByName</span>(<span style="color:#e6db74">&#34;&#34;</span>).<span style="color:#a6e22e">IsValid</span>())
    <span style="color:#75715e">// 尝试从结构体中查找一个不存在的方法
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;不存在的结构体方法:&#34;</span>, <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">s</span>).<span style="color:#a6e22e">MethodByName</span>(<span style="color:#e6db74">&#34;&#34;</span>).<span style="color:#a6e22e">IsValid</span>())
    <span style="color:#75715e">// 实例化一个map
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">m</span> <span style="color:#f92672">:=</span> <span style="color:#66d9ef">map</span>[<span style="color:#66d9ef">int</span>]<span style="color:#66d9ef">int</span>{}
    <span style="color:#75715e">// 尝试从map中查找一个不存在的键
</span><span style="color:#75715e"></span>    <span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#e6db74">&#34;不存在的键：&#34;</span>, <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">m</span>).<span style="color:#a6e22e">MapIndex</span>(<span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#ae81ff">3</span>)).<span style="color:#a6e22e">IsValid</span>())
}
</code></pre></div><h1 id="通过反射修改变量的值">通过反射修改变量的值</h1>
<p>Go语言中类似 x、x.f[1] 和 *p 形式的表达式都可以表示变量，但是其它如 x + 1 和 f(2) 则不是变量。一个变量就是一个可寻址的内存空间，里面存储了一个值，并且存储的值可以通过内存地址来更新。</p>
<p>对于 reflect.Values 也有类似的区别。有一些 reflect.Values 是可取地址的；其它一些则不可以。考虑以下的声明语句：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">x</span> <span style="color:#f92672">:=</span> <span style="color:#ae81ff">2</span> <span style="color:#75715e">// value type variable?
</span><span style="color:#75715e"></span><span style="color:#a6e22e">a</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#ae81ff">2</span>) <span style="color:#75715e">// 2 int no
</span><span style="color:#75715e"></span><span style="color:#a6e22e">b</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#a6e22e">x</span>) <span style="color:#75715e">// 2 int no
</span><span style="color:#75715e"></span><span style="color:#a6e22e">c</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">reflect</span>.<span style="color:#a6e22e">ValueOf</span>(<span style="color:#f92672">&amp;</span><span style="color:#a6e22e">x</span>) <span style="color:#75715e">// &amp;x *int no
</span><span style="color:#75715e"></span><span style="color:#a6e22e">d</span> <span style="color:#f92672">:=</span> <span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">Elem</span>() <span style="color:#75715e">// 2 int yes (x)
</span></code></pre></div><p>其中 a 对应的变量则不可取地址。因为 a 中的值仅仅是整数 2 的拷贝副本。b 中的值也同样不可取地址。c 中的值还是不可取地址，它只是一个指针 &amp;x 的拷贝。实际上，所有通过 reflect.ValueOf(x) 返回的 reflect.Value 都是不可取地址的。但是对于 d，它是 c 的解引用方式生成的，指向另一个变量，因此是可取地址的。我们可以通过调用 reflect.ValueOf(&amp;x).Elem()，来获取任意变量x对应的可取地址的 Value。</p>
<p>我们可以通过调用 reflect.Value 的 CanAddr 方法来判断其是否可以被取地址：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-go" data-lang="go"><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">a</span>.<span style="color:#a6e22e">CanAddr</span>()) <span style="color:#75715e">// &#34;false&#34;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">b</span>.<span style="color:#a6e22e">CanAddr</span>()) <span style="color:#75715e">// &#34;false&#34;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">c</span>.<span style="color:#a6e22e">CanAddr</span>()) <span style="color:#75715e">// &#34;false&#34;
</span><span style="color:#75715e"></span><span style="color:#a6e22e">fmt</span>.<span style="color:#a6e22e">Println</span>(<span style="color:#a6e22e">d</span>.<span style="color:#a6e22e">CanAddr</span>()) <span style="color:#75715e">// &#34;true&#34;
</span></code></pre></div><p>每当我们通过指针间接地获取的 reflect.Value 都是可取地址的，即使开始的是一个不可取地址的 Value。在反射机制中，所有关于是否支持取地址的规则都是类似的。例如，slice 的索引表达式 e[i]将隐式地包含一个指针，它就是可取地址的，即使开始的e表达式不支持也没有关系。</p>
<p>以此类推，reflect.ValueOf(e).Index(i) 对于的值也是可取地址的，即使原始的 reflect.ValueOf(e) 不支持也没有关系。</p>
<p>使用 reflect.Value 对包装的值进行修改时，需要遵循一些规则。如果没有按照规则进行代码设计和编写，轻则无法修改对象值，重则程序在运行时会发生宕机。</p>
<h1 id="判定及获取元素的相关方法">判定及获取元素的相关方法</h1>
<p>使用 reflect.Value 取元素、取地址及修改值的属性方法请参考下表。</p>
<table>
<thead>
<tr>
<th>方法名</th>
<th>备  注</th>
</tr>
</thead>
<tbody>
<tr>
<td>Elem() Value</td>
<td>取值指向的元素值，类似于语言层<code>*</code>操作。当值类型不是指针或接口时发生宕 机，空指针时返回 nil 的 Value</td>
</tr>
<tr>
<td>Addr() Value</td>
<td>对可寻址的值返回其地址，类似于语言层<code>&amp;</code>操作。当值不可寻址时发生宕机</td>
</tr>
<tr>
<td>CanAddr() bool</td>
<td>表示值是否可寻址</td>
</tr>
<tr>
<td>CanSet() bool</td>
<td>返回值能否被修改。要求值可寻址且是导出的字段</td>
</tr>
</tbody>
</table>
<h1 id="值修改相关方法">值修改相关方法</h1>
<p>使用 reflect.Value 修改值的相关方法如下表所示。</p>
<table>
<thead>
<tr>
<th>Set(x Value)</th>
<th>将值设置为传入的反射值对象的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Setlnt(x int64)</td>
<td>使用 int64 设置值。当值的类型不是 int、int8、int16、 int32、int64 时会发生宕机</td>
</tr>
<tr>
<td>SetUint(x uint64)</td>
<td>使用 uint64 设置值。当值的类型不是 uint、uint8、uint16、uint32、uint64 时会发生宕机</td>
</tr>
<tr>
<td>SetFloat(x float64)</td>
<td>使用 float64 设置值。当值的类型不是 float32、float64 时会发生宕机</td>
</tr>
<tr>
<td>SetBool(x bool)</td>
<td>使用 bool 设置值。当值的类型不是 bod 时会发生宕机</td>
</tr>
<tr>
<td>SetBytes(x []byte)</td>
<td>设置字节数组 []bytes值。当值的类型不是 []byte 时会发生宕机</td>
</tr>
<tr>
<td>SetString(x string)</td>
<td>设置字符串值。当值的类型不是 string 时会发生宕机</td>
</tr>
</tbody>
</table>
<p>以上方法，在 reflect.Value 的 CanSet 返回 false 仍然修改值时会发生宕机。</p>
<p>在已知值的类型时，应尽量使用值对应类型的反射设置值。</p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Jiang . </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://jfy0o0.github.io/2021/go-%E8%AF%A6%E8%A7%A3reflect/>https://jfy0o0.github.io/2021/go-%E8%AF%A6%E8%A7%A3reflect/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://jfy0o0.github.io/tags/go/">
                    #Go</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://jfy0o0.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://jfy0o0.github.io/2021/linux-io%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" class="prev" rel="prev" title="Linux - io 多路复用"><i class="iconfont icon-left"></i>&nbsp;Linux - io 多路复用</a>
         
        
        <a href="https://jfy0o0.github.io/2021/elementary-knowledge-p2p%E6%8A%80%E6%9C%AF%E4%B9%8Budp%E6%89%93%E6%B4%9E/" class="next" rel="next" title="elementary knowledge - P2P技术之UDP打洞">elementary knowledge - P2P技术之UDP打洞&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2011 - 2021</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://jfy0o0.github.io">Jiang .</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
