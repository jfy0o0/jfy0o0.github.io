<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Jiang .">
  
  
  
  <link rel="prev" href="https://jfy0o0.github.io/2021/other-%E5%86%85%E5%AD%98%E6%B1%A0/" />
  
  <link rel="canonical" href="https://jfy0o0.github.io/2021/db-rdbms/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           db - rdbms | Jiang . &#39;s blog
       
  </title>
  <meta name="title" content="db - rdbms | Jiang . &#39;s blog">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/jfy0o0.github.io"
    },
    "articleSection" : "posts",
    "name" : "db - rdbms",
    "headline" : "db - rdbms",
    "description" : "sql  SQL是结构化查询语言的缩写，用来访问和操作数据库系统。 SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。 不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。  能力 总的来说，SQL语言定义了这么几种操作数据库的能力：\nDDL：Data Definition Language\n​\tDDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。\nDML：Data Manipulation Language\n​\tDML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。\nDQL：Data Query Language\n​\tDQL允许用户查询数据，这也是通常最频繁的数据库日常操作。\n语法特点  SQL语言关键字不区分大小写！！！ 但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。 同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。  数据模型 数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型：\n 层次模型 (树) 网状模型 (图) 关系模型 (表)  rdbms 数据类型 对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：\n   名称 类型 说明     INT 整型 4字节整数类型，范围约\u002b\/-21亿   BIGINT 长整型 8字节整数类型，范围约\u002b\/-922亿亿   REAL 浮点型 4字节浮点数，范围约\u002b\/-1038   DOUBLE 浮点型 8字节浮点数，范围约\u002b\/-10308   DECIMAL(M,N) 高精度小数 由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算   CHAR(N) 定长字符串 存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串   VARCHAR(N) 变长字符串 存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串   BOOLEAN 布尔类型 存储True或者False   DATE 日期类型 存储日期，例如，2018-06-22   TIME 时间类型 存储时间，例如，12:20:59   DATETIME 日期和时间类型 存储日期\u002b时间，例如，2018-06-22 12:20:59    关系模型  表的每一行称为记录（Record），记录是一个逻辑意义上的数据。 表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。  主键 在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，students表的两行记录：",
    "inLanguage" : "en-us",
    "author" : "Jiang",
    "creator" : "Jiang",
    "publisher": "Jiang",
    "accountablePerson" : "Jiang",
    "copyrightHolder" : "Jiang",
    "copyrightYear" : "2021",
    "datePublished": "2021-01-20 13:56:14 \u002b0800 CST",
    "dateModified" : "2021-01-20 13:56:14 \u002b0800 CST",
    "url" : "https:\/\/jfy0o0.github.io\/2021\/db-rdbms\/",
    "wordCount" : "890",
    "keywords" : [ "sql","db", "Jiang . \u0027s blog"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://jfy0o0.github.io">Jiang . &#39;s blog</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://jfy0o0.github.io">Jiang . &#39;s blog</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">db - rdbms</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://jfy0o0.github.io" rel="author">Jiang</a> with ♥ 
                <span class="post-time">
                on <time datetime=2021-01-20 itemprop="datePublished">January 20, 2021</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://jfy0o0.github.io/categories/db/"> db </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          <h1 id="sql">sql</h1>
<ul>
<li>SQL是结构化查询语言的缩写，用来访问和操作数据库系统。</li>
<li>SQL语句既可以查询数据库中的数据，也可以添加、更新和删除数据库中的数据，还可以对数据库进行管理和维护操作。</li>
<li>不同的数据库，都支持SQL，这样，我们通过学习SQL这一种语言，就可以操作各种不同的数据库。</li>
</ul>
<h2 id="能力">能力</h2>
<p>总的来说，SQL语言定义了这么几种操作数据库的能力：</p>
<p><strong>DDL：Data Definition Language</strong></p>
<p>​	DDL允许用户定义数据，也就是创建表、删除表、修改表结构这些操作。通常，DDL由数据库管理员执行。</p>
<p><strong>DML：Data Manipulation Language</strong></p>
<p>​	DML为用户提供添加、删除、更新数据的能力，这些是应用程序对数据库的日常操作。</p>
<p><strong>DQL：Data Query Language</strong></p>
<p>​	DQL允许用户查询数据，这也是通常最频繁的数据库日常操作。</p>
<h2 id="语法特点">语法特点</h2>
<ul>
<li>SQL语言关键字不区分大小写！！！</li>
<li>但是，针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写。</li>
<li>同一个数据库，有的在Linux上区分大小写，有的在Windows上不区分大小写。</li>
</ul>
<h1 id="数据模型">数据模型</h1>
<p>数据库按照数据结构来组织、存储和管理数据，实际上，数据库一共有三种模型：</p>
<ul>
<li>层次模型 (树)</li>
<li>网状模型 (图)</li>
<li>关系模型 (表)</li>
</ul>
<h1 id="rdbms">rdbms</h1>
<h2 id="数据类型">数据类型</h2>
<p>对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型。关系数据库支持的标准数据类型包括数值、字符串、时间等：</p>
<table>
<thead>
<tr>
<th style="text-align:left">名称</th>
<th style="text-align:left">类型</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">INT</td>
<td style="text-align:left">整型</td>
<td style="text-align:left">4字节整数类型，范围约+/-21亿</td>
</tr>
<tr>
<td style="text-align:left">BIGINT</td>
<td style="text-align:left">长整型</td>
<td style="text-align:left">8字节整数类型，范围约+/-922亿亿</td>
</tr>
<tr>
<td style="text-align:left">REAL</td>
<td style="text-align:left">浮点型</td>
<td style="text-align:left">4字节浮点数，范围约+/-1038</td>
</tr>
<tr>
<td style="text-align:left">DOUBLE</td>
<td style="text-align:left">浮点型</td>
<td style="text-align:left">8字节浮点数，范围约+/-10308</td>
</tr>
<tr>
<td style="text-align:left">DECIMAL(M,N)</td>
<td style="text-align:left">高精度小数</td>
<td style="text-align:left">由用户指定精度的小数，例如，DECIMAL(20,10)表示一共20位，其中小数10位，通常用于财务计算</td>
</tr>
<tr>
<td style="text-align:left">CHAR(N)</td>
<td style="text-align:left">定长字符串</td>
<td style="text-align:left">存储指定长度的字符串，例如，CHAR(100)总是存储100个字符的字符串</td>
</tr>
<tr>
<td style="text-align:left">VARCHAR(N)</td>
<td style="text-align:left">变长字符串</td>
<td style="text-align:left">存储可变长度的字符串，例如，VARCHAR(100)可以存储0~100个字符的字符串</td>
</tr>
<tr>
<td style="text-align:left">BOOLEAN</td>
<td style="text-align:left">布尔类型</td>
<td style="text-align:left">存储True或者False</td>
</tr>
<tr>
<td style="text-align:left">DATE</td>
<td style="text-align:left">日期类型</td>
<td style="text-align:left">存储日期，例如，2018-06-22</td>
</tr>
<tr>
<td style="text-align:left">TIME</td>
<td style="text-align:left">时间类型</td>
<td style="text-align:left">存储时间，例如，12:20:59</td>
</tr>
<tr>
<td style="text-align:left">DATETIME</td>
<td style="text-align:left">日期和时间类型</td>
<td style="text-align:left">存储日期+时间，例如，2018-06-22 12:20:59</td>
</tr>
</tbody>
</table>
<h2 id="关系模型">关系模型</h2>
<ul>
<li>表的每一行称为记录（Record），记录是一个逻辑意义上的数据。</li>
<li>表的每一列称为字段（Column），同一个表的每一行记录都拥有相同的若干字段。</li>
</ul>
<h2 id="主键">主键</h2>
<p>在关系数据库中，一张表中的每一行数据被称为一条记录。一条记录就是由多个字段组成的。例如，<code>students</code>表的两行记录：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id</th>
<th style="text-align:left">class_id</th>
<th style="text-align:left">name</th>
<th style="text-align:left">gender</th>
<th style="text-align:left">score</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">1</td>
<td style="text-align:left">小明</td>
<td style="text-align:left">M</td>
<td style="text-align:left">90</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">1</td>
<td style="text-align:left">小红</td>
<td style="text-align:left">F</td>
<td style="text-align:left">95</td>
</tr>
</tbody>
</table>
<p>每一条记录都包含若干定义好的字段。同一个表的所有记录都有相同的字段定义。</p>
<ul>
<li>对于关系表，有个很重要的约束，就是任意两条记录不能重复。不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为<em><strong>主键</strong></em>。</li>
</ul>
<h2 id="联合主键">联合主键</h2>
<p>关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键。</p>
<p>对于联合主键，允许一列有重复，只要不是所有主键列都重复即可：</p>
<table>
<thead>
<tr>
<th style="text-align:left">id_num</th>
<th style="text-align:left">id_type</th>
<th style="text-align:left">other columns…</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">A</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">A</td>
<td style="text-align:left">…</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">B</td>
<td style="text-align:left">…</td>
</tr>
</tbody>
</table>
<p>如果我们把上述表的<code>id_num</code>和<code>id_type</code>这两列作为联合主键，那么上面的3条记录都是允许的，因为没有两列主键组合起来是相同的。</p>
<p>没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升。</p>
<h2 id="外键">外键</h2>
<ul>
<li>当我们用主键唯一标识记录时，我们就可以在<code>students</code>表中确定任意一个学生的记录：</li>
<li>在<code>students</code>表中，通过<code>class_id</code>的字段，可以把数据与另一张表关联起来，这种列称为<code>外键</code>。</li>
<li>注意：删除外键约束并没有删除外键这一列。删除列是通过<code>DROP COLUMN …</code>实现的。</li>
</ul>
<h2 id="索引">索引</h2>
<p>在关系数据库中，如果有上万甚至上亿条记录，在查找记录的时候，想要获得非常快的速度，就需要使用索引。</p>
<p>如果要经常根据<code>score</code>列进行查询，就可以对<code>score</code>列创建索引：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> studentsADD <span style="color:#66d9ef">INDEX</span> idx_score (score);
</code></pre></div><h2 id="唯一索引">唯一索引</h2>
<p>在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。</p>
<p>但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设<code>students</code>表的<code>name</code>不能重复：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">ALTER</span> <span style="color:#66d9ef">TABLE</span> studentsADD <span style="color:#66d9ef">UNIQUE</span> <span style="color:#66d9ef">INDEX</span> uni_name (name);
</code></pre></div><h2 id="基本查询">基本查询</h2>
<p>要查询数据库表的数据，我们使用如下的SQL语句：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表名</span><span style="color:#f92672">&gt;</span> 	<span style="color:#f92672">#</span><span style="color:#960050;background-color:#1e0010">查询表的所有数据</span>
<span style="color:#66d9ef">SELECT</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">#</span><span style="color:#960050;background-color:#1e0010">测试数据库连接</span>
</code></pre></div><h2 id="条件查询">条件查询</h2>
<p>SELECT语句可以通过<code>WHERE</code>条件来设定查询条件，查询结果是满足查询条件的记录。例如，要指定条件“分数在80分或以上的学生”，写成<code>WHERE</code>条件就是<code>SELECT * FROM students WHERE score &gt;= 80</code>。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表名</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">WHERE</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">条件表达式</span><span style="color:#f92672">&gt;</span>
</code></pre></div><p>条件表达式可以用</p>
<ul>
<li><code>&lt;条件1&gt; AND &lt;条件2&gt;</code></li>
<li><code>&lt;条件1&gt; OR &lt;条件2&gt;</code>，</li>
<li><code>NOT &lt;条件&gt;</code>，
<ul>
<li>上述<code>NOT</code>条件<code>NOT class_id = 2</code>其实等价于<code>class_id &lt;&gt; 2</code>，因此，<code>NOT</code>查询不是很常用。</li>
</ul>
</li>
</ul>
<p>如果不加括号，条件运算按照<code>NOT</code>、<code>AND</code>、<code>OR</code>的优先级进行，</p>
<ul>
<li>即<code>NOT</code>优先级最高，</li>
<li>其次是<code>AND</code>，</li>
<li>最后是<code>OR</code>。</li>
<li>加上括号可以改变优先级。</li>
</ul>
<h2 id="投影查询">投影查询</h2>
<p>使用<code>SELECT * FROM &lt;表名&gt; WHERE &lt;条件&gt;</code>可以选出表中的若干条记录。我们注意到返回的二维表结构和原表是相同的，即结果集的所有列与原表的所有列都一一对应。</p>
<p>如果我们只希望返回某些列的数据，而不是所有列的数据，我们可以用</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#960050;background-color:#1e0010">列</span><span style="color:#ae81ff">1</span>, <span style="color:#960050;background-color:#1e0010">列</span><span style="color:#ae81ff">2</span>, <span style="color:#960050;background-color:#1e0010">列</span><span style="color:#ae81ff">3</span> <span style="color:#66d9ef">FROM</span> <span style="color:#960050;background-color:#1e0010">…</span>
</code></pre></div><p>，让结果集仅包含指定列。这种操作称为投影查询。</p>
<p>使用<code>SELECT 列1, 列2, 列3 FROM …</code>时，还可以给每一列起个别名，这样，结果集的列名就可以与原表的列名不同。它的语法是</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#960050;background-color:#1e0010">列</span><span style="color:#ae81ff">1</span> <span style="color:#960050;background-color:#1e0010">别名</span><span style="color:#ae81ff">1</span>, <span style="color:#960050;background-color:#1e0010">列</span><span style="color:#ae81ff">2</span> <span style="color:#960050;background-color:#1e0010">别名</span><span style="color:#ae81ff">2</span>, <span style="color:#960050;background-color:#1e0010">列</span><span style="color:#ae81ff">3</span> <span style="color:#960050;background-color:#1e0010">别名</span><span style="color:#ae81ff">3</span> <span style="color:#66d9ef">FROM</span> <span style="color:#960050;background-color:#1e0010">…</span>
</code></pre></div><h2 id="排序">排序</h2>
<p>我们使用SELECT查询时，细心的读者可能注意到，查询结果集通常是按照<code>id</code>排序的，也就是根据主键排序。这也是大部分数据库的做法。如果我们要根据其他条件排序怎么办？可以加上<code>ORDER BY</code>子句。例如按照成绩从低到高进行排序：</p>
<p>如果要反过来，按照成绩从高到底排序，我们可以加上<code>DESC</code>表示“倒序”：</p>
<p>例如，使用<code>ORDER BY score DESC, gender</code>表示先按<code>score</code>列倒序，如果有相同分数的，再按<code>gender</code>列排序：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> id,name,score
form student
<span style="color:#66d9ef">where</span> class_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> score <span style="color:#66d9ef">desc</span> ,id
</code></pre></div><h2 id="分页查询">分页查询</h2>
<p>这个查询可以通过<code>LIMIT &lt;M&gt; OFFSET &lt;N&gt;</code>子句实现。</p>
<ul>
<li>现在，我们把结果集分页，每页3条记录。要获取第1页的记录，可以使用<code>LIMIT 3 OFFSET 0</code>：</li>
<li>类似的，查询第3页的时候，<code>OFFSET</code>应该设定为6:</li>
<li>查询第4页的时候，<code>OFFSET</code>应该设定为9:</li>
</ul>
<p>可见，分页查询的关键在于，首先要确定每页需要显示的结果数量<code>pageSize</code>（这里是3），然后根据当前页的索引<code>pageIndex</code>（从1开始），确定<code>LIMIT</code>和<code>OFFSET</code>应该设定的值：</p>
<ul>
<li><code>LIMIT</code>总是设定为<code>pageSize</code>；</li>
<li><code>OFFSET</code>计算公式为<code>pageSize * (pageIndex - 1)</code>。</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> id,name,score
form student
<span style="color:#66d9ef">where</span> class_id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
<span style="color:#66d9ef">order</span> <span style="color:#66d9ef">by</span> score <span style="color:#66d9ef">desc</span> ,id
<span style="color:#66d9ef">limit</span> <span style="color:#ae81ff">3</span> <span style="color:#66d9ef">offset</span> <span style="color:#ae81ff">2</span>
<span style="color:#f92672">#</span><span style="color:#ae81ff">3</span><span style="color:#960050;background-color:#1e0010">条为一页</span> <span style="color:#960050;background-color:#1e0010">，显示第</span><span style="color:#ae81ff">3</span><span style="color:#960050;background-color:#1e0010">页</span>
</code></pre></div><h2 id="聚合查询">聚合查询</h2>
<p>以查询<code>students</code>表一共有多少条记录为例，我们可以使用SQL内置的<code>COUNT()</code>函数查询：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) num <span style="color:#66d9ef">from</span> students
<span style="color:#f92672">#</span>num <span style="color:#960050;background-color:#1e0010">为别名</span>
</code></pre></div><p>除了<code>COUNT()</code>函数外，SQL还提供了如下聚合函数：</p>
<table>
<thead>
<tr>
<th style="text-align:left">函数</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SUM</td>
<td style="text-align:left">计算某一列的合计值，该列必须为数值类型</td>
</tr>
<tr>
<td style="text-align:left">AVG</td>
<td style="text-align:left">计算某一列的平均值，该列必须为数值类型</td>
</tr>
<tr>
<td style="text-align:left">MAX</td>
<td style="text-align:left">计算某一列的最大值</td>
</tr>
<tr>
<td style="text-align:left">MIN</td>
<td style="text-align:left">计算某一列的最小值</td>
</tr>
</tbody>
</table>
<h3 id="分组">分组</h3>
<ul>
<li>如果我们要统计一班的学生数量，我们知道，可以用<code>SELECT COUNT(*) num FROM students WHERE class_id = 1;</code>。</li>
<li>如果要继续统计二班、三班的学生数量，难道必须不断修改<code>WHERE</code>条件来执行<code>SELECT</code>语句吗？</li>
<li>对于聚合查询，SQL还提供了“分组聚合”的功能。我们观察下面的聚合查询：</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) num <span style="color:#66d9ef">from</span> students <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> class_id
</code></pre></div><p>执行这个查询，<code>COUNT()</code>的结果不再是一个，而是3个，这是因为，<code>GROUP BY</code>子句指定了按<code>class_id</code>分组，因此，执行该<code>SELECT</code>语句时，会把<code>class_id</code>相同的列先分组，再分别计算，因此，得到了3行结果。</p>
<p>但是这3行结果分别是哪三个班级的，不好看出来，所以我们可以把<code>class_id</code>列也放入结果集中：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> class_id, <span style="color:#66d9ef">count</span>(<span style="color:#f92672">*</span>) num <span style="color:#66d9ef">from</span> students <span style="color:#66d9ef">group</span> <span style="color:#66d9ef">by</span> class_id
</code></pre></div><h2 id="多表查询">多表查询</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表</span><span style="color:#ae81ff">2</span><span style="color:#f92672">&gt;</span>
</code></pre></div><h3 id="别名">别名</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> 
	students.id sid
	students.name
	students.gender
	classes.id cid
	classes.name cname
<span style="color:#66d9ef">from</span> students,classes
</code></pre></div><p>或者</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> 
	s.id sid
	s.name
	s.gender
	<span style="color:#66d9ef">c</span>.id cid
	<span style="color:#66d9ef">c</span>.name cname
<span style="color:#66d9ef">from</span> students s,classes <span style="color:#66d9ef">c</span>
</code></pre></div><p>多表查询也是可以添加<code>WHERE</code>条件的，我们来试试：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">select</span> 
	s.id sid
	s.name
	s.gender
	<span style="color:#66d9ef">c</span>.id cid
	<span style="color:#66d9ef">c</span>.name cname
<span style="color:#66d9ef">from</span> students s,classes <span style="color:#66d9ef">c</span>
<span style="color:#66d9ef">where</span> s.gender <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;M&#39;</span> <span style="color:#66d9ef">and</span> <span style="color:#66d9ef">c</span>.id <span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>
</code></pre></div><p>使用多表查询可以获取M x N行记录；</p>
<p>多表查询的结果集可能非常巨大，要小心使用。</p>
<h2 id="连接查询">连接查询</h2>
<p>对于这么多种JOIN查询，到底什么使用应该用哪种呢？其实我们用图来表示结果集就一目了然了。</p>
<p>假设查询语句是：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">SELECT</span> ... <span style="color:#66d9ef">FROM</span> tableA <span style="color:#f92672">???</span> <span style="color:#66d9ef">JOIN</span> tableB <span style="color:#66d9ef">ON</span> tableA.column1 <span style="color:#f92672">=</span> tableB.column2;
</code></pre></div><p>我们把tableA看作左表，把tableB看成右表，那么INNER JOIN是选出两张表都存在的记录：</p>
<p><img src="https://static.sitestack.cn/projects/liaoxuefeng-sql/15ba0c63de40a997a03977ed4e9b74b1.png" alt="inner-join"></p>
<p>LEFT OUTER JOIN是选出左表存在的记录：</p>
<p><img src="https://static.sitestack.cn/projects/liaoxuefeng-sql/b4ee0074ef690475a3c50f79f95c50a4.png" alt="left-outer-join"></p>
<p>RIGHT OUTER JOIN是选出右表存在的记录：</p>
<p><img src="https://static.sitestack.cn/projects/liaoxuefeng-sql/c3d6e28accda8167e6dca43d3cffe647.png" alt="right-outer-join"></p>
<p>FULL OUTER JOIN则是选出左右表都存在的记录：</p>
<p><img src="https://static.sitestack.cn/projects/liaoxuefeng-sql/b8053b553c2de954d51a0aff1f9fb689.png" alt="full-outer-join"></p>
<h3 id="heading"></h3>
<ul>
<li>JOIN查询需要先确定主表，然后把另一个表的数据“附加”到结果集上；</li>
<li>INNER JOIN是最常用的一种JOIN查询，它的语法是<code>SELECT … FROM &lt;表1&gt; INNER JOIN &lt;表2&gt; ON &lt;条件…&gt;</code>；</li>
<li>JOIN查询仍然可以使用<code>WHERE</code>条件和<code>ORDER BY</code>排序。</li>
</ul>
<h2 id="连接详解">连接详解</h2>
<p><strong>数据中的连接join分为内连接、自然连接、外连接，外连接又分为左外连接、右外连接、全外连接</strong></p>
<p>表1</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>5</td>
<td>6</td>
<td>7</td>
</tr>
</tbody>
</table>
<p>表2</p>
<table>
<thead>
<tr>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>8</td>
<td>9</td>
<td>1</td>
</tr>
</tbody>
</table>
<p>当然，这些分类都是在连接的基础上，是从两个表中记录的笛卡尔积中选取满足连接的记录。笛卡尔积简单的说就是一个表里的记录要分别和另外一个表的记录匹配为一条记录，即如果表1有3条记录，表2也有三条记录，经过笛卡尔运算之后就应该有3*3即9条记录。如下表</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>8</td>
<td>9</td>
<td>1</td>
</tr>
<tr>
<td>5</td>
<td>6</td>
<td>7</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>5</td>
<td>6</td>
<td>7</td>
<td>8</td>
<td>9</td>
<td>1</td>
</tr>
</tbody>
</table>
<h3 id="自然连接natural-join"><strong>自然连接（natural join）</strong></h3>
<p>自然连接是一种特殊的等值连接，他要求两个关系表中进行比较的必须是相同的属性列，无须添加连接条件，并且在结果中消除重复的属性列。
sql语句：Select …… from 表1 natural join 表2
结果：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody>
</table>
<h3 id="内连接inner-join"><strong>内连接（inner join）</strong></h3>
<p>内连接基本与自然连接相同，不同之处在于自然连接要求是同名属性列的比较，而内连接则不要求两属性列同名，可以用using或on来指定某两列字段相同的连接条件。
sql语句：Select …… from 表1 inner join 表 2 on 表1.A=表2.E
结果：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>1.C</th>
<th>2.C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>5</td>
<td>6</td>
<td>7</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
</tbody>
</table>
<p>自然连接时某些属性值不同则会导致这些元组会被舍弃，那如何保存这些会被丢失的信息呢，外连接就解决了相应的问题。外连接分为左外连接、右外连接、全外连接。外连接必须用using或on指定连接条件。</p>
<h3 id="左外连接left-outer-join"><strong>左外连接（left outer join)</strong></h3>
<p>左外连接是在两表进行自然连接，只把左表要舍弃的保留在结果集中，右表对应的列上填null。
sql语句：Select …… from 表1 left outer join 表2 on 表1.C=表2.C
结果：</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>5</td>
<td>6</td>
<td>7</td>
<td>NULL</td>
<td>NULL</td>
</tr>
</tbody>
</table>
<h3 id="右外连接rignt-outer-join"><strong>右外连接(rignt outer join)</strong></h3>
<p>右外连接是在两表进行自然连接，只把右表要舍弃的保留在结果集中，左表对应的列上填null。
Select …… from 表1 rignt outer join 表2 on 表1.C=表2.C</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>NULL</td>
<td>NULL</td>
<td>8</td>
<td>9</td>
<td>1</td>
</tr>
</tbody>
</table>
<h3 id="全外连接full-join"><strong>全外连接(full join)</strong></h3>
<p>全外连接是在两表进行自然连接，只把左表和右表要舍弃的都保留在结果集中，相对应的列上填null。
Select …… from 表1 full join 表2 on 表1.C=表2.C</p>
<table>
<thead>
<tr>
<th>A</th>
<th>B</th>
<th>C</th>
<th>D</th>
<th>E</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2</td>
<td>3</td>
<td>4</td>
<td>5</td>
</tr>
<tr>
<td>5</td>
<td>6</td>
<td>7</td>
<td>NULL</td>
<td>NULL</td>
</tr>
<tr>
<td>NULL</td>
<td>NULL</td>
<td>8</td>
<td>9</td>
<td>1</td>
</tr>
</tbody>
</table>
<h2 id="crud">crud</h2>
<p>而对于增、删、改，对应的SQL语句分别是：</p>
<ul>
<li>INSERT：插入新记录；</li>
<li>UPDATE：更新已有记录；</li>
<li>DELETE：删除已有记录。</li>
</ul>
<p><code>INSERT</code>语句的基本语法是：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表名</span><span style="color:#f92672">&gt;</span> (<span style="color:#960050;background-color:#1e0010">字段</span><span style="color:#ae81ff">1</span>, <span style="color:#960050;background-color:#1e0010">字段</span><span style="color:#ae81ff">2</span>, ...) <span style="color:#66d9ef">VALUES</span> (<span style="color:#960050;background-color:#1e0010">值</span><span style="color:#ae81ff">1</span>, <span style="color:#960050;background-color:#1e0010">值</span><span style="color:#ae81ff">2</span>, ...);
</code></pre></div><p><code>UPDATE</code>语句的基本语法是：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">UPDATE</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表名</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">SET</span> <span style="color:#960050;background-color:#1e0010">字段</span><span style="color:#ae81ff">1</span><span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">值</span><span style="color:#ae81ff">1</span>, <span style="color:#960050;background-color:#1e0010">字段</span><span style="color:#ae81ff">2</span><span style="color:#f92672">=</span><span style="color:#960050;background-color:#1e0010">值</span><span style="color:#ae81ff">2</span>, ... <span style="color:#66d9ef">WHERE</span> ...;
</code></pre></div><p><code>DELETE</code>语句的基本语法是：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">DELETE</span> <span style="color:#66d9ef">FROM</span> <span style="color:#f92672">&lt;</span><span style="color:#960050;background-color:#1e0010">表名</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">WHERE</span> ...;
</code></pre></div><p>要创建一个新数据库，使用命令：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">DATABASE</span> test;
</code></pre></div><p>要删除一个数据库，使用命令：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">mysql<span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">DROP</span> <span style="color:#66d9ef">DATABASE</span> test;
</code></pre></div><p>对一个数据库进行操作时，要首先将其切换为当前数据库：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql">mysql<span style="color:#f92672">&gt;</span> USE test;
</code></pre></div><h3 id="插入或替换">插入或替换</h3>
<p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就先删除原记录，再插入新记录。此时，可以使用<code>REPLACE</code>语句，这样就不必先查询，再决定是否先删除再插入：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">REPLACE</span> <span style="color:#66d9ef">INTO</span> students (id, class_id, name, gender, score) <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;小明&#39;</span>, <span style="color:#e6db74">&#39;F&#39;</span>, <span style="color:#ae81ff">99</span>);
</code></pre></div><p>若<code>id=1</code>的记录不存在，<code>REPLACE</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被删除，然后再插入新记录。</p>
<h3 id="插入或更新">插入或更新</h3>
<p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就更新该记录，此时，可以使用<code>INSERT INTO … ON DUPLICATE KEY UPDATE …</code>语句：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> students (id, class_id, name, gender, score) <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;小明&#39;</span>, <span style="color:#e6db74">&#39;F&#39;</span>, <span style="color:#ae81ff">99</span>) <span style="color:#66d9ef">ON</span> DUPLICATE <span style="color:#66d9ef">KEY</span> <span style="color:#66d9ef">UPDATE</span> name<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;小明&#39;</span>, gender<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;F&#39;</span>, score<span style="color:#f92672">=</span><span style="color:#ae81ff">99</span>;
</code></pre></div><p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，当前<code>id=1</code>的记录将被更新，更新的字段由<code>UPDATE</code>指定。</p>
<h3 id="插入或忽略">插入或忽略</h3>
<p>如果我们希望插入一条新记录（INSERT），但如果记录已经存在，就啥事也不干直接忽略，此时，可以使用<code>INSERT IGNORE INTO …</code>语句：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">IGNORE</span> <span style="color:#66d9ef">INTO</span> students (id, class_id, name, gender, score) <span style="color:#66d9ef">VALUES</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#39;小明&#39;</span>, <span style="color:#e6db74">&#39;F&#39;</span>, <span style="color:#ae81ff">99</span>);
</code></pre></div><p>若<code>id=1</code>的记录不存在，<code>INSERT</code>语句将插入新记录，否则，不执行任何操作。</p>
<h3 id="快照">快照</h3>
<p>如果想要对一个表进行快照，即复制一份当前表的数据到一个新表，可以结合<code>CREATE TABLE</code>和<code>SELECT</code>：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#75715e">-- 对class_id=1的记录进行快照，并存储为新表students_of_class1:
</span><span style="color:#75715e"></span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> students_of_class1 <span style="color:#66d9ef">SELECT</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">FROM</span> students <span style="color:#66d9ef">WHERE</span> class_id<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>;
</code></pre></div><p>新创建的表结构和<code>SELECT</code>使用的表结构完全一致。</p>
<h3 id="写入查询结果集">写入查询结果集</h3>
<p>如果查询结果集需要写入到表中，可以结合<code>INSERT</code>和<code>SELECT</code>，将<code>SELECT</code>语句的结果集直接插入到指定表中。</p>
<p>例如，创建一个统计成绩的表<code>statistics</code>，记录各班的平均成绩：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> <span style="color:#66d9ef">statistics</span> (    id BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> AUTO_INCREMENT,    class_id BIGINT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,    average DOUBLE <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,    <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span> (id));
</code></pre></div><p>然后，我们就可以用一条语句写入各班的平均成绩：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">INSERT</span> <span style="color:#66d9ef">INTO</span> <span style="color:#66d9ef">statistics</span> (class_id, average) <span style="color:#66d9ef">SELECT</span> class_id, <span style="color:#66d9ef">AVG</span>(score) <span style="color:#66d9ef">FROM</span> students <span style="color:#66d9ef">GROUP</span> <span style="color:#66d9ef">BY</span> class_id;
</code></pre></div><h3 id="强制使用指定索引">强制使用指定索引</h3>
<p>在查询的时候，数据库系统会自动分析查询语句，并选择一个最合适的索引。但是很多时候，数据库系统的查询优化器并不一定总是能使用最优索引。如果我们知道如何选择索引，可以使用<code>FORCE INDEX</code>强制查询使用指定的索引。例如：</p>
<pre><code>&gt; SELECT * FROM students FORCE INDEX (idx_class_id) WHERE class_id = 1 ORDER BY id DESC;
</code></pre><p>指定索引的前提是索引<code>idx_class_id</code>必须存在。</p>
<h2 id="事务">事务</h2>
<h3 id="特性">特性</h3>
<p>数据库事务具有ACID这4个特性：</p>
<ul>
<li>A：Atomic，原子性，将所有SQL作为原子工作单元执行，要么全部执行，要么全部不执行；</li>
<li>C：Consistent，一致性，事务完成后，所有数据的状态都是一致的，即A账户只要减去了100，B账户则必定加上了100；</li>
<li>I：Isolation，隔离性，如果有多个事务并发执行，每个事务作出的修改必须与其他事务隔离；</li>
<li>D：Duration，持久性，即事务完成后，对数据库数据的修改被持久化存储。</li>
</ul>
<p>要手动把多条SQL语句作为一个事务执行，使用<code>BEGIN</code>开启一个事务，使用<code>COMMIT</code>提交一个事务，这种事务被称为<em>显式事务</em>，例如，把上述的转账操作作为一个显式事务：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">BEGIN</span>;
<span style="color:#66d9ef">UPDATE</span> accounts <span style="color:#66d9ef">SET</span> balance <span style="color:#f92672">=</span> balance <span style="color:#f92672">-</span> <span style="color:#ae81ff">100</span> <span style="color:#66d9ef">WHERE</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">UPDATE</span> accounts <span style="color:#66d9ef">SET</span> balance <span style="color:#f92672">=</span> balance <span style="color:#f92672">+</span> <span style="color:#ae81ff">100</span> <span style="color:#66d9ef">WHERE</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
<span style="color:#66d9ef">COMMIT</span>;
</code></pre></div><p>有些时候，我们希望主动让事务失败，这时，可以用<code>ROLLBACK</code>回滚事务，整个事务会失败：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-sql" data-lang="sql"><span style="color:#66d9ef">BEGIN</span>;
<span style="color:#66d9ef">UPDATE</span> accounts <span style="color:#66d9ef">SET</span> balance <span style="color:#f92672">=</span> balance <span style="color:#f92672">-</span> <span style="color:#ae81ff">100</span> <span style="color:#66d9ef">WHERE</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
<span style="color:#66d9ef">UPDATE</span> accounts <span style="color:#66d9ef">SET</span> balance <span style="color:#f92672">=</span> balance <span style="color:#f92672">+</span> <span style="color:#ae81ff">100</span> <span style="color:#66d9ef">WHERE</span> id <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>;
<span style="color:#66d9ef">ROLLBACK</span>;
</code></pre></div><h3 id="隔离级别">隔离级别</h3>
<p>对于两个并发执行的事务，如果涉及到操作同一条记录的时候，可能会发生问题。因为并发操作会带来数据的不一致性，包括脏读、不可重复读、幻读等。数据库系统提供了隔离级别来让我们有针对性地选择事务的隔离级别，避免数据不一致的问题。</p>
<p>SQL标准定义了4种隔离级别，分别对应可能出现的数据不一致的情况：</p>
<table>
<thead>
<tr>
<th style="text-align:left">Isolation Level</th>
<th style="text-align:left">脏读（Dirty Read）</th>
<th style="text-align:left">不可重复读（Non Repeatable Read）</th>
<th style="text-align:left">幻读（Phantom Read）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Read Uncommitted</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">Read Committed</td>
<td style="text-align:left">-</td>
<td style="text-align:left">Yes</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">Repeatable Read</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">Yes</td>
</tr>
<tr>
<td style="text-align:left">Serializable</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
<td style="text-align:left">-</td>
</tr>
</tbody>
</table>
<p>我们会依次介绍4种隔离级别的数据一致性问题。</p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Jiang . </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://jfy0o0.github.io/2021/db-rdbms/>https://jfy0o0.github.io/2021/db-rdbms/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://jfy0o0.github.io/tags/sql/">
                    #sql</a></span>
            
            <span class="tag"><a href="https://jfy0o0.github.io/tags/db/">
                    #db</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://jfy0o0.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://jfy0o0.github.io/2021/other-%E5%86%85%E5%AD%98%E6%B1%A0/" class="prev" rel="prev" title="Other - 内存池"><i class="iconfont icon-left"></i>&nbsp;Other - 内存池</a>
         
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2011 - 2021</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://jfy0o0.github.io">Jiang .</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>
