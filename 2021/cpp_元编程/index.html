<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Jiang .">
  
  
  
  <link rel="prev" href="https://jfy0o0.github.io/2021/go-gdb%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95go%E7%A8%8B%E5%BA%8F/" />
  <link rel="next" href="https://jfy0o0.github.io/2021/elementary-knowledge-%E5%86%85%E5%AD%98%E4%BA%94%E5%8C%BA/" />
  <link rel="canonical" href="https://jfy0o0.github.io/2021/cpp_%E5%85%83%E7%BC%96%E7%A8%8B/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           C&#43;&#43; - 元编程 | Jiang . &#39;s blog
       
  </title>
  <meta name="title" content="C&#43;&#43; - 元编程 | Jiang . &#39;s blog">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/jfy0o0.github.io"
    },
    "articleSection" : "posts",
    "name" : "C\u002b\u002b - 元编程",
    "headline" : "C\u002b\u002b - 元编程",
    "description" : "概念 1.概述 　模版元编程（template metaprogram）是C\u002b\u002b中最复杂也是威力最强大的编程范式，它是一种可以创建和操纵程序的程序。模版元编程完全不同于普通的运行期程序，它很独特，因为模版元程序的执行完全是在编译期，并且模版元程序操纵的数据不能是运行时变量，只能是编译期常量，不可修改，另外它用到的语法元素也是相当有限，不能使用运行期的一些语法，比如if-else，for等语句都不能用。因此，模版元编程需要很多技巧，常常需要类型重定义、枚举常量、继承、模板偏特化等方法来配合，因此编写模版元编程比较复杂也比较困难。\n　现在C\u002b\u002b11新增了一些模版元相关的特性，不仅可以让我们编写模版元程序变得更容易，还进一步增强了泛型编程的能力，比如type_traits让我们不必再重复发明轮子了，给我们提供了大量便利的元函数，还提供了可变模板参数和tuple，让模版元编程“如虎添翼”。本文将向读者展示C\u002b\u002b11中模版元编程常用的技巧和具体应用。\n2.模版元基本概念 　模版元程序由元数据和元函数组成，元数据就是元编程可以操作的数据，即C\u002b\u002b编译器在编译期可以操作的数据。元数据不是运行期变量，只能是编译期常量，不能修改，常见的元数据有enum枚举常量、静态常量、基本类型和自定义类型等。\n　元函数是模板元编程中用于操作处理元数据的“构件”，可以在编译期被“调用”，因为它的功能和形式和运行时的函数类似，而被称为元函数，它是元编程中最重要的构件。元函数实际上表现为C\u002b\u002b的一个类、模板类或模板函数，它的通常形式如下：\ntemplate\u0026lt;int N, int M\u0026gt; struct meta_func { static const int value = N\u002bM; } 　调用元函数获取value值：cout\u0026laquo;meta_func\u0026lt;1, 2\u0026gt;::value\u0026laquo;endl;\n　meta_func的执行过程是在编译期完成的，实际执行程序时，是没有计算动作而是直接使用编译期的计算结果的。元函数只处理元数据，元数据是编译期常量和类型，所以下面的代码是编译不过的：\nint i = 1, j = 2; meta_func\u0026lt;i, j\u0026gt;::value; \/\/错误，元函数无法处理运行时普通数据 　模板元编程产生的源程序是在编译期执行的程序，因此它首先要遵循C\u002b\u002b和模板的语法，但是它操作的对象不是运行时普通的变量，因此不能使用运行时的C\u002b\u002b关键字（如if、else、for），可用的语法元素相当有限，最常用的是：\n enum、static const，用来定义编译期的整数常量； typedef\/using，用于定义元数据； T、Args\u0026hellip;，声明元数据类型； template，主要用于定义元函数； \u0026ldquo;::\u0026quot;，域运算符，用于解析类型作用域获取计算结果（元数据）。  如果模板元编程中需要if-else、for等逻辑时该怎么办呢？\n模板元中的if-else可以通过type_traits来实现，它不仅仅可以在编译期做判断，还可以做计算、查询、转换和选择。\n模板元中的for等逻辑可以通过递归、重载、和模板特化（偏特化）等方法实现。\n下面来看看C\u002b\u002b11提供的模版元基础库type_traits。\n3.type_traits 　type_traits是C\u002b\u002b11提供的模板元基础库，通过type_traits可以实现在编译期计算、查询、判断、转换和选择，提供了模板元编程需要的一些常用元函数。下面来看看一些基本的type_traits的基本用法。\n　最简单的一个type_traits是定义编译期常量的元函数integral_constant，它的定义如下：\ntemplate\u0026lt; class T, T v \u0026gt; struct integral_constant; 　借助这个简单的trait，我们可以很方便地定义编译期常量，比如定义一个值为1的int常量可以这样定义：",
    "inLanguage" : "en-us",
    "author" : "Jiang",
    "creator" : "Jiang",
    "publisher": "Jiang",
    "accountablePerson" : "Jiang",
    "copyrightHolder" : "Jiang",
    "copyrightYear" : "2021",
    "datePublished": "2021-11-08 14:36:36 \u002b0800 CST",
    "dateModified" : "2021-11-08 14:36:36 \u002b0800 CST",
    "url" : "https:\/\/jfy0o0.github.io\/2021\/cpp_%E5%85%83%E7%BC%96%E7%A8%8B\/",
    "wordCount" : "632",
    "keywords" : [ "C\u002b\u002b", "Jiang . \u0027s blog"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://jfy0o0.github.io">Jiang . &#39;s blog</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://jfy0o0.github.io">Jiang . &#39;s blog</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">C&#43;&#43; - 元编程</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://jfy0o0.github.io" rel="author">Jiang</a> with ♥ 
                <span class="post-time">
                on <time datetime=2021-11-08 itemprop="datePublished">November 8, 2021</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://jfy0o0.github.io/categories/c&#43;&#43;/"> C&#43;&#43; </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          <h1 id="概念">概念</h1>
<h3 id="1概述">1.概述</h3>
<p>　　模版元编程（template metaprogram）是C++中最复杂也是威力最强大的编程范式，它是一种可以创建和操纵程序的程序。模版元编程完全不同于普通的运行期程序，它很独特，因为模版元程序的执行完全是在编译期，并且模版元程序操纵的数据不能是运行时变量，只能是编译期常量，不可修改，另外它用到的语法元素也是相当有限，<strong>不能使用运行期的一些语法，比如if-else，for等语句都不能用</strong>。因此，模版元编程需要很多技巧，常常需要类型重定义、枚举常量、继承、模板偏特化等方法来配合，因此编写模版元编程比较复杂也比较困难。</p>
<p>　　现在C++11新增了一些模版元相关的特性，不仅可以让我们编写模版元程序变得更容易，还进一步增强了泛型编程的能力，比如<strong>type_traits</strong>让我们不必再重复发明轮子了，给我们提供了大量便利的元函数，还提供了可变模板参数和tuple，让模版元编程“如虎添翼”。本文将向读者展示C++11中模版元编程常用的技巧和具体应用。</p>
<h3 id="2模版元基本概念">2.模版元基本概念</h3>
<p>　　模版元程序由元数据和元函数组成，元数据就是元编程可以操作的数据，即C++编译器在编译期可以操作的数据。元数据不是运行期变量，只能是编译期常量，不能修改，常见的元数据有enum枚举常量、静态常量、基本类型和自定义类型等。</p>
<p>　　元函数是模板元编程中用于操作处理元数据的“构件”，可以在编译期被“调用”，因为它的功能和形式和运行时的函数类似，而被称为元函数，它是元编程中最重要的构件。元函数实际上表现为C++的一个类、模板类或模板函数，它的通常形式如下：</p>
<pre><code>template&lt;int N, int M&gt;
struct meta_func
{
    static const int value = N+M;
}
</code></pre><p>　　调用元函数获取value值：cout&laquo;meta_func&lt;1, 2&gt;::value&laquo;endl;</p>
<p>　　meta_func的执行过程是在编译期完成的，实际执行程序时，是没有计算动作而是直接使用编译期的计算结果的。元函数只处理元数据，元数据是编译期常量和类型，所以下面的代码是编译不过的：</p>
<pre><code>int i = 1, j = 2;
meta_func&lt;i, j&gt;::value; //错误，元函数无法处理运行时普通数据
</code></pre><p>　　模板元编程产生的源程序是在编译期执行的程序，因此它首先要遵循C++和模板的语法，但是它操作的对象不是运行时普通的变量，因此不能使用运行时的C++关键字（如if、else、for），可用的语法元素相当有限，最常用的是：</p>
<ul>
<li>enum、static const，用来定义编译期的整数常量；</li>
<li>typedef/using，用于定义元数据；</li>
<li>T、Args&hellip;，声明元数据类型；</li>
<li>template，主要用于定义元函数；</li>
<li>&ldquo;::&quot;，域运算符，用于解析类型作用域获取计算结果（元数据）。</li>
</ul>
<p>如果模板元编程中需要if-else、for等逻辑时该怎么办呢？</p>
<p>模板元中的if-else可以通过type_traits来实现，它不仅仅可以在编译期做判断，还可以做计算、查询、转换和选择。</p>
<p>模板元中的for等逻辑可以通过递归、重载、和模板特化（偏特化）等方法实现。</p>
<p>下面来看看C++11提供的模版元基础库type_traits。</p>
<h3 id="3type_traits">3.type_traits</h3>
<p>　　type_traits是C++11提供的模板元基础库，通过type_traits可以实现在编译期计算、查询、判断、转换和选择，提供了模板元编程需要的一些常用元函数。下面来看看一些基本的type_traits的基本用法。</p>
<p>　　最简单的一个type_traits是定义编译期常量的元函数integral_constant，它的定义如下：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, T v <span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">integral_constant</span>;
</code></pre></div><p>　　借助这个简单的trait，我们可以很方便地定义编译期常量，比如定义一个值为1的int常量可以这样定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">using</span> one_type <span style="color:#f92672">=</span> std<span style="color:#f92672">::</span>integral_constant<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>;
</code></pre></div><p>或者</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">one_type</span> <span style="color:#f92672">:</span> std<span style="color:#f92672">::</span>integral_constant<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>{};
</code></pre></div><p>　　获取常量则通过one_type::value来获取，这种定义编译期常量的方式相比C++98/03要简单，在C++98/03中定义编译期常量一般是这样定义的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">one_type</span>
{
    <span style="color:#66d9ef">enum</span>{value <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>};
};

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">one_type</span>
{
    <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span> value <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
};
</code></pre></div><p>　　可以看到，通过C++11的type_traits提供的一个简单的integral_constant就可以很方便的定义编译期常量，而无需再去通过定义enum和static const变量方式去定义编译期常量了，这也为定义编译期常量提供了另外一种方法。C++11的type_traits已经提供了编译期的true和false，是通过integral_constant来定义的：</p>
<pre><code>typedef  integral_constant&lt;bool, true&gt; true_type;
typedef  integral_constant&lt;bool, false&gt; false_type;
</code></pre><p>　　除了这些基本的元函数之外，type_traits还提供了丰富的元函数，比如用于编译期判断的元函数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;type_traits&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() {
  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;int: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>is_const<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;const int: &#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>is_const<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;

  <span style="color:#75715e">//判断类型是否相同
</span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>is_same<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>value<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;<span style="color:#75715e">// true
</span><span style="color:#75715e"></span>  std<span style="color:#f92672">::</span>cout<span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>is_same<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, unsignedint<span style="color:#f92672">&gt;::</span>value<span style="color:#f92672">&lt;&lt;</span><span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>;<span style="color:#75715e">// false
</span><span style="color:#75715e"></span>
  <span style="color:#75715e">//添加、移除const
</span><span style="color:#75715e"></span>  cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>is_same<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span>, add_const<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>type<span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&lt;&lt;</span> endl;
  cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>is_same<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, remove_const<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">const</span> <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>type<span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&lt;&lt;</span> endl;

  <span style="color:#75715e">//添加引用
</span><span style="color:#75715e"></span>  cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>is_same<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;</span>, add_lvalue_reference<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>type<span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&lt;&lt;</span> endl;
  cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>is_same<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;&amp;</span>, add_rvalue_reference<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>type<span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&lt;&lt;</span> endl;

  <span style="color:#75715e">//取公共类型
</span><span style="color:#75715e"></span>  <span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>common_type<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">char</span>, <span style="color:#66d9ef">short</span>, <span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>type NumericType;
  cout <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>is_same<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>, NumericType<span style="color:#f92672">&gt;::</span>value <span style="color:#f92672">&lt;&lt;</span> endl;

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><p>type_traits还提供了编译期选择traits：std::conditional，它在编译期根据一个判断式选择两个类型中的一个，和条件表达式的语义类似，类似于一个三元表达式。它的原型是：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">bool</span> B, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">F</span> <span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">conditional</span>;
</code></pre></div><p>用法比较简单：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;type_traits&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>() 
{
    <span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>conditional<span style="color:#f92672">&lt;</span>true,<span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;::</span>type A;               <span style="color:#75715e">// int
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>conditional<span style="color:#f92672">&lt;</span>false,<span style="color:#66d9ef">int</span>,<span style="color:#66d9ef">float</span><span style="color:#f92672">&gt;::</span>type B;              <span style="color:#75715e">// float
</span><span style="color:#75715e"></span>
    <span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>conditional<span style="color:#f92672">&lt;</span>(<span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>) <span style="color:#f92672">&gt;</span><span style="color:#66d9ef">sizeof</span>(<span style="color:#66d9ef">long</span> <span style="color:#66d9ef">double</span>)),
    <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">long</span>, <span style="color:#66d9ef">long</span> <span style="color:#66d9ef">double</span><span style="color:#f92672">&gt;::</span>type max_size_t;

    cout<span style="color:#f92672">&lt;&lt;</span><span style="color:#66d9ef">typeid</span>(max_size_t).name()<span style="color:#f92672">&lt;&lt;</span>endl;  <span style="color:#75715e">//long double
</span><span style="color:#75715e"></span>}
</code></pre></div><p>　　另外一个常用的type_traits是std::decay(朽化)，它对于普通类型来说std::decay（朽化）是移除引用和cv符，大大简化了我们的书写。除了普通类型之外，std::decay还可以用于数组和函数，具体的转换规则是这样的：</p>
<p>　　先移除T类型的引用，得到类型U，U定义为remove_reference<!-- raw HTML omitted -->::type。</p>
<ul>
<li>如果is_array<!-- raw HTML omitted -->::value为 true，修改类型type为remove_extent<!-- raw HTML omitted -->::type *。</li>
<li>否则，如果is_function<!-- raw HTML omitted -->::value为 true，修改类型type将为add_pointer<!-- raw HTML omitted -->::type。</li>
<li>否则，修改类型type为 remove_cv<!-- raw HTML omitted -->::type。</li>
</ul>
<p>std::decay的基本用法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>decay<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;::</span>type A;           <span style="color:#75715e">// int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>decay<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;&gt;::</span>type B;          <span style="color:#75715e">// int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>decay<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&amp;&amp;&gt;::</span>type C;         <span style="color:#75715e">// int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>decay<span style="color:#f92672">&lt;</span>constint<span style="color:#f92672">&amp;&gt;::</span>type D;    <span style="color:#75715e">// int
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>decay<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>[<span style="color:#ae81ff">2</span>]<span style="color:#f92672">&gt;::</span>type E;        <span style="color:#75715e">// int*
</span><span style="color:#75715e"></span><span style="color:#66d9ef">typedef</span> std<span style="color:#f92672">::</span>decay<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span>(<span style="color:#66d9ef">int</span>)<span style="color:#f92672">&gt;::</span>type F;      <span style="color:#75715e">// int(*)(int)
</span></code></pre></div><p>　　std::decay除了移除普通类型的cv符的作用之外，还可以将函数类型转换为函数指针类型，从而将函数指针变量保存起来，以便在后面延迟执行，比如下面的例子。</p>
<h1 id="引子">引子</h1>
<h2 id="交换迭代器10">交换迭代器1.0</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">iter1</span>,<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">iter2</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> my_swap (iter1 i1,iter2 i2)
{
    iter1<span style="color:#f92672">::</span>value_type t <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>i1;
    <span style="color:#f92672">*</span>i1 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>i2;
    <span style="color:#f92672">*</span>i2 <span style="color:#f92672">=</span> t;
}
</code></pre></div><p>要是参数类型不是迭代器，而是int*?</p>
<h2 id="交换迭代器11">交换迭代器1.1</h2>
<h3 id="使用萃取器-iterator_traits">使用萃取器 iterator_traits</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">iter1</span>,<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">iter2</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> my_swap (iter1 i1,iter2 i2)
{
    <span style="color:#66d9ef">typename</span> iterator_traits<span style="color:#f92672">&lt;</span>iter1<span style="color:#f92672">&gt;::</span>value_type t <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>i1;
    <span style="color:#f92672">*</span>i1 <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>i2;
    <span style="color:#f92672">*</span>i2 <span style="color:#f92672">=</span> t;
}
</code></pre></div><h1 id="stdenable_if">std::enable_if</h1>
<p>C++11中引入了std::enable_if函数，函数原型如下:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">bool</span> B, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">void</span> <span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">enable_if</span>;

</code></pre></div><p>可能的函数实现:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span> B, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">enable_if</span> {};
  
<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">enable_if</span><span style="color:#f92672">&lt;</span>true, T<span style="color:#f92672">&gt;</span> { <span style="color:#66d9ef">typedef</span> T type; };
<span style="color:#75715e">//由上可知，只有当第一个模板参数为true时，enable_if会包含一个type=T的公有成员，否则没有该公有成员。
</span></code></pre></div><h2 id="使用场景"><strong>使用场景</strong></h2>
<h3 id="1类型偏特化">1.类型偏特化</h3>
<p>在使用模板编程时，经常会用到根据模板参数的某些特性进行不同类型的选择，或者在编译时校验模板参数的某些特性。</p>
<p>在使用模板编程时，可以利用std::enable_if的特性根据模板参数的不同特性进行不同的类型选择。</p>
<p>如下所示，我们可以实现一个检测变量是否为智能指针的实现：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;iostream&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;type_traits&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;memory&gt;</span><span style="color:#75715e">
</span><span style="color:#75715e"></span> 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">is_smart_pointer_helper</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> std<span style="color:#f92672">::</span>false_type {};
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">is_smart_pointer_helper</span><span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> std<span style="color:#f92672">::</span>true_type {};
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">is_smart_pointer_helper</span><span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> std<span style="color:#f92672">::</span>true_type {};
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">is_smart_pointer_helper</span><span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>weak_ptr<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&gt;</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> std<span style="color:#f92672">::</span>true_type {};
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">is_smart_pointer</span> <span style="color:#f92672">:</span> <span style="color:#66d9ef">public</span> is_smart_pointer_helper<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>remove_cv<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>type<span style="color:#f92672">&gt;</span> {};
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>enable_if<span style="color:#f92672">&lt;</span>is_smart_pointer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value,<span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;::</span>type check_smart_pointer(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> t)
{
  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;is smart pointer&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>enable_if<span style="color:#f92672">&lt;!</span>is_smart_pointer<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value,<span style="color:#66d9ef">void</span><span style="color:#f92672">&gt;::</span>type check_smart_pointer(<span style="color:#66d9ef">const</span> T<span style="color:#f92672">&amp;</span> t)
{
  std<span style="color:#f92672">::</span>cout <span style="color:#f92672">&lt;&lt;</span> <span style="color:#e6db74">&#34;not smart pointer&#34;</span> <span style="color:#f92672">&lt;&lt;</span> std<span style="color:#f92672">::</span>endl;
}
 
<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>()
{
  <span style="color:#66d9ef">int</span><span style="color:#f92672">*</span> p(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">2</span>));
  std<span style="color:#f92672">::</span>shared_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> pp(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">2</span>));
  std<span style="color:#f92672">::</span>unique_ptr<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> upp(<span style="color:#66d9ef">new</span> <span style="color:#66d9ef">int</span>(<span style="color:#ae81ff">4</span>));
 
  check_smart_pointer(p);<span style="color:#75715e">//    not smart pointer
</span><span style="color:#75715e"></span>  check_smart_pointer(pp);<span style="color:#75715e">//    is smart pointer
</span><span style="color:#75715e"></span>  check_smart_pointer(upp);<span style="color:#75715e">//	is smart pointer
</span><span style="color:#75715e"></span>   
  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}
</code></pre></div><h3 id="2校验函数模板参数类型">2.校验函数模板参数类型</h3>
<p>有时定义的模板函数，只希望特定的类型可以调用，参考 cppreference 官网示例，很好的说明了如何限制只有整型可以调用的函数定义：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>enable_if<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>is_integral<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value, <span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;::</span>type
is_odd(T t) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">bool</span>(t<span style="color:#f92672">%</span><span style="color:#ae81ff">2</span>);
}
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>enable_if<span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>is_integral<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;::</span>value<span style="color:#f92672">&gt;::</span>type<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">bool</span> is_even(T t) {
  <span style="color:#66d9ef">return</span> <span style="color:#f92672">!</span>is_odd(t); 
}
</code></pre></div><p>一个通过返回值，一个通过默认模板参数，都可以实现校验模板参数是整型的功能。</p>
<h3 id="3控制函数返回类型">3.控制函数返回类型(?)</h3>
<p>对于模板函数，有时希望根据不同的模板参数返回不同类型的值，进而给函数模板也赋予类型模板特化的性质。典型的例子可以参看 <code>tuple</code> 的获取第 k 个元素的 <code>get</code> 函数：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>size_t k, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">Ts</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>enable_if<span style="color:#f92672">&lt;</span>k<span style="color:#f92672">==</span><span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">typename</span> element_type_holder<span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0</span>, T, Ts...<span style="color:#f92672">&gt;::</span>type<span style="color:#f92672">&amp;&gt;::</span>type
get(tuple<span style="color:#f92672">&lt;</span>T, Ts...<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>t) {
  <span style="color:#66d9ef">return</span> t.tail; 
}
 
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span>std<span style="color:#f92672">::</span>size_t k, <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">T</span>, <span style="color:#66d9ef">class</span><span style="color:#960050;background-color:#1e0010">... </span><span style="color:#a6e22e">Ts</span><span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">typename</span> std<span style="color:#f92672">::</span>enable_if<span style="color:#f92672">&lt;</span>k<span style="color:#f92672">!=</span><span style="color:#ae81ff">0</span>, <span style="color:#66d9ef">typename</span> element_type_holder<span style="color:#f92672">&lt;</span>k, T, Ts...<span style="color:#f92672">&gt;::</span>type<span style="color:#f92672">&amp;&gt;::</span>type
get(tuple<span style="color:#f92672">&lt;</span>T, Ts...<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>t) {
  tuple<span style="color:#f92672">&lt;</span>Ts...<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>base <span style="color:#f92672">=</span> t;
  <span style="color:#66d9ef">return</span> get<span style="color:#f92672">&lt;</span>k<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span><span style="color:#f92672">&gt;</span>(base); 
}
</code></pre></div><h1 id="不定参数">不定参数</h1>
<p>递归</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> trigger_func(<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>t) <span style="color:#75715e">//结束递归函数
</span><span style="color:#75715e"></span>{
	m_vector.Insert<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(t);
}
<span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T, <span style="color:#66d9ef">typename</span>... Args<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> trigger_func(<span style="color:#66d9ef">const</span> T <span style="color:#f92672">&amp;</span>t, <span style="color:#66d9ef">const</span> Args <span style="color:#f92672">&amp;</span>... rest)
{
	m_vector.Insert<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(t);
	trigger_func(rest...); <span style="color:#75715e">// 递归调用
</span><span style="color:#75715e"></span>}


</code></pre></div><h2 id="得到不定参的长度">得到不定参的长度</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span> <span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span>... Args<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">void</span> fun ()
{
   cout <span style="color:#f92672">&lt;&lt;</span>  <span style="color:#66d9ef">sizeof</span>...(Args) <span style="color:#f92672">&lt;&lt;</span>endl;
}
</code></pre></div><h1 id="判断是不是容器">判断是不是容器</h1>
<h2 id="1偏特化">1.偏特化</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-cpp" data-lang="cpp"><span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> 
<span style="color:#66d9ef">void</span> my_fun(T <span style="color:#f92672">&amp;</span>obj) 
{ 
    perform1(); 
} 

<span style="color:#66d9ef">template</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">typename</span> T<span style="color:#f92672">&gt;</span> 
<span style="color:#66d9ef">void</span> my_fun(std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> <span style="color:#f92672">&amp;</span>obj) 
{ 
    perform2(); 
} 

<span style="color:#66d9ef">int</span> <span style="color:#a6e22e">main</span>(<span style="color:#66d9ef">void</span>) 
{ 
    <span style="color:#66d9ef">int</span>    a; 
    std<span style="color:#f92672">::</span>vector<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">int</span><span style="color:#f92672">&gt;</span> b; 

    my_fun(a); 
    my_fun(b); 
} 
</code></pre></div><h1 id="心得">心得：</h1>
<ul>
<li>可以用is_same 判断类型后返回 类型名,用
<ul>
<li>remove_reference</li>
<li>remove_pointer</li>
<li>remove_volatile</li>
<li>remove_const</li>
<li>得到干净的类型，然后实现偏特化</li>
</ul>
</li>
<li>结合enable_if判断某个类型具有某些特性</li>
<li>不定参用递归，可以遍历</li>
</ul>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Jiang . </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://jfy0o0.github.io/2021/cpp_%E5%85%83%E7%BC%96%E7%A8%8B/>https://jfy0o0.github.io/2021/cpp_%E5%85%83%E7%BC%96%E7%A8%8B/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://jfy0o0.github.io/tags/c&#43;&#43;/">
                    #C&#43;&#43;</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://jfy0o0.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://jfy0o0.github.io/2021/go-gdb%E5%8A%A8%E6%80%81%E8%B0%83%E8%AF%95go%E7%A8%8B%E5%BA%8F/" class="prev" rel="prev" title="Go - gdb动态调试go程序"><i class="iconfont icon-left"></i>&nbsp;Go - gdb动态调试go程序</a>
         
        
        <a href="https://jfy0o0.github.io/2021/elementary-knowledge-%E5%86%85%E5%AD%98%E4%BA%94%E5%8C%BA/" class="next" rel="next" title="elementary knowledge - 内存五区">elementary knowledge - 内存五区&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2011 - 2021</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://jfy0o0.github.io">Jiang .</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
