<!DOCTYPE html>
<html lang="en-us">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="Jiang .">
  
  
  
  <link rel="prev" href="https://jfy0o0.github.io/2021/linux-%E8%BD%AF%E4%BB%B6-inotifywait/" />
  <link rel="next" href="https://jfy0o0.github.io/2021/cpp_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" />
  <link rel="canonical" href="https://jfy0o0.github.io/2021/linux-shell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Linux - shell常用命令 | Jiang . &#39;s blog
       
  </title>
  <meta name="title" content="Linux - shell常用命令 | Jiang . &#39;s blog">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "https:\/\/jfy0o0.github.io"
    },
    "articleSection" : "posts",
    "name" : "Linux - shell常用命令",
    "headline" : "Linux - shell常用命令",
    "description" : "() ①命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。\n②命令替换。等同于cmd，shell扫描一遍命令行，发现了$(cmd)结构，便将$(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。\n③用于初始化数组。如：array=(a b c d)\n(( )) ①整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是\u0026quot;假\u0026quot;，而一个非零值的表达式所返回的退出状态码将为0，或者是\u0026quot;true\u0026quot;。若是逻辑判断，表达式exp为真则为1,假则为0。\n②只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)\n③单纯用 (( )) 也可重定义变量值，比如 a=5; ((a\u002b\u002b)) 可将 $a 重定义为6\n④常用于算术运算比较，双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i=0;i\u0026lt;5;i\u002b\u002b)), 如果不使用双括号, 则为for i in seq 0 4或者for i in {0..4}。再如可以直接使用if (($i\u0026lt;5)), 如果不使用双括号, 则为if [ $i -lt 5 ]。\n[] ①bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if\/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if\/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。\n②Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较\u0026quot;ab\u0026quot;和\u0026quot;bc\u0026quot;：[ ab \u0026lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。\n③字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。 ④在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。\n[[ ]] ①[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。\n②支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。",
    "inLanguage" : "en-us",
    "author" : "Jiang",
    "creator" : "Jiang",
    "publisher": "Jiang",
    "accountablePerson" : "Jiang",
    "copyrightHolder" : "Jiang",
    "copyrightYear" : "2021",
    "datePublished": "2021-08-26 15:17:08 \u002b0800 CST",
    "dateModified" : "2021-08-26 15:17:08 \u002b0800 CST",
    "url" : "https:\/\/jfy0o0.github.io\/2021\/linux-shell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4\/",
    "wordCount" : "1155",
    "keywords" : [ "Linux", "Jiang . \u0027s blog"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://jfy0o0.github.io">Jiang . &#39;s blog</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="https://jfy0o0.github.io">Jiang . &#39;s blog</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">Blog</a>
                
                <a class="menu-item" href="/categories/" title="">Categories</a>
                
                <a class="menu-item" href="/tags/" title="">Tags</a>
                
                <a class="menu-item" href="/about/" title="">About</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">Linux - shell常用命令</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="https://jfy0o0.github.io" rel="author">Jiang</a> with ♥ 
                <span class="post-time">
                on <time datetime=2021-08-26 itemprop="datePublished">August 26, 2021</time>
                </span>
                in
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="https://jfy0o0.github.io/categories/linux/"> Linux </a>
                        
                </span>
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          <h1 id="heading">()</h1>
<p>①命令组。括号中的命令将会新开一个子shell顺序执行，所以括号中的变量不能够被脚本余下的部分使用。括号中多个命令之间用分号隔开，最后一个命令可以没有分号，各命令和括号之间不必有空格。</p>
<p>②命令替换。等同于<code>cmd</code>，shell扫描一遍命令行，发现了$(cmd)结构，便将$(cmd)中的cmd执行一次，得到其标准输出，再将此输出放到原来命令。有些shell不支持，如tcsh。</p>
<p>③用于初始化数组。如：array=(a b c d)</p>
<h1 id="-">(( ))</h1>
<p>①整数扩展。这种扩展计算是整数型的计算，不支持浮点型。((exp))结构扩展并计算一个算术表达式的值，如果表达式的结果为0，那么返回的退出状态码为1，或者 是&quot;假&quot;，而一个非零值的表达式所返回的退出状态码将为0，或者是&quot;true&quot;。若是逻辑判断，表达式exp为真则为1,假则为0。</p>
<p>②只要括号中的运算符、表达式符合C语言运算规则，都可用在$((exp))中，甚至是三目运算符。作不同进位(如二进制、八进制、十六进制)运算时，输出结果全都自动转化成了十进制。如：echo $((16#5f)) 结果为95 (16进位转十进制)</p>
<p>③单纯用 (( )) 也可重定义变量值，比如 a=5; ((a++)) 可将 $a 重定义为6</p>
<p>④常用于算术运算比较，双括号中的变量可以不使用$符号前缀。括号内支持多个表达式用逗号分开。 只要括号中的表达式符合C语言运算规则,比如可以直接使用for((i=0;i&lt;5;i++)), 如果不使用双括号, 则为for i in <code>seq 0 4</code>或者for i in {0..4}。再如可以直接使用if (($i&lt;5)), 如果不使用双括号, 则为if [ $i -lt 5 ]。</p>
<h2 id="heading-1">[]</h2>
<p>①bash 的内部命令，[和test是等同的。如果我们不用绝对路径指明，通常我们用的都是bash自带的命令。if/test结构中的左中括号是调用test的命令标识，右中括号是关闭条件判断的。这个命令把它的参数作为比较表达式或者作为文件测试，并且根据比较的结果来返回一个退出状态码。if/test结构中并不是必须右中括号，但是新版的Bash中要求必须这样。</p>
<p>②Test和[]中可用的比较运算符只有==和!=，两者都是用于字符串比较的，不可用于整数比较，整数比较只能使用-eq，-gt这种形式。无论是字符串比较还是整数比较都不支持大于号小于号。如果实在想用，对于字符串比较可以使用转义形式，如果比较&quot;ab&quot;和&quot;bc&quot;：[ ab &lt; bc ]，结果为真，也就是返回状态为0。[ ]中的逻辑与和逻辑或使用-a 和-o 表示。</p>
<p>③字符范围。用作正则表达式的一部分，描述一个匹配的字符范围。作为test用途的中括号内不能使用正则。   ④在一个array 结构的上下文中，中括号用来引用数组中每个元素的编号。</p>
<h2 id="--1">[[ ]]</h2>
<p>①[[是 bash 程序语言的关键字。并不是一个命令，[[ ]] 结构比[ ]结构更加通用。在[[和]]之间所有的字符都不会发生文件名扩展或者单词分割，但是会发生参数扩展和命令替换。</p>
<p>②支持字符串的模式匹配，使用=~操作符时甚至支持shell的正则表达式。字符串比较时可以把右边的作为一个模式，而不仅仅是一个字符串，比如[[ hello == hell? ]]，结果为真。[[ ]] 中匹配字符串或通配符，不需要引号。</p>
<p>③使用[[ &hellip; ]]条件判断结构，而不是[ &hellip; ]，能够防止脚本中的许多逻辑错误。比如，&amp;&amp;、||、&lt;和&gt; 操作符能够正常存在于[[ ]]条件判断结构中，但是如果出现在[ ]结构中的话，会报错。比如可以直接使用if [[ $a != 1 &amp;&amp; $a != 2 ]], 如果不适用双括号, 则为if [ $a -ne 1] &amp;&amp; [ $a != 2 ]或者if [ $a -ne 1 -a $a != 2 ]。</p>
<p>④bash把双中括号中的表达式看作一个单独的元素，并返回一个退出状态码。</p>
<h1 id="du">du</h1>
<p>命令用于显示目录或文件的大小</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">-a或-all 显示目录中个别文件的大小。
-b或-bytes 显示目录或文件大小时，以byte为单位。
-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。
-D或--dereference-args 显示指定符号连接的源文件大小。
-h或--human-readable 以K，M，G为单位，提高信息的可读性。
-H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。
-k或--kilobytes 以1024 bytes为单位。
-l或--count-links 重复计算硬件连接的文件。
-L&lt;符号连接&gt;或--dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。
-m或--megabytes 以1MB为单位。
-s或--summarize 仅显示总计。
-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。
-x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。
-X&lt;文件&gt;或--exclude-from<span style="color:#f92672">=</span>&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。
--exclude<span style="color:#f92672">=</span>&lt;目录或文件&gt; 略过指定的目录或文件。
--max-depth<span style="color:#f92672">=</span>&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。
--help 显示帮助。
--version 显示版本信息。
</code></pre></div><h1 id="awk">awk</h1>
<p><strong>awk</strong>是一个强大的文本分析工具</p>
<p>参数：</p>
<ul>
<li>-F  指定分隔符</li>
<li>-f  调用脚本</li>
<li>-v  定义变量</li>
</ul>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">awk中字符的含义：
$0           表示整个当前行
$1           每行第一个字段
NF          字段数量变量
NR          每行的记录号，多文件记录递增
FNR        与NR类似，不过多文件记录不递增，每个文件都从1开始
<span style="color:#ae81ff">\t</span>            制表符
<span style="color:#ae81ff">\n</span>           换行符
FS          BEGIN时定义分隔符
RS         输入的记录分隔符， 默认为换行符<span style="color:#f92672">(</span>即文本是按一行一行输入<span style="color:#f92672">)</span>
~            包含
!~           不包含
<span style="color:#f92672">==</span>         等于，必须全部相等，精确比较
!<span style="color:#f92672">=</span>           不等于，精确比较
<span style="color:#f92672">&amp;&amp;</span>         逻辑与
<span style="color:#f92672">||</span>             逻辑或

匹配时表示1个或1个以上
/<span style="color:#f92672">[</span>0-9<span style="color:#f92672">][</span>0-9<span style="color:#f92672">]</span>+/     两个或两个以上数字
/<span style="color:#f92672">[</span>0-9<span style="color:#f92672">][</span>0-9<span style="color:#f92672">]</span>*/     一个或一个以上数字
OFS         输出字段分隔符， 默认也是空格，可以改为其他的
ORS        输出的记录分隔符，默认为换行符,即处理结果也是一行一行输出到屏幕
-F  <span style="color:#f92672">[</span>:#/<span style="color:#f92672">]</span>    定义了三个分隔符
print 打印
print 是 awk打印指定内容的主要命令，也可以用 printf
awk <span style="color:#e6db74">&#39;{print}&#39;</span>  /etc/passwd   <span style="color:#f92672">==</span>   awk <span style="color:#e6db74">&#39;{print $0}&#39;</span>  /etc/passwd  
awk <span style="color:#e6db74">&#39;{print &#34; &#34;}&#39;</span>  /etc/passwd          不输出passwd的内容，而是输出相同个数的空行，进一步解释了awk是一行一行处理文本
awk <span style="color:#e6db74">&#39;{print &#34;a&#34;}&#39;</span>   /etc/passwd                                        输出相同个数的a行，一行只有一个a字母
awk -F:  <span style="color:#e6db74">&#39;{print $1}&#39;</span>  /etc/passwd  <span style="color:#f92672">==</span>   awk  -F  <span style="color:#e6db74">&#34;:&#34;</span>  <span style="color:#e6db74">&#39;{print $1}&#39;</span>  /etc/passwd
awk -F: <span style="color:#e6db74">&#39;{print $1 $2}&#39;</span>                                                 输入字段1,2，中间不分隔
awk -F: <span style="color:#e6db74">&#39;{print $1,$3,$6}&#39;</span> OFS<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;\t&#34;</span> /etc/passwd          输出字段1,3,6， 以制表符作为分隔符
awk -F: <span style="color:#e6db74">&#39;{print $1; print $2}&#39;</span>   /etc/passwd                   输入字段1,2，分行输出
awk -F: <span style="color:#e6db74">&#39;{print $1 &#34;**&#34; print $2}&#39;</span>   /etc/passwd                输入字段1,2，中间以**分隔
awk -F: <span style="color:#e6db74">&#39;{print &#34;name:&#34;$1&#34;\tid:&#34;$3}&#39;</span> /etc/passwd            自定义格式输出字段1,2
awk -F: <span style="color:#e6db74">&#39;{print NF}&#39;</span> /etc/passwd                                     显示每行有多少字段
awk -F: <span style="color:#e6db74">&#39;NF&gt;2{print }&#39;</span> /etc/passwd                                 将每行字段数大于2的打印出来
awk -F: <span style="color:#e6db74">&#39;NR==5{print}&#39;</span> /etc/passwd                               打印出/etc/passwd文件中的第5行
awk -F: <span style="color:#e6db74">&#39;NR==5|NR==6{print}&#39;</span> /etc/passwd                   打印出/etc/passwd文件中的第5行和第6行
awk -F: <span style="color:#e6db74">&#39;NR!=1{print}&#39;</span>  /etc/passwd                               不显示第一行
awk -F: <span style="color:#e6db74">&#39;{print &gt; &#34;1.txt&#34;}&#39;</span>  /etc/passwd                            输出到文件中
awk -F: <span style="color:#e6db74">&#39;{print}&#39;</span> /etc/passwd &gt; 2.txt                                使用重定向输出到文件中                                     
字符匹配
awk  -F: <span style="color:#e6db74">&#39;/root/{print }&#39;</span>  /etc/passwd                         打印出文件中含有root的行
awk  -F: <span style="color:#e6db74">&#39;/&#39;</span>$A<span style="color:#e6db74">&#39;/{print }&#39;</span>  /etc/passwd                         打印出文件中含有变量 $A的行
awk -F: <span style="color:#e6db74">&#39;!/root/{print}&#39;</span> /etc/passwd                           打印出文件中不含有root的行
awk -F:  <span style="color:#e6db74">&#39;/root|tom/{print}&#39;</span>  /etc/passwd                    打印出文件中含有root或者tom的行
awk -F: <span style="color:#e6db74">&#39;/mail/,mysql/{print}&#39;</span>  test                            打印出文件中含有 mail*mysql 的行，*代表有0个或任意多个字符
awk -F: <span style="color:#e6db74">&#39;/^[2][7][7]*/{print}&#39;</span>  test                              打印出文件中以27开头的行，如27,277,27gff 等等
 
awk -F: <span style="color:#e6db74">&#39;$1~/root/{print}&#39;</span> /etc/passwd                     打印出文件中第一个字段是root的行
awk -F: <span style="color:#e6db74">&#39;($1==&#34;root&#34;){print}&#39;</span> /etc/passwd               打印出文件中第一个字段是root的行，与上面的等效
awk -F: <span style="color:#e6db74">&#39;$1!~/root/{print}&#39;</span> /etc/passwd                   打印出文件中第一个字段不是root的行
awk -F: <span style="color:#e6db74">&#39;($1!=&#34;root&#34;){print}&#39;</span> /etc/passwd                打印出文件中第一个字段不是root的行，与上面的等效
awk -F: <span style="color:#e6db74">&#39;$1~/root|ftp/{print}&#39;</span> /etc/passwd               打印出文件中第一个字段是root或ftp的行
awk -F: <span style="color:#e6db74">&#39;($1==&#34;root&#34;||$1==&#34;ftp&#34;){print}&#39;</span> /etc/passwd   打印出文件中第一个字段是root或ftp的行，与上面的等效
awk -F: <span style="color:#e6db74">&#39;$1!~/root|ftp/{print}&#39;</span> /etc/passwd              打印出文件中第一个字段不是root或不是ftp的行
awk -F: <span style="color:#e6db74">&#39;($1!=&#34;root&#34;||$1!=&#34;ftp&#34;){print}&#39;</span> /etc/passwd    打印出文件中第一个字段不是root或不是ftp的行，与上面等效
awk -F: <span style="color:#e6db74">&#39;{if($1~/mail/) {print $1} else {print $2}}&#39;</span>  /etc/passwd   如果第一个字段是mail，则打印第一个字段，否则打印第2个字段

</code></pre></div><h2 id="例子">例子</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell">举例：
1、显示 /etc/passwd 中含有 root 的行
awk <span style="color:#e6db74">&#39;/root/&#39;</span>  /etc/passwd
2、以 : 为分隔，显示/etc/passwd中每行的第1和第7个字段
awk -F <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#e6db74">&#39;{print $1,$7}&#39;</span> /etc/passwd  或  awk <span style="color:#e6db74">&#39;BEGIN{FS=&#34;:&#34;}{print $1,$7}&#39;</span> /etc/passwd
3、以 : 为分隔，显示/etc/passwd中含有 root 的行的第1和第7个字段
awk -F <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#e6db74">&#39;/root/{print $1,$7}&#39;</span> /etc/passwd
4、以 : 为分隔，显示/etc/passwd中以 root 开头行的第1和第7个字段
awk -F <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#e6db74">&#39;/^root/{print $1,$7}&#39;</span> /etc/passwd
5、以 : 为分隔，显示/etc/passwd中第3个字段大于999的行的第1和第7个字段
awk -F <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#e6db74">&#39;$3&gt;999{print $1,$7}&#39;</span>  /etc/passwd
6、以 : 为分隔，显示/etc/passwd中第7个字段包含bash的行的第1和第7个字段
awk -F <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#e6db74">&#39;$7~&#34;bash&#34;{print $1,$7}&#39;</span> /etc/passwd
7、以 : 为分隔，显示/etc/passwd中第7个字段不包含bash的行的第1和第7个字段
awk -F <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#e6db74">&#39;$7!~&#34;nologin&#34;{print $1,$7}&#39;</span>  /etc/passwd
8、以 : 为分隔，显示$3&gt;999并且第7个字段包含bash的行的第1和第7个字段
awk -F <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#e6db74">&#39;$3&gt;999&amp;&amp;$7~&#34;bash&#34;{print $1,$7}&#39;</span> /etc/passwd
9、以 : 为分隔，显示$3&gt;999或第7个字段包含bash的行的第1和第7个字段
awk -F <span style="color:#e6db74">&#34;:&#34;</span> <span style="color:#e6db74">&#39;$3&gt;999||$7~&#34;bash&#34;{print $1,$7}&#39;</span> /etc/passwd



1、打印文件的第一列<span style="color:#f92672">(</span>域<span style="color:#f92672">)</span> ：
 awk <span style="color:#e6db74">&#39;{print $1}&#39;</span> filename
 
2、打印文件的前两列<span style="color:#f92672">(</span>域<span style="color:#f92672">)</span> ：
 awk <span style="color:#e6db74">&#39;{print $1,$2}&#39;</span> filename
 
3、打印完第一列，然后打印第二列 ： 
awk <span style="color:#e6db74">&#39;{print $1 $2}&#39;</span> filename

4、打印文本文件的总行数 ： 
awk <span style="color:#e6db74">&#39;END{print NR}&#39;</span> filename

5、打印文本第一行 ：
awk <span style="color:#e6db74">&#39;NR==1{print}&#39;</span> filename

6、打印文本第二行第一列 ：
sed -n <span style="color:#e6db74">&#34;2, 1p&#34;</span> filename | awk <span style="color:#e6db74">&#39;print $1&#39;</span>



1. 获取第一列
ps -aux | grep watchdog | awk <span style="color:#e6db74">&#39;{print $1}&#39;</span>

2. 获取第一列，第二列，第三列
ps -aux | grep watchdog | awk <span style="color:#e6db74">&#39;{print $1, $2, $3}&#39;</span>

3. 获取第一行的第一列，第二列，第三列
ps -aux | grep watchdog | awk <span style="color:#e6db74">&#39;NR==1{print $1, $2, $3}&#39;</span>

4. 获取行数NR
df -h | awk <span style="color:#e6db74">&#39;END{print NR}&#39;</span>

5. 获取列数NF（这里是获取最后一行的列数，注意每行的列数可能是不同的）
ps -aux | grep watchdog | awk <span style="color:#e6db74">&#39;END{print NF}&#39;</span>

6. 获取最后一列
ps -aux | grep watchdog | awk <span style="color:#e6db74">&#39;{print $NF}&#39;</span>

7. 对文件进行操作
awk <span style="color:#e6db74">&#39;{print $1}&#39;</span> fileName

8. 指定分隔符（这里以:分割）
ps -aux | grep watchdog |awk  -F<span style="color:#e6db74">&#39;:&#39;</span> <span style="color:#e6db74">&#39;{print $1}&#39;</span>

9. 超出范围不报错
ps -aux | grep watchdog | awk <span style="color:#e6db74">&#39;{print $100}&#39;</span>


</code></pre></div><h1 id="sed">sed</h1>
<p>sed 是一种在线编辑器，它一次处理一行内容。处理时，把当前处理的行存储在临时缓冲区中，称为“模式空间”（pattern space），接着用sed命令处理缓冲区中的内容，处理完成后，把缓冲区的内容送往屏幕。接着处理下一行，这样不断重复，直到文件末尾。文件内容并没有 改变，除非你使用重定向存储输出。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>
<h2 id="sed使用参数"><strong>sed使用参数</strong></h2>
<p><a href=""><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<pre><code>[root@www ~]# sed [-nefr] [动作]
选项与参数：
-n ：使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN 的数据一般都会被列出到终端上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。
-e ：直接在命令列模式上进行 sed 的动作编辑；
-f ：直接将 sed 的动作写在一个文件内， -f filename 则可以运行 filename 内的 sed 动作；
-r ：sed 的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)
-i ：直接修改读取的文件内容，而不是输出到终端。

动作说明： [n1[,n2]]function
n1, n2 ：不见得会存在，一般代表『选择进行动作的行数』，举例来说，如果我的动作是需要在 10 到 20 行之间进行的，则『 10,20[动作行为] 』

function：
a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
p ：列印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～
s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 1,20s/old/new/g 就是啦！
</code></pre><p><a href=""><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<h2 id="以行为单位的新增删除"><strong>以行为单位的新增/删除</strong></h2>
<p>将 /etc/passwd 的内容列出并且列印行号，同时，请将第 2~5 行删除！</p>
<pre><code>[root@www ~]# nl /etc/passwd | sed '2,5d'
1 root❌0:0:root:/root:/bin/bash
6 sync❌5:0:sync:/sbin:/bin/sync
7 shutdown❌6:0:shutdown:/sbin:/sbin/shutdown
.....(后面省略).....
</code></pre><p>sed 的动作为 &lsquo;2,5d&rsquo; ，那个 d 就是删除！因为 2-5 行给他删除了，所以显示的数据就没有 2-5 行罗～ 另外，注意一下，原本应该是要下达 sed -e 才对，没有 -e 也行啦！同时也要注意的是， sed 后面接的动作，请务必以 '' 两个单引号括住喔！</p>
<p>只要删除第 2 行</p>
<pre><code>nl /etc/passwd | sed '2d' 
</code></pre><p>要删除第 3 到最后一行</p>
<pre><code> nl /etc/passwd | sed '3,$d' 
</code></pre><p>在第二行后(亦即是加在第三行)加上『drink tea?』字样！</p>
<pre><code>[root@www ~]# nl /etc/passwd | sed '2a drink tea'
1 root❌0:0:root:/root:/bin/bash
2 bin❌1:1:bin:/bin:/sbin/nologin
drink tea
3 daemon❌2:2:daemon:/sbin:/sbin/nologin
.....(后面省略).....
</code></pre><p>那如果是要在第二行前</p>
<pre><code> nl /etc/passwd | sed '2i drink tea' 
</code></pre><p>如果是要增加两行以上，在第二行后面加入两行字，例如『Drink tea or &hellip;..』与『drink beer?』</p>
<p><a href=""><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<pre><code>[root@www ~]# nl /etc/passwd | sed '2a Drink tea or ......\
&gt; drink beer ?'
1 root❌0:0:root:/root:/bin/bash
2 bin❌1:1:bin:/bin:/sbin/nologin
Drink tea or ......
drink beer ?
3 daemon❌2:2:daemon:/sbin:/sbin/nologin
.....(后面省略).....
</code></pre><p><a href=""><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>每一行之间都必须要以反斜杠『 \ 』来进行新行的添加喔！所以，上面的例子中，我们可以发现在第一行的最后面就有 \ 存在。</p>
<h2 id="以行为单位的替换与显示"><strong>以行为单位的替换与显示</strong></h2>
<p>将第2-5行的内容取代成为『No 2-5 number』呢？</p>
<pre><code>[root@www ~]# nl /etc/passwd | sed '2,5c No 2-5 number'
1 root❌0:0:root:/root:/bin/bash
No 2-5 number
6 sync❌5:0:sync:/sbin:/bin/sync
.....(后面省略).....
</code></pre><p>透过这个方法我们就能够将数据整行取代了！</p>
<p>仅列出 /etc/passwd 文件内的第 5-7 行</p>
<pre><code>[root@www ~]# nl /etc/passwd | sed -n '5,7p'
5 lp❌4:7:lp:/var/spool/lpd:/sbin/nologin
6 sync❌5:0:sync:/sbin:/bin/sync
7 shutdown❌6:0:shutdown:/sbin:/sbin/shutdown
</code></pre><p>可以透过这个 sed 的以行为单位的显示功能， 就能够将某一个文件内的某些行号选择出来显示。</p>
<h2 id="heading-2"></h2>
<h2 id="数据的搜寻并显示"><strong>数据的搜寻并显示</strong></h2>
<p>搜索 /etc/passwd有root关键字的行</p>
<p><a href=""><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<pre><code>nl /etc/passwd | sed '/root/p'
1  root❌0:0:root:/root:/bin/bash
1  root❌0:0:root:/root:/bin/bash
2  daemon❌1:1:daemon:/usr/sbin:/bin/sh
3  bin❌2:2:bin:/bin:/bin/sh
4  sys❌3:3:sys:/dev:/bin/sh
5  sync❌4:65534:sync:/bin:/bin/sync
....下面忽略 
</code></pre><p><a href=""><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a></p>
<p>如果root找到，除了输出所有行，还会输出匹配行。</p>
<p>使用-n的时候将只打印包含模板的行。</p>
<pre><code>nl /etc/passwd | sed -n '/root/p'
1  root❌0:0:root:/root:/bin/bash
</code></pre><h2 id="数据的搜寻并删除"><strong>数据的搜寻并删除</strong></h2>
<p>删除/etc/passwd所有包含root的行，其他行输出</p>
<pre><code>nl /etc/passwd | sed  '/root/d'
2  daemon❌1:1:daemon:/usr/sbin:/bin/sh
3  bin❌2:2:bin:/bin:/bin/sh
....下面忽略
#第一行的匹配root已经删除了
</code></pre><h2 id="数据的搜寻并执行命令"><strong>数据的搜寻并执行命令</strong></h2>
<p>找到匹配模式eastern的行后，</p>
<p>搜索/etc/passwd,找到root对应的行，执行后面花括号中的一组命令，每个命令之间用分号分隔，这里把bash替换为blueshell，再输出这行：</p>
<pre><code> nl /etc/passwd | sed -n '/root/{s/bash/blueshell/;p}'
 1  root❌0:0:root:/root:/bin/blueshell
</code></pre><p>如果只替换/etc/passwd的第一个bash关键字为blueshell，就退出</p>
<pre><code>nl /etc/passwd | sed -n '/bash/{s/bash/blueshell/;p;q}'    
1  root❌0:0:root:/root:/bin/blueshell
</code></pre><p>最后的q是退出。</p>
<h2 id="数据的搜寻并替换"><strong>数据的搜寻并替换</strong></h2>
<p>除了整行的处理模式之外， sed 还可以用行为单位进行部分数据的搜寻并取代。基本上 sed 的搜寻与替代的与 vi 相当的类似！他有点像这样：</p>
<pre><code>sed 's/要被取代的字串/新的字串/g'
</code></pre><p>先观察原始信息，利用 /sbin/ifconfig 查询 IP</p>
<pre><code>[root@www ~]# /sbin/ifconfig eth0
eth0 Link encap:Ethernet HWaddr 00:90:CC:A6:34:84
inet addr:192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0
inet6 addr: fe80::290:ccff:fea6:3484/64 Scope:Link
UP BROADCAST RUNNING MULTICAST MTU:1500 Metric:1
.....(以下省略).....
</code></pre><p>本机的ip是192.168.1.100。</p>
<p>将 IP 前面的部分予以删除</p>
<pre><code>[root@www ~]# /sbin/ifconfig eth0 | grep 'inet addr' | sed 's/^.*addr://g'
192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0
</code></pre><p>接下来则是删除后续的部分，亦即： 192.168.1.100 Bcast:192.168.1.255 Mask:255.255.255.0</p>
<p>将 IP 后面的部分予以删除</p>
<pre><code>[root@www ~]# /sbin/ifconfig eth0 | grep 'inet addr' | sed 's/^.*addr://g' | sed 's/Bcast.*$//g'
192.168.1.100
</code></pre><h2 id="多点编辑"><strong>多点编辑</strong></h2>
<p>一条sed命令，删除/etc/passwd第三行到末尾的数据，并把bash替换为blueshell</p>
<pre><code>nl /etc/passwd | sed -e '3,$d' -e 's/bash/blueshell/'
1  root❌0:0:root:/root:/bin/blueshell
2  daemon❌1:1:daemon:/usr/sbin:/bin/sh
</code></pre><p>-e表示多点编辑，第一个编辑命令删除/etc/passwd第三行到末尾的数据，第二条命令搜索bash替换为blueshell。</p>
<h2 id="直接修改文件内容危险动作"><strong>直接修改文件内容(危险动作)</strong></h2>
<p>sed 可以直接修改文件的内容，不必使用管道命令或数据流重导向！ 不过，由於这个动作会直接修改到原始的文件，所以请你千万不要随便拿系统配置来测试！ 我们还是使用下载的 regular_express.txt 文件来测试看看吧！</p>
<p>利用 sed 将 regular_express.txt 内每一行结尾若为 . 则换成 !</p>
<pre><code>[root@www ~]# sed -i 's/\.$/\!/g' regular_express.txt
</code></pre><p>利用 sed 直接在 regular_express.txt 最后一行加入『# This is a test』</p>
<pre><code>[root@www ~]# sed -i '$a # This is a test' regular_express.txt
</code></pre><p>由於 $ 代表的是最后一行，而 a 的动作是新增，因此该文件最后新增『# This is a test』！</p>
<h1 id="cut">cut</h1>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#f92672">[</span>root@localhost ~<span style="color:#f92672">]</span>$ cut <span style="color:#f92672">[</span>选项<span style="color:#f92672">]</span> 文件名
选项:
-f 列号: 提取第几列
-d 分隔符: 按照指定分隔符分割列
-n	取消分割多字节字符
-c 字符范围: 不依赖分隔符来区分列，而是通过字符范围（行首为0）来进行字段提取。“n-”表示从第n个字符到行尾;“n-m”从第n个字符到第m个字符;“一m”表示从第1个字符到第m个字符。
--complement	补足被选择的字节、字符或字段
--out-delimiter	指定输出内容是的字段分割符

</code></pre></div><p>cut命令的默认分隔符是制表符，也就是“tab”键，不过对空格符可是支持的不怎么好啊。我们先建立一个测试文件，然后看看cut命令的作用吧:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-shell" data-lang="shell"><span style="color:#f92672">[</span>root@localhost ~<span style="color:#f92672">]</span>$ vi student.txt
id	name	gender	mark
1	liming	m		<span style="color:#ae81ff">86</span>
2	sc		m		<span style="color:#ae81ff">67</span>
3	tg		n		<span style="color:#ae81ff">90</span>


</code></pre></div><h2 id="例子-1">例子</h2>
<p>如果我想用cut命令截取df命令的第一列和第三列，就会出现这样的情况:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-powershell" data-lang="powershell">[root@localhost~]$ df -h | cut -d <span style="color:#e6db74">&#34; &#34;</span> <span style="color:#f92672">-f</span> 1,3
Filesystem 
/dev/sda2 
tmpfs 
/dev/sda1
12345
</code></pre></div>
    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>Jiang . </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=https://jfy0o0.github.io/2021/linux-shell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/>https://jfy0o0.github.io/2021/linux-shell%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
            <section>
            <i class="iconfont icon-tag"></i>Tag(s): 
            
            <span class="tag"><a href="https://jfy0o0.github.io/tags/linux/">
                    #Linux</a></span>
            
            </section>
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="https://jfy0o0.github.io">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="https://jfy0o0.github.io/2021/linux-%E8%BD%AF%E4%BB%B6-inotifywait/" class="prev" rel="prev" title="Linux Soft - inotifywait"><i class="iconfont icon-left"></i>&nbsp;Linux Soft - inotifywait</a>
         
        
        <a href="https://jfy0o0.github.io/2021/cpp_%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/" class="next" rel="next" title="C&#43;&#43; - 性能测试">C&#43;&#43; - 性能测试&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2011 - 2021</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="https://jfy0o0.github.io">Jiang .</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
     <link href="//lib.baomitu.com/lightgallery/1.6.11/css/lightgallery.min.css" rel="stylesheet">  
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  



     </div>
  </body>
</html>
